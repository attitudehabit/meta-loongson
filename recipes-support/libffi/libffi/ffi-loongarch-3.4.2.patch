diff -urN libffi-3.4.2.ori/config.guess libffi-3.4.2/config.guess
--- libffi-3.4.2.ori/config.guess	2021-06-27 23:17:08.000000000 +0800
+++ libffi-3.4.2/config.guess	2022-11-01 23:29:36.084249111 +0800
@@ -991,6 +991,9 @@
     m68*:Linux:*:*)
 	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
 	exit ;;
+    loongarch*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
     mips:Linux:*:* | mips64:Linux:*:*)
 	set_cc_for_build
 	IS_GLIBC=0
diff -urN libffi-3.4.2.ori/config.guess.orig libffi-3.4.2/config.guess.orig
--- libffi-3.4.2.ori/config.guess.orig	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/config.guess.orig	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,1687 @@
+#! /bin/sh
+# Attempt to guess a canonical system name.
+#   Copyright 1992-2020 Free Software Foundation, Inc.
+
+timestamp='2020-07-12'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+#
+# Originally written by Per Bothner; maintained since 2000 by Ben Elliston.
+#
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+#
+# Please send patches to <config-patches@gnu.org>.
+
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION]
+
+Output the configuration name of the system \`$me' is run on.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.guess ($timestamp)
+
+Originally written by Per Bothner.
+Copyright 1992-2020 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+    * )
+       break ;;
+  esac
+done
+
+if test $# != 0; then
+  echo "$me: too many arguments$help" >&2
+  exit 1
+fi
+
+# CC_FOR_BUILD -- compiler used by this script. Note that the use of a
+# compiler to aid in system detection is discouraged as it requires
+# temporary files to be created and, as you can see below, it is a
+# headache to deal with in a portable fashion.
+
+# Historically, `CC_FOR_BUILD' used to be named `HOST_CC'. We still
+# use `HOST_CC' if defined, but it is deprecated.
+
+# Portable tmp directory creation inspired by the Autoconf team.
+
+tmp=
+# shellcheck disable=SC2172
+trap 'test -z "$tmp" || rm -fr "$tmp"' 0 1 2 13 15
+
+set_cc_for_build() {
+    # prevent multiple calls if $tmp is already set
+    test "$tmp" && return 0
+    : "${TMPDIR=/tmp}"
+    # shellcheck disable=SC2039
+    { tmp=`(umask 077 && mktemp -d "$TMPDIR/cgXXXXXX") 2>/dev/null` && test -n "$tmp" && test -d "$tmp" ; } ||
+	{ test -n "$RANDOM" && tmp=$TMPDIR/cg$$-$RANDOM && (umask 077 && mkdir "$tmp" 2>/dev/null) ; } ||
+	{ tmp=$TMPDIR/cg-$$ && (umask 077 && mkdir "$tmp" 2>/dev/null) && echo "Warning: creating insecure temp directory" >&2 ; } ||
+	{ echo "$me: cannot create a temporary directory in $TMPDIR" >&2 ; exit 1 ; }
+    dummy=$tmp/dummy
+    case ${CC_FOR_BUILD-},${HOST_CC-},${CC-} in
+	,,)    echo "int x;" > "$dummy.c"
+	       for driver in cc gcc c89 c99 ; do
+		   if ($driver -c -o "$dummy.o" "$dummy.c") >/dev/null 2>&1 ; then
+		       CC_FOR_BUILD="$driver"
+		       break
+		   fi
+	       done
+	       if test x"$CC_FOR_BUILD" = x ; then
+		   CC_FOR_BUILD=no_compiler_found
+	       fi
+	       ;;
+	,,*)   CC_FOR_BUILD=$CC ;;
+	,*,*)  CC_FOR_BUILD=$HOST_CC ;;
+    esac
+}
+
+# This is needed to find uname on a Pyramid OSx when run in the BSD universe.
+# (ghazi@noc.rutgers.edu 1994-08-24)
+if test -f /.attbin/uname ; then
+	PATH=$PATH:/.attbin ; export PATH
+fi
+
+UNAME_MACHINE=`(uname -m) 2>/dev/null` || UNAME_MACHINE=unknown
+UNAME_RELEASE=`(uname -r) 2>/dev/null` || UNAME_RELEASE=unknown
+UNAME_SYSTEM=`(uname -s) 2>/dev/null`  || UNAME_SYSTEM=unknown
+UNAME_VERSION=`(uname -v) 2>/dev/null` || UNAME_VERSION=unknown
+
+case "$UNAME_SYSTEM" in
+Linux|GNU|GNU/*)
+	# If the system lacks a compiler, then just pick glibc.
+	# We could probably try harder.
+	LIBC=gnu
+
+	set_cc_for_build
+	cat <<-EOF > "$dummy.c"
+	#include <features.h>
+	#if defined(__UCLIBC__)
+	LIBC=uclibc
+	#elif defined(__dietlibc__)
+	LIBC=dietlibc
+	#else
+	LIBC=gnu
+	#endif
+	EOF
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^LIBC' | sed 's, ,,g'`"
+
+	# If ldd exists, use it to detect musl libc.
+	if command -v ldd >/dev/null && \
+		ldd --version 2>&1 | grep -q ^musl
+	then
+	    LIBC=musl
+	fi
+	;;
+esac
+
+# Note: order is significant - the case branches are not exclusive.
+
+case "$UNAME_MACHINE:$UNAME_SYSTEM:$UNAME_RELEASE:$UNAME_VERSION" in
+    *:NetBSD:*:*)
+	# NetBSD (nbsd) targets should (where applicable) match one or
+	# more of the tuples: *-*-netbsdelf*, *-*-netbsdaout*,
+	# *-*-netbsdecoff* and *-*-netbsd*.  For targets that recently
+	# switched to ELF, *-*-netbsd* would select the old
+	# object file format.  This provides both forward
+	# compatibility and a consistent mechanism for selecting the
+	# object file format.
+	#
+	# Note: NetBSD doesn't particularly care about the vendor
+	# portion of the name.  We always set it to "unknown".
+	sysctl="sysctl -n hw.machine_arch"
+	UNAME_MACHINE_ARCH=`(uname -p 2>/dev/null || \
+	    "/sbin/$sysctl" 2>/dev/null || \
+	    "/usr/sbin/$sysctl" 2>/dev/null || \
+	    echo unknown)`
+	case "$UNAME_MACHINE_ARCH" in
+	    armeb) machine=armeb-unknown ;;
+	    arm*) machine=arm-unknown ;;
+	    sh3el) machine=shl-unknown ;;
+	    sh3eb) machine=sh-unknown ;;
+	    sh5el) machine=sh5le-unknown ;;
+	    earmv*)
+		arch=`echo "$UNAME_MACHINE_ARCH" | sed -e 's,^e\(armv[0-9]\).*$,\1,'`
+		endian=`echo "$UNAME_MACHINE_ARCH" | sed -ne 's,^.*\(eb\)$,\1,p'`
+		machine="${arch}${endian}"-unknown
+		;;
+	    *) machine="$UNAME_MACHINE_ARCH"-unknown ;;
+	esac
+	# The Operating System including object format, if it has switched
+	# to ELF recently (or will in the future) and ABI.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		os=netbsdelf
+		;;
+	    arm*|i386|m68k|ns32k|sh3*|sparc|vax)
+		set_cc_for_build
+		if echo __ELF__ | $CC_FOR_BUILD -E - 2>/dev/null \
+			| grep -q __ELF__
+		then
+		    # Once all utilities can be ECOFF (netbsdecoff) or a.out (netbsdaout).
+		    # Return netbsd for either.  FIX?
+		    os=netbsd
+		else
+		    os=netbsdelf
+		fi
+		;;
+	    *)
+		os=netbsd
+		;;
+	esac
+	# Determine ABI tags.
+	case "$UNAME_MACHINE_ARCH" in
+	    earm*)
+		expr='s/^earmv[0-9]/-eabi/;s/eb$//'
+		abi=`echo "$UNAME_MACHINE_ARCH" | sed -e "$expr"`
+		;;
+	esac
+	# The OS release
+	# Debian GNU/NetBSD machines have a different userland, and
+	# thus, need a distinct triplet. However, they do not need
+	# kernel version information, so it can be replaced with a
+	# suitable tag, in the style of linux-gnu.
+	case "$UNAME_VERSION" in
+	    Debian*)
+		release='-gnu'
+		;;
+	    *)
+		release=`echo "$UNAME_RELEASE" | sed -e 's/[-_].*//' | cut -d. -f1,2`
+		;;
+	esac
+	# Since CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM:
+	# contains redundant information, the shorter form:
+	# CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM is used.
+	echo "$machine-${os}${release}${abi-}"
+	exit ;;
+    *:Bitrig:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/Bitrig.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-bitrig"$UNAME_RELEASE"
+	exit ;;
+    *:OpenBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/OpenBSD.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-openbsd"$UNAME_RELEASE"
+	exit ;;
+    *:LibertyBSD:*:*)
+	UNAME_MACHINE_ARCH=`arch | sed 's/^.*BSD\.//'`
+	echo "$UNAME_MACHINE_ARCH"-unknown-libertybsd"$UNAME_RELEASE"
+	exit ;;
+    *:MidnightBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-midnightbsd"$UNAME_RELEASE"
+	exit ;;
+    *:ekkoBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-ekkobsd"$UNAME_RELEASE"
+	exit ;;
+    *:SolidBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-solidbsd"$UNAME_RELEASE"
+	exit ;;
+    *:OS108:*:*)
+	echo "$UNAME_MACHINE"-unknown-os108_"$UNAME_RELEASE"
+	exit ;;
+    macppc:MirBSD:*:*)
+	echo powerpc-unknown-mirbsd"$UNAME_RELEASE"
+	exit ;;
+    *:MirBSD:*:*)
+	echo "$UNAME_MACHINE"-unknown-mirbsd"$UNAME_RELEASE"
+	exit ;;
+    *:Sortix:*:*)
+	echo "$UNAME_MACHINE"-unknown-sortix
+	exit ;;
+    *:Twizzler:*:*)
+	echo "$UNAME_MACHINE"-unknown-twizzler
+	exit ;;
+    *:Redox:*:*)
+	echo "$UNAME_MACHINE"-unknown-redox
+	exit ;;
+    mips:OSF1:*.*)
+	echo mips-dec-osf1
+	exit ;;
+    alpha:OSF1:*:*)
+	case $UNAME_RELEASE in
+	*4.0)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $3}'`
+		;;
+	*5.*)
+		UNAME_RELEASE=`/usr/sbin/sizer -v | awk '{print $4}'`
+		;;
+	esac
+	# According to Compaq, /usr/sbin/psrinfo has been available on
+	# OSF/1 and Tru64 systems produced since 1995.  I hope that
+	# covers most systems running today.  This code pipes the CPU
+	# types through head -n 1, so we only detect the type of CPU 0.
+	ALPHA_CPU_TYPE=`/usr/sbin/psrinfo -v | sed -n -e 's/^  The alpha \(.*\) processor.*$/\1/p' | head -n 1`
+	case "$ALPHA_CPU_TYPE" in
+	    "EV4 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "EV4.5 (21064)")
+		UNAME_MACHINE=alpha ;;
+	    "LCA4 (21066/21068)")
+		UNAME_MACHINE=alpha ;;
+	    "EV5 (21164)")
+		UNAME_MACHINE=alphaev5 ;;
+	    "EV5.6 (21164A)")
+		UNAME_MACHINE=alphaev56 ;;
+	    "EV5.6 (21164PC)")
+		UNAME_MACHINE=alphapca56 ;;
+	    "EV5.7 (21164PC)")
+		UNAME_MACHINE=alphapca57 ;;
+	    "EV6 (21264)")
+		UNAME_MACHINE=alphaev6 ;;
+	    "EV6.7 (21264A)")
+		UNAME_MACHINE=alphaev67 ;;
+	    "EV6.8CB (21264C)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8AL (21264B)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.8CX (21264D)")
+		UNAME_MACHINE=alphaev68 ;;
+	    "EV6.9A (21264/EV69A)")
+		UNAME_MACHINE=alphaev69 ;;
+	    "EV7 (21364)")
+		UNAME_MACHINE=alphaev7 ;;
+	    "EV7.9 (21364A)")
+		UNAME_MACHINE=alphaev79 ;;
+	esac
+	# A Pn.n version is a patched version.
+	# A Vn.n version is a released version.
+	# A Tn.n version is a released field test version.
+	# A Xn.n version is an unreleased experimental baselevel.
+	# 1.2 uses "1.2" for uname -r.
+	echo "$UNAME_MACHINE"-dec-osf"`echo "$UNAME_RELEASE" | sed -e 's/^[PVTX]//' | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`"
+	# Reset EXIT trap before exiting to avoid spurious non-zero exit code.
+	exitcode=$?
+	trap '' 0
+	exit $exitcode ;;
+    Amiga*:UNIX_System_V:4.0:*)
+	echo m68k-unknown-sysv4
+	exit ;;
+    *:[Aa]miga[Oo][Ss]:*:*)
+	echo "$UNAME_MACHINE"-unknown-amigaos
+	exit ;;
+    *:[Mm]orph[Oo][Ss]:*:*)
+	echo "$UNAME_MACHINE"-unknown-morphos
+	exit ;;
+    *:OS/390:*:*)
+	echo i370-ibm-openedition
+	exit ;;
+    *:z/VM:*:*)
+	echo s390-ibm-zvmoe
+	exit ;;
+    *:OS400:*:*)
+	echo powerpc-ibm-os400
+	exit ;;
+    arm:RISC*:1.[012]*:*|arm:riscix:1.[012]*:*)
+	echo arm-acorn-riscix"$UNAME_RELEASE"
+	exit ;;
+    arm*:riscos:*:*|arm*:RISCOS:*:*)
+	echo arm-unknown-riscos
+	exit ;;
+    SR2?01:HI-UX/MPP:*:* | SR8000:HI-UX/MPP:*:*)
+	echo hppa1.1-hitachi-hiuxmpp
+	exit ;;
+    Pyramid*:OSx*:*:* | MIS*:OSx*:*:* | MIS*:SMP_DC-OSx*:*:*)
+	# akee@wpdis03.wpafb.af.mil (Earle F. Ake) contributed MIS and NILE.
+	if test "`(/bin/universe) 2>/dev/null`" = att ; then
+		echo pyramid-pyramid-sysv3
+	else
+		echo pyramid-pyramid-bsd
+	fi
+	exit ;;
+    NILE*:*:*:dcosx)
+	echo pyramid-pyramid-svr4
+	exit ;;
+    DRS?6000:unix:4.0:6*)
+	echo sparc-icl-nx6
+	exit ;;
+    DRS?6000:UNIX_SV:4.2*:7* | DRS?6000:isis:4.2*:7*)
+	case `/usr/bin/uname -p` in
+	    sparc) echo sparc-icl-nx7; exit ;;
+	esac ;;
+    s390x:SunOS:*:*)
+	echo "$UNAME_MACHINE"-ibm-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	exit ;;
+    sun4H:SunOS:5.*:*)
+	echo sparc-hal-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	exit ;;
+    sun4*:SunOS:5.*:* | tadpole*:SunOS:5.*:*)
+	echo sparc-sun-solaris2"`echo "$UNAME_RELEASE" | sed -e 's/[^.]*//'`"
+	exit ;;
+    i86pc:AuroraUX:5.*:* | i86xen:AuroraUX:5.*:*)
+	echo i386-pc-auroraux"$UNAME_RELEASE"
+	exit ;;
+    i86pc:SunOS:5.*:* | i86xen:SunOS:5.*:*)
+	set_cc_for_build
+	SUN_ARCH=i386
+	# If there is a compiler, see if it is configured for 64-bit objects.
+	# Note that the Sun cc does not turn __LP64__ into 1 like gcc does.
+	# This test works for both compilers.
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	    if (echo '#ifdef __amd64'; echo IS_64BIT_ARCH; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_64BIT_ARCH >/dev/null
+	    then
+		SUN_ARCH=x86_64
+	    fi
+	fi
+	echo "$SUN_ARCH"-pc-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	exit ;;
+    sun4*:SunOS:6*:*)
+	# According to config.sub, this is the proper way to canonicalize
+	# SunOS6.  Hard to guess exactly what SunOS6 will be like, but
+	# it's likely to be more like Solaris than SunOS4.
+	echo sparc-sun-solaris3"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	exit ;;
+    sun4*:SunOS:*:*)
+	case "`/usr/bin/arch -k`" in
+	    Series*|S4*)
+		UNAME_RELEASE=`uname -v`
+		;;
+	esac
+	# Japanese Language versions have a version number like `4.1.3-JL'.
+	echo sparc-sun-sunos"`echo "$UNAME_RELEASE"|sed -e 's/-/_/'`"
+	exit ;;
+    sun3*:SunOS:*:*)
+	echo m68k-sun-sunos"$UNAME_RELEASE"
+	exit ;;
+    sun*:*:4.2BSD:*)
+	UNAME_RELEASE=`(sed 1q /etc/motd | awk '{print substr($5,1,3)}') 2>/dev/null`
+	test "x$UNAME_RELEASE" = x && UNAME_RELEASE=3
+	case "`/bin/arch`" in
+	    sun3)
+		echo m68k-sun-sunos"$UNAME_RELEASE"
+		;;
+	    sun4)
+		echo sparc-sun-sunos"$UNAME_RELEASE"
+		;;
+	esac
+	exit ;;
+    aushp:SunOS:*:*)
+	echo sparc-auspex-sunos"$UNAME_RELEASE"
+	exit ;;
+    # The situation for MiNT is a little confusing.  The machine name
+    # can be virtually everything (everything which is not
+    # "atarist" or "atariste" at least should have a processor
+    # > m68000).  The system name ranges from "MiNT" over "FreeMiNT"
+    # to the lowercase version "mint" (or "freemint").  Finally
+    # the system name "TOS" denotes a system which is actually not
+    # MiNT.  But MiNT is downward compatible to TOS, so this should
+    # be no problem.
+    atarist[e]:*MiNT:*:* | atarist[e]:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint"$UNAME_RELEASE"
+	exit ;;
+    atari*:*MiNT:*:* | atari*:*mint:*:* | atarist[e]:*TOS:*:*)
+	echo m68k-atari-mint"$UNAME_RELEASE"
+	exit ;;
+    *falcon*:*MiNT:*:* | *falcon*:*mint:*:* | *falcon*:*TOS:*:*)
+	echo m68k-atari-mint"$UNAME_RELEASE"
+	exit ;;
+    milan*:*MiNT:*:* | milan*:*mint:*:* | *milan*:*TOS:*:*)
+	echo m68k-milan-mint"$UNAME_RELEASE"
+	exit ;;
+    hades*:*MiNT:*:* | hades*:*mint:*:* | *hades*:*TOS:*:*)
+	echo m68k-hades-mint"$UNAME_RELEASE"
+	exit ;;
+    *:*MiNT:*:* | *:*mint:*:* | *:*TOS:*:*)
+	echo m68k-unknown-mint"$UNAME_RELEASE"
+	exit ;;
+    m68k:machten:*:*)
+	echo m68k-apple-machten"$UNAME_RELEASE"
+	exit ;;
+    powerpc:machten:*:*)
+	echo powerpc-apple-machten"$UNAME_RELEASE"
+	exit ;;
+    RISC*:Mach:*:*)
+	echo mips-dec-mach_bsd4.3
+	exit ;;
+    RISC*:ULTRIX:*:*)
+	echo mips-dec-ultrix"$UNAME_RELEASE"
+	exit ;;
+    VAX*:ULTRIX*:*:*)
+	echo vax-dec-ultrix"$UNAME_RELEASE"
+	exit ;;
+    2020:CLIX:*:* | 2430:CLIX:*:*)
+	echo clipper-intergraph-clix"$UNAME_RELEASE"
+	exit ;;
+    mips:*:*:UMIPS | mips:*:*:RISCos)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+#ifdef __cplusplus
+#include <stdio.h>  /* for printf() prototype */
+	int main (int argc, char *argv[]) {
+#else
+	int main (argc, argv) int argc; char *argv[]; {
+#endif
+	#if defined (host_mips) && defined (MIPSEB)
+	#if defined (SYSTYPE_SYSV)
+	  printf ("mips-mips-riscos%ssysv\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_SVR4)
+	  printf ("mips-mips-riscos%ssvr4\\n", argv[1]); exit (0);
+	#endif
+	#if defined (SYSTYPE_BSD43) || defined(SYSTYPE_BSD)
+	  printf ("mips-mips-riscos%sbsd\\n", argv[1]); exit (0);
+	#endif
+	#endif
+	  exit (-1);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" &&
+	  dummyarg=`echo "$UNAME_RELEASE" | sed -n 's/\([0-9]*\).*/\1/p'` &&
+	  SYSTEM_NAME=`"$dummy" "$dummyarg"` &&
+	    { echo "$SYSTEM_NAME"; exit; }
+	echo mips-mips-riscos"$UNAME_RELEASE"
+	exit ;;
+    Motorola:PowerMAX_OS:*:*)
+	echo powerpc-motorola-powermax
+	exit ;;
+    Motorola:*:4.3:PL8-*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:*:*:PowerMAX_OS | Synergy:PowerMAX_OS:*:*)
+	echo powerpc-harris-powermax
+	exit ;;
+    Night_Hawk:Power_UNIX:*:*)
+	echo powerpc-harris-powerunix
+	exit ;;
+    m88k:CX/UX:7*:*)
+	echo m88k-harris-cxux7
+	exit ;;
+    m88k:*:4*:R4*)
+	echo m88k-motorola-sysv4
+	exit ;;
+    m88k:*:3*:R3*)
+	echo m88k-motorola-sysv3
+	exit ;;
+    AViiON:dgux:*:*)
+	# DG/UX returns AViiON for all architectures
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	if [ "$UNAME_PROCESSOR" = mc88100 ] || [ "$UNAME_PROCESSOR" = mc88110 ]
+	then
+	    if [ "$TARGET_BINARY_INTERFACE"x = m88kdguxelfx ] || \
+	       [ "$TARGET_BINARY_INTERFACE"x = x ]
+	    then
+		echo m88k-dg-dgux"$UNAME_RELEASE"
+	    else
+		echo m88k-dg-dguxbcs"$UNAME_RELEASE"
+	    fi
+	else
+	    echo i586-dg-dgux"$UNAME_RELEASE"
+	fi
+	exit ;;
+    M88*:DolphinOS:*:*)	# DolphinOS (SVR3)
+	echo m88k-dolphin-sysv3
+	exit ;;
+    M88*:*:R3*:*)
+	# Delta 88k system running SVR3
+	echo m88k-motorola-sysv3
+	exit ;;
+    XD88*:*:*:*) # Tektronix XD88 system running UTekV (SVR3)
+	echo m88k-tektronix-sysv3
+	exit ;;
+    Tek43[0-9][0-9]:UTek:*:*) # Tektronix 4300 system running UTek (BSD)
+	echo m68k-tektronix-bsd
+	exit ;;
+    *:IRIX*:*:*)
+	echo mips-sgi-irix"`echo "$UNAME_RELEASE"|sed -e 's/-/_/g'`"
+	exit ;;
+    ????????:AIX?:[12].1:2)   # AIX 2.2.1 or AIX 2.1.1 is RT/PC AIX.
+	echo romp-ibm-aix     # uname -m gives an 8 hex-code CPU id
+	exit ;;               # Note that: echo "'`uname -s`'" gives 'AIX '
+    i*86:AIX:*:*)
+	echo i386-ibm-aix
+	exit ;;
+    ia64:AIX:*:*)
+	if [ -x /usr/bin/oslevel ] ; then
+		IBM_REV=`/usr/bin/oslevel`
+	else
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+	fi
+	echo "$UNAME_MACHINE"-ibm-aix"$IBM_REV"
+	exit ;;
+    *:AIX:2:3)
+	if grep bos325 /usr/include/stdio.h >/dev/null 2>&1; then
+		set_cc_for_build
+		sed 's/^		//' << EOF > "$dummy.c"
+		#include <sys/systemcfg.h>
+
+		main()
+			{
+			if (!__power_pc())
+				exit(1);
+			puts("powerpc-ibm-aix3.2.5");
+			exit(0);
+			}
+EOF
+		if $CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"`
+		then
+			echo "$SYSTEM_NAME"
+		else
+			echo rs6000-ibm-aix3.2.5
+		fi
+	elif grep bos324 /usr/include/stdio.h >/dev/null 2>&1; then
+		echo rs6000-ibm-aix3.2.4
+	else
+		echo rs6000-ibm-aix3.2
+	fi
+	exit ;;
+    *:AIX:*:[4567])
+	IBM_CPU_ID=`/usr/sbin/lsdev -C -c processor -S available | sed 1q | awk '{ print $1 }'`
+	if /usr/sbin/lsattr -El "$IBM_CPU_ID" | grep ' POWER' >/dev/null 2>&1; then
+		IBM_ARCH=rs6000
+	else
+		IBM_ARCH=powerpc
+	fi
+	if [ -x /usr/bin/lslpp ] ; then
+		IBM_REV=`/usr/bin/lslpp -Lqc bos.rte.libc |
+			   awk -F: '{ print $3 }' | sed s/[0-9]*$/0/`
+	else
+		IBM_REV="$UNAME_VERSION.$UNAME_RELEASE"
+	fi
+	echo "$IBM_ARCH"-ibm-aix"$IBM_REV"
+	exit ;;
+    *:AIX:*:*)
+	echo rs6000-ibm-aix
+	exit ;;
+    ibmrt:4.4BSD:*|romp-ibm:4.4BSD:*)
+	echo romp-ibm-bsd4.4
+	exit ;;
+    ibmrt:*BSD:*|romp-ibm:BSD:*)            # covers RT/PC BSD and
+	echo romp-ibm-bsd"$UNAME_RELEASE"   # 4.3 with uname added to
+	exit ;;                             # report: romp-ibm BSD 4.3
+    *:BOSX:*:*)
+	echo rs6000-bull-bosx
+	exit ;;
+    DPX/2?00:B.O.S.:*:*)
+	echo m68k-bull-sysv3
+	exit ;;
+    9000/[34]??:4.3bsd:1.*:*)
+	echo m68k-hp-bsd
+	exit ;;
+    hp300:4.4BSD:*:* | 9000/[34]??:4.3bsd:2.*:*)
+	echo m68k-hp-bsd4.4
+	exit ;;
+    9000/[34678]??:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	case "$UNAME_MACHINE" in
+	    9000/31?)            HP_ARCH=m68000 ;;
+	    9000/[34]??)         HP_ARCH=m68k ;;
+	    9000/[678][0-9][0-9])
+		if [ -x /usr/bin/getconf ]; then
+		    sc_cpu_version=`/usr/bin/getconf SC_CPU_VERSION 2>/dev/null`
+		    sc_kernel_bits=`/usr/bin/getconf SC_KERNEL_BITS 2>/dev/null`
+		    case "$sc_cpu_version" in
+		      523) HP_ARCH=hppa1.0 ;; # CPU_PA_RISC1_0
+		      528) HP_ARCH=hppa1.1 ;; # CPU_PA_RISC1_1
+		      532)                      # CPU_PA_RISC2_0
+			case "$sc_kernel_bits" in
+			  32) HP_ARCH=hppa2.0n ;;
+			  64) HP_ARCH=hppa2.0w ;;
+			  '') HP_ARCH=hppa2.0 ;;   # HP-UX 10.20
+			esac ;;
+		    esac
+		fi
+		if [ "$HP_ARCH" = "" ]; then
+		    set_cc_for_build
+		    sed 's/^		//' << EOF > "$dummy.c"
+
+		#define _HPUX_SOURCE
+		#include <stdlib.h>
+		#include <unistd.h>
+
+		int main ()
+		{
+		#if defined(_SC_KERNEL_BITS)
+		    long bits = sysconf(_SC_KERNEL_BITS);
+		#endif
+		    long cpu  = sysconf (_SC_CPU_VERSION);
+
+		    switch (cpu)
+			{
+			case CPU_PA_RISC1_0: puts ("hppa1.0"); break;
+			case CPU_PA_RISC1_1: puts ("hppa1.1"); break;
+			case CPU_PA_RISC2_0:
+		#if defined(_SC_KERNEL_BITS)
+			    switch (bits)
+				{
+				case 64: puts ("hppa2.0w"); break;
+				case 32: puts ("hppa2.0n"); break;
+				default: puts ("hppa2.0"); break;
+				} break;
+		#else  /* !defined(_SC_KERNEL_BITS) */
+			    puts ("hppa2.0"); break;
+		#endif
+			default: puts ("hppa1.0"); break;
+			}
+		    exit (0);
+		}
+EOF
+		    (CCOPTS="" $CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null) && HP_ARCH=`"$dummy"`
+		    test -z "$HP_ARCH" && HP_ARCH=hppa
+		fi ;;
+	esac
+	if [ "$HP_ARCH" = hppa2.0w ]
+	then
+	    set_cc_for_build
+
+	    # hppa2.0w-hp-hpux* has a 64-bit kernel and a compiler generating
+	    # 32-bit code.  hppa64-hp-hpux* has the same kernel and a compiler
+	    # generating 64-bit code.  GNU and HP use different nomenclature:
+	    #
+	    # $ CC_FOR_BUILD=cc ./config.guess
+	    # => hppa2.0w-hp-hpux11.23
+	    # $ CC_FOR_BUILD="cc +DA2.0w" ./config.guess
+	    # => hppa64-hp-hpux11.23
+
+	    if echo __LP64__ | (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) |
+		grep -q __LP64__
+	    then
+		HP_ARCH=hppa2.0w
+	    else
+		HP_ARCH=hppa64
+	    fi
+	fi
+	echo "$HP_ARCH"-hp-hpux"$HPUX_REV"
+	exit ;;
+    ia64:HP-UX:*:*)
+	HPUX_REV=`echo "$UNAME_RELEASE"|sed -e 's/[^.]*.[0B]*//'`
+	echo ia64-hp-hpux"$HPUX_REV"
+	exit ;;
+    3050*:HI-UX:*:*)
+	set_cc_for_build
+	sed 's/^	//' << EOF > "$dummy.c"
+	#include <unistd.h>
+	int
+	main ()
+	{
+	  long cpu = sysconf (_SC_CPU_VERSION);
+	  /* The order matters, because CPU_IS_HP_MC68K erroneously returns
+	     true for CPU_PA_RISC1_0.  CPU_IS_PA_RISC returns correct
+	     results, however.  */
+	  if (CPU_IS_PA_RISC (cpu))
+	    {
+	      switch (cpu)
+		{
+		  case CPU_PA_RISC1_0: puts ("hppa1.0-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC1_1: puts ("hppa1.1-hitachi-hiuxwe2"); break;
+		  case CPU_PA_RISC2_0: puts ("hppa2.0-hitachi-hiuxwe2"); break;
+		  default: puts ("hppa-hitachi-hiuxwe2"); break;
+		}
+	    }
+	  else if (CPU_IS_HP_MC68K (cpu))
+	    puts ("m68k-hitachi-hiuxwe2");
+	  else puts ("unknown-hitachi-hiuxwe2");
+	  exit (0);
+	}
+EOF
+	$CC_FOR_BUILD -o "$dummy" "$dummy.c" && SYSTEM_NAME=`"$dummy"` &&
+		{ echo "$SYSTEM_NAME"; exit; }
+	echo unknown-hitachi-hiuxwe2
+	exit ;;
+    9000/7??:4.3bsd:*:* | 9000/8?[79]:4.3bsd:*:*)
+	echo hppa1.1-hp-bsd
+	exit ;;
+    9000/8??:4.3bsd:*:*)
+	echo hppa1.0-hp-bsd
+	exit ;;
+    *9??*:MPE/iX:*:* | *3000*:MPE/iX:*:*)
+	echo hppa1.0-hp-mpeix
+	exit ;;
+    hp7??:OSF1:*:* | hp8?[79]:OSF1:*:*)
+	echo hppa1.1-hp-osf
+	exit ;;
+    hp8??:OSF1:*:*)
+	echo hppa1.0-hp-osf
+	exit ;;
+    i*86:OSF1:*:*)
+	if [ -x /usr/sbin/sysversion ] ; then
+	    echo "$UNAME_MACHINE"-unknown-osf1mk
+	else
+	    echo "$UNAME_MACHINE"-unknown-osf1
+	fi
+	exit ;;
+    parisc*:Lites*:*:*)
+	echo hppa1.1-hp-lites
+	exit ;;
+    C1*:ConvexOS:*:* | convex:ConvexOS:C1*:*)
+	echo c1-convex-bsd
+	exit ;;
+    C2*:ConvexOS:*:* | convex:ConvexOS:C2*:*)
+	if getsysinfo -f scalar_acc
+	then echo c32-convex-bsd
+	else echo c2-convex-bsd
+	fi
+	exit ;;
+    C34*:ConvexOS:*:* | convex:ConvexOS:C34*:*)
+	echo c34-convex-bsd
+	exit ;;
+    C38*:ConvexOS:*:* | convex:ConvexOS:C38*:*)
+	echo c38-convex-bsd
+	exit ;;
+    C4*:ConvexOS:*:* | convex:ConvexOS:C4*:*)
+	echo c4-convex-bsd
+	exit ;;
+    CRAY*Y-MP:*:*:*)
+	echo ymp-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*[A-Z]90:*:*:*)
+	echo "$UNAME_MACHINE"-cray-unicos"$UNAME_RELEASE" \
+	| sed -e 's/CRAY.*\([A-Z]90\)/\1/' \
+	      -e y/ABCDEFGHIJKLMNOPQRSTUVWXYZ/abcdefghijklmnopqrstuvwxyz/ \
+	      -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*TS:*:*:*)
+	echo t90-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*T3E:*:*:*)
+	echo alphaev5-cray-unicosmk"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    CRAY*SV1:*:*:*)
+	echo sv1-cray-unicos"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    *:UNICOS/mp:*:*)
+	echo craynv-cray-unicosmp"$UNAME_RELEASE" | sed -e 's/\.[^.]*$/.X/'
+	exit ;;
+    F30[01]:UNIX_System_V:*:* | F700:UNIX_System_V:*:*)
+	FUJITSU_PROC=`uname -m | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz`
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | sed -e 's/ /_/'`
+	echo "${FUJITSU_PROC}-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    5000:UNIX_System_V:4.*:*)
+	FUJITSU_SYS=`uname -p | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/\///'`
+	FUJITSU_REL=`echo "$UNAME_RELEASE" | tr ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz | sed -e 's/ /_/'`
+	echo "sparc-fujitsu-${FUJITSU_SYS}${FUJITSU_REL}"
+	exit ;;
+    i*86:BSD/386:*:* | i*86:BSD/OS:*:* | *:Ascend\ Embedded/OS:*:*)
+	echo "$UNAME_MACHINE"-pc-bsdi"$UNAME_RELEASE"
+	exit ;;
+    sparc*:BSD/OS:*:*)
+	echo sparc-unknown-bsdi"$UNAME_RELEASE"
+	exit ;;
+    *:BSD/OS:*:*)
+	echo "$UNAME_MACHINE"-unknown-bsdi"$UNAME_RELEASE"
+	exit ;;
+    arm:FreeBSD:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	set_cc_for_build
+	if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_PCS_VFP
+	then
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabi
+	else
+	    echo "${UNAME_PROCESSOR}"-unknown-freebsd"`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`"-gnueabihf
+	fi
+	exit ;;
+    *:FreeBSD:*:*)
+	UNAME_PROCESSOR=`/usr/bin/uname -p`
+	case "$UNAME_PROCESSOR" in
+	    amd64)
+		UNAME_PROCESSOR=x86_64 ;;
+	    i386)
+		UNAME_PROCESSOR=i586 ;;
+	esac
+	echo "$UNAME_PROCESSOR"-unknown-freebsd"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	exit ;;
+    i*:CYGWIN*:*)
+	echo "$UNAME_MACHINE"-pc-cygwin
+	exit ;;
+    *:MINGW64*:*)
+	echo "$UNAME_MACHINE"-pc-mingw64
+	exit ;;
+    *:MINGW*:*)
+	echo "$UNAME_MACHINE"-pc-mingw32
+	exit ;;
+    *:MSYS*:*)
+	echo "$UNAME_MACHINE"-pc-msys
+	exit ;;
+    i*:PW*:*)
+	echo "$UNAME_MACHINE"-pc-pw32
+	exit ;;
+    *:Interix*:*)
+	case "$UNAME_MACHINE" in
+	    x86)
+		echo i586-pc-interix"$UNAME_RELEASE"
+		exit ;;
+	    authenticamd | genuineintel | EM64T)
+		echo x86_64-unknown-interix"$UNAME_RELEASE"
+		exit ;;
+	    IA64)
+		echo ia64-unknown-interix"$UNAME_RELEASE"
+		exit ;;
+	esac ;;
+    i*:UWIN*:*)
+	echo "$UNAME_MACHINE"-pc-uwin
+	exit ;;
+    amd64:CYGWIN*:*:* | x86_64:CYGWIN*:*:*)
+	echo x86_64-pc-cygwin
+	exit ;;
+    prep*:SunOS:5.*:*)
+	echo powerpcle-unknown-solaris2"`echo "$UNAME_RELEASE"|sed -e 's/[^.]*//'`"
+	exit ;;
+    *:GNU:*:*)
+	# the GNU system
+	echo "`echo "$UNAME_MACHINE"|sed -e 's,[-/].*$,,'`-unknown-$LIBC`echo "$UNAME_RELEASE"|sed -e 's,/.*$,,'`"
+	exit ;;
+    *:GNU/*:*:*)
+	# other systems with GNU libc and userland
+	echo "$UNAME_MACHINE-unknown-`echo "$UNAME_SYSTEM" | sed 's,^[^/]*/,,' | tr "[:upper:]" "[:lower:]"``echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`-$LIBC"
+	exit ;;
+    *:Minix:*:*)
+	echo "$UNAME_MACHINE"-unknown-minix
+	exit ;;
+    aarch64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    aarch64_be:Linux:*:*)
+	UNAME_MACHINE=aarch64_be
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    alpha:Linux:*:*)
+	case `sed -n '/^cpu model/s/^.*: \(.*\)/\1/p' /proc/cpuinfo 2>/dev/null` in
+	  EV5)   UNAME_MACHINE=alphaev5 ;;
+	  EV56)  UNAME_MACHINE=alphaev56 ;;
+	  PCA56) UNAME_MACHINE=alphapca56 ;;
+	  PCA57) UNAME_MACHINE=alphapca56 ;;
+	  EV6)   UNAME_MACHINE=alphaev6 ;;
+	  EV67)  UNAME_MACHINE=alphaev67 ;;
+	  EV68*) UNAME_MACHINE=alphaev68 ;;
+	esac
+	objdump --private-headers /bin/sh | grep -q ld.so.1
+	if test "$?" = 0 ; then LIBC=gnulibc1 ; fi
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    arc:Linux:*:* | arceb:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    arm*:Linux:*:*)
+	set_cc_for_build
+	if echo __ARM_EABI__ | $CC_FOR_BUILD -E - 2>/dev/null \
+	    | grep -q __ARM_EABI__
+	then
+	    echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	else
+	    if echo __ARM_PCS_VFP | $CC_FOR_BUILD -E - 2>/dev/null \
+		| grep -q __ARM_PCS_VFP
+	    then
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabi
+	    else
+		echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"eabihf
+	    fi
+	fi
+	exit ;;
+    avr32*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    cris:Linux:*:*)
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	exit ;;
+    crisv32:Linux:*:*)
+	echo "$UNAME_MACHINE"-axis-linux-"$LIBC"
+	exit ;;
+    e2k:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    frv:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    hexagon:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    i*86:Linux:*:*)
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBC"
+	exit ;;
+    ia64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    k1om:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    m32r*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    m68*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    mips:Linux:*:* | mips64:Linux:*:*)
+	set_cc_for_build
+	IS_GLIBC=0
+	test x"${LIBC}" = xgnu && IS_GLIBC=1
+	sed 's/^	//' << EOF > "$dummy.c"
+	#undef CPU
+	#undef mips
+	#undef mipsel
+	#undef mips64
+	#undef mips64el
+	#if ${IS_GLIBC} && defined(_ABI64)
+	LIBCABI=gnuabi64
+	#else
+	#if ${IS_GLIBC} && defined(_ABIN32)
+	LIBCABI=gnuabin32
+	#else
+	LIBCABI=${LIBC}
+	#endif
+	#endif
+
+	#if ${IS_GLIBC} && defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa64r6
+	#else
+	#if ${IS_GLIBC} && !defined(__mips64) && defined(__mips_isa_rev) && __mips_isa_rev>=6
+	CPU=mipsisa32r6
+	#else
+	#if defined(__mips64)
+	CPU=mips64
+	#else
+	CPU=mips
+	#endif
+	#endif
+	#endif
+
+	#if defined(__MIPSEL__) || defined(__MIPSEL) || defined(_MIPSEL) || defined(MIPSEL)
+	MIPS_ENDIAN=el
+	#else
+	#if defined(__MIPSEB__) || defined(__MIPSEB) || defined(_MIPSEB) || defined(MIPSEB)
+	MIPS_ENDIAN=
+	#else
+	MIPS_ENDIAN=
+	#endif
+	#endif
+EOF
+	eval "`$CC_FOR_BUILD -E "$dummy.c" 2>/dev/null | grep '^CPU\|^MIPS_ENDIAN\|^LIBCABI'`"
+	test "x$CPU" != x && { echo "$CPU${MIPS_ENDIAN}-unknown-linux-$LIBCABI"; exit; }
+	;;
+    mips64el:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    openrisc*:Linux:*:*)
+	echo or1k-unknown-linux-"$LIBC"
+	exit ;;
+    or32:Linux:*:* | or1k*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    padre:Linux:*:*)
+	echo sparc-unknown-linux-"$LIBC"
+	exit ;;
+    parisc64:Linux:*:* | hppa64:Linux:*:*)
+	echo hppa64-unknown-linux-"$LIBC"
+	exit ;;
+    parisc:Linux:*:* | hppa:Linux:*:*)
+	# Look for CPU level
+	case `grep '^cpu[^a-z]*:' /proc/cpuinfo 2>/dev/null | cut -d' ' -f2` in
+	  PA7*) echo hppa1.1-unknown-linux-"$LIBC" ;;
+	  PA8*) echo hppa2.0-unknown-linux-"$LIBC" ;;
+	  *)    echo hppa-unknown-linux-"$LIBC" ;;
+	esac
+	exit ;;
+    ppc64:Linux:*:*)
+	echo powerpc64-unknown-linux-"$LIBC"
+	exit ;;
+    ppc:Linux:*:*)
+	echo powerpc-unknown-linux-"$LIBC"
+	exit ;;
+    ppc64le:Linux:*:*)
+	echo powerpc64le-unknown-linux-"$LIBC"
+	exit ;;
+    ppcle:Linux:*:*)
+	echo powerpcle-unknown-linux-"$LIBC"
+	exit ;;
+    riscv32:Linux:*:* | riscv64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    s390:Linux:*:* | s390x:Linux:*:*)
+	echo "$UNAME_MACHINE"-ibm-linux-"$LIBC"
+	exit ;;
+    sh64*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    sh*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    sparc:Linux:*:* | sparc64:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    tile*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    vax:Linux:*:*)
+	echo "$UNAME_MACHINE"-dec-linux-"$LIBC"
+	exit ;;
+    x86_64:Linux:*:*)
+	set_cc_for_build
+	LIBCABI=$LIBC
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	    if (echo '#ifdef __ILP32__'; echo IS_X32; echo '#endif') | \
+		(CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		grep IS_X32 >/dev/null
+	    then
+		LIBCABI="$LIBC"x32
+	    fi
+	fi
+	echo "$UNAME_MACHINE"-pc-linux-"$LIBCABI"
+	exit ;;
+    xtensa*:Linux:*:*)
+	echo "$UNAME_MACHINE"-unknown-linux-"$LIBC"
+	exit ;;
+    i*86:DYNIX/ptx:4*:*)
+	# ptx 4.0 does uname -s correctly, with DYNIX/ptx in there.
+	# earlier versions are messed up and put the nodename in both
+	# sysname and nodename.
+	echo i386-sequent-sysv4
+	exit ;;
+    i*86:UNIX_SV:4.2MP:2.*)
+	# Unixware is an offshoot of SVR4, but it has its own version
+	# number series starting with 2...
+	# I am not positive that other SVR4 systems won't match this,
+	# I just have to hope.  -- rms.
+	# Use sysv4.2uw... so that sysv4* matches it.
+	echo "$UNAME_MACHINE"-pc-sysv4.2uw"$UNAME_VERSION"
+	exit ;;
+    i*86:OS/2:*:*)
+	# If we were able to find `uname', then EMX Unix compatibility
+	# is probably installed.
+	echo "$UNAME_MACHINE"-pc-os2-emx
+	exit ;;
+    i*86:XTS-300:*:STOP)
+	echo "$UNAME_MACHINE"-unknown-stop
+	exit ;;
+    i*86:atheos:*:*)
+	echo "$UNAME_MACHINE"-unknown-atheos
+	exit ;;
+    i*86:syllable:*:*)
+	echo "$UNAME_MACHINE"-pc-syllable
+	exit ;;
+    i*86:LynxOS:2.*:* | i*86:LynxOS:3.[01]*:* | i*86:LynxOS:4.[02]*:*)
+	echo i386-unknown-lynxos"$UNAME_RELEASE"
+	exit ;;
+    i*86:*DOS:*:*)
+	echo "$UNAME_MACHINE"-pc-msdosdjgpp
+	exit ;;
+    i*86:*:4.*:*)
+	UNAME_REL=`echo "$UNAME_RELEASE" | sed 's/\/MP$//'`
+	if grep Novell /usr/include/link.h >/dev/null 2>/dev/null; then
+		echo "$UNAME_MACHINE"-univel-sysv"$UNAME_REL"
+	else
+		echo "$UNAME_MACHINE"-pc-sysv"$UNAME_REL"
+	fi
+	exit ;;
+    i*86:*:5:[678]*)
+	# UnixWare 7.x, OpenUNIX and OpenServer 6.
+	case `/bin/uname -X | grep "^Machine"` in
+	    *486*)	     UNAME_MACHINE=i486 ;;
+	    *Pentium)	     UNAME_MACHINE=i586 ;;
+	    *Pent*|*Celeron) UNAME_MACHINE=i686 ;;
+	esac
+	echo "$UNAME_MACHINE-unknown-sysv${UNAME_RELEASE}${UNAME_SYSTEM}${UNAME_VERSION}"
+	exit ;;
+    i*86:*:3.2:*)
+	if test -f /usr/options/cb.name; then
+		UNAME_REL=`sed -n 's/.*Version //p' </usr/options/cb.name`
+		echo "$UNAME_MACHINE"-pc-isc"$UNAME_REL"
+	elif /bin/uname -X 2>/dev/null >/dev/null ; then
+		UNAME_REL=`(/bin/uname -X|grep Release|sed -e 's/.*= //')`
+		(/bin/uname -X|grep i80486 >/dev/null) && UNAME_MACHINE=i486
+		(/bin/uname -X|grep '^Machine.*Pentium' >/dev/null) \
+			&& UNAME_MACHINE=i586
+		(/bin/uname -X|grep '^Machine.*Pent *II' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		(/bin/uname -X|grep '^Machine.*Pentium Pro' >/dev/null) \
+			&& UNAME_MACHINE=i686
+		echo "$UNAME_MACHINE"-pc-sco"$UNAME_REL"
+	else
+		echo "$UNAME_MACHINE"-pc-sysv32
+	fi
+	exit ;;
+    pc:*:*:*)
+	# Left here for compatibility:
+	# uname -m prints for DJGPP always 'pc', but it prints nothing about
+	# the processor, so we play safe by assuming i586.
+	# Note: whatever this is, it MUST be the same as what config.sub
+	# prints for the "djgpp" host, or else GDB configure will decide that
+	# this is a cross-build.
+	echo i586-pc-msdosdjgpp
+	exit ;;
+    Intel:Mach:3*:*)
+	echo i386-pc-mach3
+	exit ;;
+    paragon:*:*:*)
+	echo i860-intel-osf1
+	exit ;;
+    i860:*:4.*:*) # i860-SVR4
+	if grep Stardent /usr/include/sys/uadmin.h >/dev/null 2>&1 ; then
+	  echo i860-stardent-sysv"$UNAME_RELEASE" # Stardent Vistra i860-SVR4
+	else # Add other i860-SVR4 vendors below as they are discovered.
+	  echo i860-unknown-sysv"$UNAME_RELEASE"  # Unknown i860-SVR4
+	fi
+	exit ;;
+    mini*:CTIX:SYS*5:*)
+	# "miniframe"
+	echo m68010-convergent-sysv
+	exit ;;
+    mc68k:UNIX:SYSTEM5:3.51m)
+	echo m68k-convergent-sysv
+	exit ;;
+    M680?0:D-NIX:5.3:*)
+	echo m68k-diab-dnix
+	exit ;;
+    M68*:*:R3V[5678]*:*)
+	test -r /sysV68 && { echo 'm68k-motorola-sysv'; exit; } ;;
+    3[345]??:*:4.0:3.0 | 3[34]??A:*:4.0:3.0 | 3[34]??,*:*:4.0:3.0 | 3[34]??/*:*:4.0:3.0 | 4400:*:4.0:3.0 | 4850:*:4.0:3.0 | SKA40:*:4.0:3.0 | SDS2:*:4.0:3.0 | SHG2:*:4.0:3.0 | S7501*:*:4.0:3.0)
+	OS_REL=''
+	test -r /etc/.relid \
+	&& OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	  && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    3[34]??:*:4.0:* | 3[34]??,*:*:4.0:*)
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	  && { echo i486-ncr-sysv4; exit; } ;;
+    NCR*:*:4.2:* | MPRAS*:*:4.2:*)
+	OS_REL='.3'
+	test -r /etc/.relid \
+	    && OS_REL=.`sed -n 's/[^ ]* [^ ]* \([0-9][0-9]\).*/\1/p' < /etc/.relid`
+	/bin/uname -p 2>/dev/null | grep 86 >/dev/null \
+	    && { echo i486-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep entium >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; }
+	/bin/uname -p 2>/dev/null | /bin/grep pteron >/dev/null \
+	    && { echo i586-ncr-sysv4.3"$OS_REL"; exit; } ;;
+    m68*:LynxOS:2.*:* | m68*:LynxOS:3.0*:*)
+	echo m68k-unknown-lynxos"$UNAME_RELEASE"
+	exit ;;
+    mc68030:UNIX_System_V:4.*:*)
+	echo m68k-atari-sysv4
+	exit ;;
+    TSUNAMI:LynxOS:2.*:*)
+	echo sparc-unknown-lynxos"$UNAME_RELEASE"
+	exit ;;
+    rs6000:LynxOS:2.*:*)
+	echo rs6000-unknown-lynxos"$UNAME_RELEASE"
+	exit ;;
+    PowerPC:LynxOS:2.*:* | PowerPC:LynxOS:3.[01]*:* | PowerPC:LynxOS:4.[02]*:*)
+	echo powerpc-unknown-lynxos"$UNAME_RELEASE"
+	exit ;;
+    SM[BE]S:UNIX_SV:*:*)
+	echo mips-dde-sysv"$UNAME_RELEASE"
+	exit ;;
+    RM*:ReliantUNIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    RM*:SINIX-*:*:*)
+	echo mips-sni-sysv4
+	exit ;;
+    *:SINIX-*:*:*)
+	if uname -p 2>/dev/null >/dev/null ; then
+		UNAME_MACHINE=`(uname -p) 2>/dev/null`
+		echo "$UNAME_MACHINE"-sni-sysv4
+	else
+		echo ns32k-sni-sysv
+	fi
+	exit ;;
+    PENTIUM:*:4.0*:*)	# Unisys `ClearPath HMP IX 4000' SVR4/MP effort
+			# says <Richard.M.Bartel@ccMail.Census.GOV>
+	echo i586-unisys-sysv4
+	exit ;;
+    *:UNIX_System_V:4*:FTX*)
+	# From Gerald Hewes <hewes@openmarket.com>.
+	# How about differentiating between stratus architectures? -djm
+	echo hppa1.1-stratus-sysv4
+	exit ;;
+    *:*:*:FTX*)
+	# From seanf@swdc.stratus.com.
+	echo i860-stratus-sysv4
+	exit ;;
+    i*86:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo "$UNAME_MACHINE"-stratus-vos
+	exit ;;
+    *:VOS:*:*)
+	# From Paul.Green@stratus.com.
+	echo hppa1.1-stratus-vos
+	exit ;;
+    mc68*:A/UX:*:*)
+	echo m68k-apple-aux"$UNAME_RELEASE"
+	exit ;;
+    news*:NEWS-OS:6*:*)
+	echo mips-sony-newsos6
+	exit ;;
+    R[34]000:*System_V*:*:* | R4000:UNIX_SYSV:*:* | R*000:UNIX_SV:*:*)
+	if [ -d /usr/nec ]; then
+		echo mips-nec-sysv"$UNAME_RELEASE"
+	else
+		echo mips-unknown-sysv"$UNAME_RELEASE"
+	fi
+	exit ;;
+    BeBox:BeOS:*:*)	# BeOS running on hardware made by Be, PPC only.
+	echo powerpc-be-beos
+	exit ;;
+    BeMac:BeOS:*:*)	# BeOS running on Mac or Mac clone, PPC only.
+	echo powerpc-apple-beos
+	exit ;;
+    BePC:BeOS:*:*)	# BeOS running on Intel PC compatible.
+	echo i586-pc-beos
+	exit ;;
+    BePC:Haiku:*:*)	# Haiku running on Intel PC compatible.
+	echo i586-pc-haiku
+	exit ;;
+    x86_64:Haiku:*:*)
+	echo x86_64-unknown-haiku
+	exit ;;
+    SX-4:SUPER-UX:*:*)
+	echo sx4-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-5:SUPER-UX:*:*)
+	echo sx5-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-6:SUPER-UX:*:*)
+	echo sx6-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-7:SUPER-UX:*:*)
+	echo sx7-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-8:SUPER-UX:*:*)
+	echo sx8-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-8R:SUPER-UX:*:*)
+	echo sx8r-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    SX-ACE:SUPER-UX:*:*)
+	echo sxace-nec-superux"$UNAME_RELEASE"
+	exit ;;
+    Power*:Rhapsody:*:*)
+	echo powerpc-apple-rhapsody"$UNAME_RELEASE"
+	exit ;;
+    *:Rhapsody:*:*)
+	echo "$UNAME_MACHINE"-apple-rhapsody"$UNAME_RELEASE"
+	exit ;;
+    arm64:Darwin:*:*)
+	echo aarch64-apple-darwin"$UNAME_RELEASE"
+	exit ;;
+    *:Darwin:*:*)
+	UNAME_PROCESSOR=`uname -p`
+	case $UNAME_PROCESSOR in
+	    unknown) UNAME_PROCESSOR=powerpc ;;
+	esac
+	if command -v xcode-select > /dev/null 2> /dev/null && \
+		! xcode-select --print-path > /dev/null 2> /dev/null ; then
+	    # Avoid executing cc if there is no toolchain installed as
+	    # cc will be a stub that puts up a graphical alert
+	    # prompting the user to install developer tools.
+	    CC_FOR_BUILD=no_compiler_found
+	else
+	    set_cc_for_build
+	fi
+	if [ "$CC_FOR_BUILD" != no_compiler_found ]; then
+	    if (echo '#ifdef __LP64__'; echo IS_64BIT_ARCH; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_64BIT_ARCH >/dev/null
+	    then
+		case $UNAME_PROCESSOR in
+		    i386) UNAME_PROCESSOR=x86_64 ;;
+		    powerpc) UNAME_PROCESSOR=powerpc64 ;;
+		esac
+	    fi
+	    # On 10.4-10.6 one might compile for PowerPC via gcc -arch ppc
+	    if (echo '#ifdef __POWERPC__'; echo IS_PPC; echo '#endif') | \
+		   (CCOPTS="" $CC_FOR_BUILD -E - 2>/dev/null) | \
+		   grep IS_PPC >/dev/null
+	    then
+		UNAME_PROCESSOR=powerpc
+	    fi
+	elif test "$UNAME_PROCESSOR" = i386 ; then
+	    # uname -m returns i386 or x86_64
+	    UNAME_PROCESSOR=$UNAME_MACHINE
+	fi
+	echo "$UNAME_PROCESSOR"-apple-darwin"$UNAME_RELEASE"
+	exit ;;
+    *:procnto*:*:* | *:QNX:[0123456789]*:*)
+	UNAME_PROCESSOR=`uname -p`
+	if test "$UNAME_PROCESSOR" = x86; then
+		UNAME_PROCESSOR=i386
+		UNAME_MACHINE=pc
+	fi
+	echo "$UNAME_PROCESSOR"-"$UNAME_MACHINE"-nto-qnx"$UNAME_RELEASE"
+	exit ;;
+    *:QNX:*:4*)
+	echo i386-pc-qnx
+	exit ;;
+    NEO-*:NONSTOP_KERNEL:*:*)
+	echo neo-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSE-*:NONSTOP_KERNEL:*:*)
+	echo nse-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSR-*:NONSTOP_KERNEL:*:*)
+	echo nsr-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSV-*:NONSTOP_KERNEL:*:*)
+	echo nsv-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    NSX-*:NONSTOP_KERNEL:*:*)
+	echo nsx-tandem-nsk"$UNAME_RELEASE"
+	exit ;;
+    *:NonStop-UX:*:*)
+	echo mips-compaq-nonstopux
+	exit ;;
+    BS2000:POSIX*:*:*)
+	echo bs2000-siemens-sysv
+	exit ;;
+    DS/*:UNIX_System_V:*:*)
+	echo "$UNAME_MACHINE"-"$UNAME_SYSTEM"-"$UNAME_RELEASE"
+	exit ;;
+    *:Plan9:*:*)
+	# "uname -m" is not consistent, so use $cputype instead. 386
+	# is converted to i386 for consistency with other x86
+	# operating systems.
+	# shellcheck disable=SC2154
+	if test "$cputype" = 386; then
+	    UNAME_MACHINE=i386
+	else
+	    UNAME_MACHINE="$cputype"
+	fi
+	echo "$UNAME_MACHINE"-unknown-plan9
+	exit ;;
+    *:TOPS-10:*:*)
+	echo pdp10-unknown-tops10
+	exit ;;
+    *:TENEX:*:*)
+	echo pdp10-unknown-tenex
+	exit ;;
+    KS10:TOPS-20:*:* | KL10:TOPS-20:*:* | TYPE4:TOPS-20:*:*)
+	echo pdp10-dec-tops20
+	exit ;;
+    XKL-1:TOPS-20:*:* | TYPE5:TOPS-20:*:*)
+	echo pdp10-xkl-tops20
+	exit ;;
+    *:TOPS-20:*:*)
+	echo pdp10-unknown-tops20
+	exit ;;
+    *:ITS:*:*)
+	echo pdp10-unknown-its
+	exit ;;
+    SEI:*:*:SEIUX)
+	echo mips-sei-seiux"$UNAME_RELEASE"
+	exit ;;
+    *:DragonFly:*:*)
+	echo "$UNAME_MACHINE"-unknown-dragonfly"`echo "$UNAME_RELEASE"|sed -e 's/[-(].*//'`"
+	exit ;;
+    *:*VMS:*:*)
+	UNAME_MACHINE=`(uname -p) 2>/dev/null`
+	case "$UNAME_MACHINE" in
+	    A*) echo alpha-dec-vms ; exit ;;
+	    I*) echo ia64-dec-vms ; exit ;;
+	    V*) echo vax-dec-vms ; exit ;;
+	esac ;;
+    *:XENIX:*:SysV)
+	echo i386-pc-xenix
+	exit ;;
+    i*86:skyos:*:*)
+	echo "$UNAME_MACHINE"-pc-skyos"`echo "$UNAME_RELEASE" | sed -e 's/ .*$//'`"
+	exit ;;
+    i*86:rdos:*:*)
+	echo "$UNAME_MACHINE"-pc-rdos
+	exit ;;
+    i*86:AROS:*:*)
+	echo "$UNAME_MACHINE"-pc-aros
+	exit ;;
+    x86_64:VMkernel:*:*)
+	echo "$UNAME_MACHINE"-unknown-esx
+	exit ;;
+    amd64:Isilon\ OneFS:*:*)
+	echo x86_64-unknown-onefs
+	exit ;;
+    *:Unleashed:*:*)
+	echo "$UNAME_MACHINE"-unknown-unleashed"$UNAME_RELEASE"
+	exit ;;
+esac
+
+# No uname command or uname output not recognized.
+set_cc_for_build
+cat > "$dummy.c" <<EOF
+#ifdef _SEQUENT_
+#include <sys/types.h>
+#include <sys/utsname.h>
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined (vax) || defined (__vax) || defined (__vax__) || defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#include <signal.h>
+#if defined(_SIZE_T_) || defined(SIGLOST)
+#include <sys/utsname.h>
+#endif
+#endif
+#endif
+main ()
+{
+#if defined (sony)
+#if defined (MIPSEB)
+  /* BFD wants "bsd" instead of "newsos".  Perhaps BFD should be changed,
+     I don't know....  */
+  printf ("mips-sony-bsd\n"); exit (0);
+#else
+#include <sys/param.h>
+  printf ("m68k-sony-newsos%s\n",
+#ifdef NEWSOS4
+  "4"
+#else
+  ""
+#endif
+  ); exit (0);
+#endif
+#endif
+
+#if defined (NeXT)
+#if !defined (__ARCHITECTURE__)
+#define __ARCHITECTURE__ "m68k"
+#endif
+  int version;
+  version=`(hostinfo | sed -n 's/.*NeXT Mach \([0-9]*\).*/\1/p') 2>/dev/null`;
+  if (version < 4)
+    printf ("%s-next-nextstep%d\n", __ARCHITECTURE__, version);
+  else
+    printf ("%s-next-openstep%d\n", __ARCHITECTURE__, version);
+  exit (0);
+#endif
+
+#if defined (MULTIMAX) || defined (n16)
+#if defined (UMAXV)
+  printf ("ns32k-encore-sysv\n"); exit (0);
+#else
+#if defined (CMU)
+  printf ("ns32k-encore-mach\n"); exit (0);
+#else
+  printf ("ns32k-encore-bsd\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (__386BSD__)
+  printf ("i386-pc-bsd\n"); exit (0);
+#endif
+
+#if defined (sequent)
+#if defined (i386)
+  printf ("i386-sequent-dynix\n"); exit (0);
+#endif
+#if defined (ns32000)
+  printf ("ns32k-sequent-dynix\n"); exit (0);
+#endif
+#endif
+
+#if defined (_SEQUENT_)
+  struct utsname un;
+
+  uname(&un);
+  if (strncmp(un.version, "V2", 2) == 0) {
+    printf ("i386-sequent-ptx2\n"); exit (0);
+  }
+  if (strncmp(un.version, "V1", 2) == 0) { /* XXX is V1 correct? */
+    printf ("i386-sequent-ptx1\n"); exit (0);
+  }
+  printf ("i386-sequent-ptx\n"); exit (0);
+#endif
+
+#if defined (vax)
+#if !defined (ultrix)
+#include <sys/param.h>
+#if defined (BSD)
+#if BSD == 43
+  printf ("vax-dec-bsd4.3\n"); exit (0);
+#else
+#if BSD == 199006
+  printf ("vax-dec-bsd4.3reno\n"); exit (0);
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#endif
+#else
+  printf ("vax-dec-bsd\n"); exit (0);
+#endif
+#else
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname un;
+  uname (&un);
+  printf ("vax-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("vax-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+#if defined(ultrix) || defined(_ultrix) || defined(__ultrix) || defined(__ultrix__)
+#if defined(mips) || defined(__mips) || defined(__mips__) || defined(MIPS) || defined(__MIPS__)
+#if defined(_SIZE_T_) || defined(SIGLOST)
+  struct utsname *un;
+  uname (&un);
+  printf ("mips-dec-ultrix%s\n", un.release); exit (0);
+#else
+  printf ("mips-dec-ultrix\n"); exit (0);
+#endif
+#endif
+#endif
+
+#if defined (alliant) && defined (i860)
+  printf ("i860-alliant-bsd\n"); exit (0);
+#endif
+
+  exit (1);
+}
+EOF
+
+$CC_FOR_BUILD -o "$dummy" "$dummy.c" 2>/dev/null && SYSTEM_NAME=`$dummy` &&
+	{ echo "$SYSTEM_NAME"; exit; }
+
+# Apollos put the system type in the environment.
+test -d /usr/apollo && { echo "$ISP-apollo-$SYSTYPE"; exit; }
+
+echo "$0: unable to guess system type" >&2
+
+case "$UNAME_MACHINE:$UNAME_SYSTEM" in
+    mips:Linux | mips64:Linux)
+	# If we got here on MIPS GNU/Linux, output extra information.
+	cat >&2 <<EOF
+
+NOTE: MIPS GNU/Linux systems require a C compiler to fully recognize
+the system type. Please install a C compiler and try again.
+EOF
+	;;
+esac
+
+cat >&2 <<EOF
+
+This script (version $timestamp), has failed to recognize the
+operating system you are using. If your script is old, overwrite *all*
+copies of config.guess and config.sub with the latest versions from:
+
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.guess
+and
+  https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+EOF
+
+year=`echo $timestamp | sed 's,-.*,,'`
+# shellcheck disable=SC2003
+if test "`expr "\`date +%Y\`" - "$year"`" -lt 3 ; then
+   cat >&2 <<EOF
+
+If $0 has already been updated, send the following data and any
+information you think might be pertinent to config-patches@gnu.org to
+provide the necessary information to handle your system.
+
+config.guess timestamp = $timestamp
+
+uname -m = `(uname -m) 2>/dev/null || echo unknown`
+uname -r = `(uname -r) 2>/dev/null || echo unknown`
+uname -s = `(uname -s) 2>/dev/null || echo unknown`
+uname -v = `(uname -v) 2>/dev/null || echo unknown`
+
+/usr/bin/uname -p = `(/usr/bin/uname -p) 2>/dev/null`
+/bin/uname -X     = `(/bin/uname -X) 2>/dev/null`
+
+hostinfo               = `(hostinfo) 2>/dev/null`
+/bin/universe          = `(/bin/universe) 2>/dev/null`
+/usr/bin/arch -k       = `(/usr/bin/arch -k) 2>/dev/null`
+/bin/arch              = `(/bin/arch) 2>/dev/null`
+/usr/bin/oslevel       = `(/usr/bin/oslevel) 2>/dev/null`
+/usr/convex/getsysinfo = `(/usr/convex/getsysinfo) 2>/dev/null`
+
+UNAME_MACHINE = "$UNAME_MACHINE"
+UNAME_RELEASE = "$UNAME_RELEASE"
+UNAME_SYSTEM  = "$UNAME_SYSTEM"
+UNAME_VERSION = "$UNAME_VERSION"
+EOF
+fi
+
+exit 1
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -urN libffi-3.4.2.ori/config.guess.rej libffi-3.4.2/config.guess.rej
--- libffi-3.4.2.ori/config.guess.rej	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/config.guess.rej	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,12 @@
+--- config.guess	2022-11-01 09:51:59.997945666 +0800
++++ config.guess	2022-11-01 22:24:41.588383573 +0800
+@@ -1045,6 +1045,9 @@
+     m68*:Linux:*:*)
+ 	GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
+ 	;;
++    loongarch32:Linux:*:* | loongarch64:Linux:*:*)
++    GUESS=$UNAME_MACHINE-unknown-linux-$LIBC
++    ;;
+     mips:Linux:*:* | mips64:Linux:*:*)
+ 	set_cc_for_build
+ 	IS_GLIBC=0
diff -urN libffi-3.4.2.ori/config.sub libffi-3.4.2/config.sub
--- libffi-3.4.2.ori/config.sub	2021-06-27 23:17:08.000000000 +0800
+++ libffi-3.4.2/config.sub	2022-11-01 23:26:36.286463049 +0800
@@ -943,6 +943,11 @@
 		cpu=x86_64
 		vendor=pc
 		;;
+    loongarch64)
+		cpu=loongarch64
+		vendor=loongson
+		;;
+
 	# Recognize the basic CPU types without company name.
 	*)
 		cpu=$basic_machine
diff -urN libffi-3.4.2.ori/config.sub.orig libffi-3.4.2/config.sub.orig
--- libffi-3.4.2.ori/config.sub.orig	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/config.sub.orig	2021-06-27 23:17:08.000000000 +0800
@@ -0,0 +1,1851 @@
+#! /bin/sh
+# Configuration validation subroutine script.
+#   Copyright 1992-2020 Free Software Foundation, Inc.
+
+timestamp='2020-08-05'
+
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3 of the License, or
+# (at your option) any later version.
+#
+# This program is distributed in the hope that it will be useful, but
+# WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# General Public License for more details.
+#
+# You should have received a copy of the GNU General Public License
+# along with this program; if not, see <https://www.gnu.org/licenses/>.
+#
+# As a special exception to the GNU General Public License, if you
+# distribute this file as part of a program that contains a
+# configuration script generated by Autoconf, you may include it under
+# the same distribution terms that you use for the rest of that
+# program.  This Exception is an additional permission under section 7
+# of the GNU General Public License, version 3 ("GPLv3").
+
+
+# Please send patches to <config-patches@gnu.org>.
+#
+# Configuration subroutine to validate and canonicalize a configuration type.
+# Supply the specified configuration type as an argument.
+# If it is invalid, we print an error message on stderr and exit with code 1.
+# Otherwise, we print the canonical config type on stdout and succeed.
+
+# You can get the latest version of this script from:
+# https://git.savannah.gnu.org/gitweb/?p=config.git;a=blob_plain;f=config.sub
+
+# This file is supposed to be the same for all GNU packages
+# and recognize all the CPU types, system types and aliases
+# that are meaningful with *any* GNU software.
+# Each package is responsible for reporting which valid configurations
+# it does not support.  The user should be able to distinguish
+# a failure to support a valid configuration from a meaningless
+# configuration.
+
+# The goal of this file is to map all the various variations of a given
+# machine specification into a single specification in the form:
+#	CPU_TYPE-MANUFACTURER-OPERATING_SYSTEM
+# or in some cases, the newer four-part form:
+#	CPU_TYPE-MANUFACTURER-KERNEL-OPERATING_SYSTEM
+# It is wrong to echo any other type of specification.
+
+me=`echo "$0" | sed -e 's,.*/,,'`
+
+usage="\
+Usage: $0 [OPTION] CPU-MFR-OPSYS or ALIAS
+
+Canonicalize a configuration name.
+
+Options:
+  -h, --help         print this help, then exit
+  -t, --time-stamp   print date of last modification, then exit
+  -v, --version      print version number, then exit
+
+Report bugs and patches to <config-patches@gnu.org>."
+
+version="\
+GNU config.sub ($timestamp)
+
+Copyright 1992-2020 Free Software Foundation, Inc.
+
+This is free software; see the source for copying conditions.  There is NO
+warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE."
+
+help="
+Try \`$me --help' for more information."
+
+# Parse command line
+while test $# -gt 0 ; do
+  case $1 in
+    --time-stamp | --time* | -t )
+       echo "$timestamp" ; exit ;;
+    --version | -v )
+       echo "$version" ; exit ;;
+    --help | --h* | -h )
+       echo "$usage"; exit ;;
+    -- )     # Stop option processing
+       shift; break ;;
+    - )	# Use stdin as input.
+       break ;;
+    -* )
+       echo "$me: invalid option $1$help" >&2
+       exit 1 ;;
+
+    *local*)
+       # First pass through any local machine types.
+       echo "$1"
+       exit ;;
+
+    * )
+       break ;;
+  esac
+done
+
+case $# in
+ 0) echo "$me: missing argument$help" >&2
+    exit 1;;
+ 1) ;;
+ *) echo "$me: too many arguments$help" >&2
+    exit 1;;
+esac
+
+# Split fields of configuration type
+# shellcheck disable=SC2162
+IFS="-" read field1 field2 field3 field4 <<EOF
+$1
+EOF
+
+# Separate into logical components for further validation
+case $1 in
+	*-*-*-*-*)
+		echo Invalid configuration \`"$1"\': more than four components >&2
+		exit 1
+		;;
+	*-*-*-*)
+		basic_machine=$field1-$field2
+		basic_os=$field3-$field4
+		;;
+	*-*-*)
+		# Ambiguous whether COMPANY is present, or skipped and KERNEL-OS is two
+		# parts
+		maybe_os=$field2-$field3
+		case $maybe_os in
+			nto-qnx* | linux-* | uclinux-uclibc* \
+			| uclinux-gnu* | kfreebsd*-gnu* | knetbsd*-gnu* | netbsd*-gnu* \
+			| netbsd*-eabi* | kopensolaris*-gnu* | cloudabi*-eabi* \
+			| storm-chaos* | os2-emx* | rtmk-nova*)
+				basic_machine=$field1
+				basic_os=$maybe_os
+				;;
+			android-linux)
+				basic_machine=$field1-unknown
+				basic_os=linux-android
+				;;
+			*)
+				basic_machine=$field1-$field2
+				basic_os=$field3
+				;;
+		esac
+		;;
+	*-*)
+		# A lone config we happen to match not fitting any pattern
+		case $field1-$field2 in
+			decstation-3100)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			*-*)
+				# Second component is usually, but not always the OS
+				case $field2 in
+					# Prevent following clause from handling this valid os
+					sun*os*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+					# Manufacturers
+					dec* | mips* | sequent* | encore* | pc533* | sgi* | sony* \
+					| att* | 7300* | 3300* | delta* | motorola* | sun[234]* \
+					| unicom* | ibm* | next | hp | isi* | apollo | altos* \
+					| convergent* | ncr* | news | 32* | 3600* | 3100* \
+					| hitachi* | c[123]* | convex* | sun | crds | omron* | dg \
+					| ultra | tti* | harris | dolphin | highlevel | gould \
+					| cbm | ns | masscomp | apple | axis | knuth | cray \
+					| microblaze* | sim | cisco \
+					| oki | wec | wrs | winbond)
+						basic_machine=$field1-$field2
+						basic_os=
+						;;
+					*)
+						basic_machine=$field1
+						basic_os=$field2
+						;;
+				esac
+			;;
+		esac
+		;;
+	*)
+		# Convert single-component short-hands not valid as part of
+		# multi-component configurations.
+		case $field1 in
+			386bsd)
+				basic_machine=i386-pc
+				basic_os=bsd
+				;;
+			a29khif)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			adobe68k)
+				basic_machine=m68010-adobe
+				basic_os=scout
+				;;
+			alliant)
+				basic_machine=fx80-alliant
+				basic_os=
+				;;
+			altos | altos3068)
+				basic_machine=m68k-altos
+				basic_os=
+				;;
+			am29k)
+				basic_machine=a29k-none
+				basic_os=bsd
+				;;
+			amdahl)
+				basic_machine=580-amdahl
+				basic_os=sysv
+				;;
+			amiga)
+				basic_machine=m68k-unknown
+				basic_os=
+				;;
+			amigaos | amigados)
+				basic_machine=m68k-unknown
+				basic_os=amigaos
+				;;
+			amigaunix | amix)
+				basic_machine=m68k-unknown
+				basic_os=sysv4
+				;;
+			apollo68)
+				basic_machine=m68k-apollo
+				basic_os=sysv
+				;;
+			apollo68bsd)
+				basic_machine=m68k-apollo
+				basic_os=bsd
+				;;
+			aros)
+				basic_machine=i386-pc
+				basic_os=aros
+				;;
+			aux)
+				basic_machine=m68k-apple
+				basic_os=aux
+				;;
+			balance)
+				basic_machine=ns32k-sequent
+				basic_os=dynix
+				;;
+			blackfin)
+				basic_machine=bfin-unknown
+				basic_os=linux
+				;;
+			cegcc)
+				basic_machine=arm-unknown
+				basic_os=cegcc
+				;;
+			convex-c1)
+				basic_machine=c1-convex
+				basic_os=bsd
+				;;
+			convex-c2)
+				basic_machine=c2-convex
+				basic_os=bsd
+				;;
+			convex-c32)
+				basic_machine=c32-convex
+				basic_os=bsd
+				;;
+			convex-c34)
+				basic_machine=c34-convex
+				basic_os=bsd
+				;;
+			convex-c38)
+				basic_machine=c38-convex
+				basic_os=bsd
+				;;
+			cray)
+				basic_machine=j90-cray
+				basic_os=unicos
+				;;
+			crds | unos)
+				basic_machine=m68k-crds
+				basic_os=
+				;;
+			da30)
+				basic_machine=m68k-da30
+				basic_os=
+				;;
+			decstation | pmax | pmin | dec3100 | decstatn)
+				basic_machine=mips-dec
+				basic_os=
+				;;
+			delta88)
+				basic_machine=m88k-motorola
+				basic_os=sysv3
+				;;
+			dicos)
+				basic_machine=i686-pc
+				basic_os=dicos
+				;;
+			djgpp)
+				basic_machine=i586-pc
+				basic_os=msdosdjgpp
+				;;
+			ebmon29k)
+				basic_machine=a29k-amd
+				basic_os=ebmon
+				;;
+			es1800 | OSE68k | ose68k | ose | OSE)
+				basic_machine=m68k-ericsson
+				basic_os=ose
+				;;
+			gmicro)
+				basic_machine=tron-gmicro
+				basic_os=sysv
+				;;
+			go32)
+				basic_machine=i386-pc
+				basic_os=go32
+				;;
+			h8300hms)
+				basic_machine=h8300-hitachi
+				basic_os=hms
+				;;
+			h8300xray)
+				basic_machine=h8300-hitachi
+				basic_os=xray
+				;;
+			h8500hms)
+				basic_machine=h8500-hitachi
+				basic_os=hms
+				;;
+			harris)
+				basic_machine=m88k-harris
+				basic_os=sysv3
+				;;
+			hp300 | hp300hpux)
+				basic_machine=m68k-hp
+				basic_os=hpux
+				;;
+			hp300bsd)
+				basic_machine=m68k-hp
+				basic_os=bsd
+				;;
+			hppaosf)
+				basic_machine=hppa1.1-hp
+				basic_os=osf
+				;;
+			hppro)
+				basic_machine=hppa1.1-hp
+				basic_os=proelf
+				;;
+			i386mach)
+				basic_machine=i386-mach
+				basic_os=mach
+				;;
+			isi68 | isi)
+				basic_machine=m68k-isi
+				basic_os=sysv
+				;;
+			m68knommu)
+				basic_machine=m68k-unknown
+				basic_os=linux
+				;;
+			magnum | m3230)
+				basic_machine=mips-mips
+				basic_os=sysv
+				;;
+			merlin)
+				basic_machine=ns32k-utek
+				basic_os=sysv
+				;;
+			mingw64)
+				basic_machine=x86_64-pc
+				basic_os=mingw64
+				;;
+			mingw32)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			mingw32ce)
+				basic_machine=arm-unknown
+				basic_os=mingw32ce
+				;;
+			monitor)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			morphos)
+				basic_machine=powerpc-unknown
+				basic_os=morphos
+				;;
+			moxiebox)
+				basic_machine=moxie-unknown
+				basic_os=moxiebox
+				;;
+			msdos)
+				basic_machine=i386-pc
+				basic_os=msdos
+				;;
+			msys)
+				basic_machine=i686-pc
+				basic_os=msys
+				;;
+			mvs)
+				basic_machine=i370-ibm
+				basic_os=mvs
+				;;
+			nacl)
+				basic_machine=le32-unknown
+				basic_os=nacl
+				;;
+			ncr3000)
+				basic_machine=i486-ncr
+				basic_os=sysv4
+				;;
+			netbsd386)
+				basic_machine=i386-pc
+				basic_os=netbsd
+				;;
+			netwinder)
+				basic_machine=armv4l-rebel
+				basic_os=linux
+				;;
+			news | news700 | news800 | news900)
+				basic_machine=m68k-sony
+				basic_os=newsos
+				;;
+			news1000)
+				basic_machine=m68030-sony
+				basic_os=newsos
+				;;
+			necv70)
+				basic_machine=v70-nec
+				basic_os=sysv
+				;;
+			nh3000)
+				basic_machine=m68k-harris
+				basic_os=cxux
+				;;
+			nh[45]000)
+				basic_machine=m88k-harris
+				basic_os=cxux
+				;;
+			nindy960)
+				basic_machine=i960-intel
+				basic_os=nindy
+				;;
+			mon960)
+				basic_machine=i960-intel
+				basic_os=mon960
+				;;
+			nonstopux)
+				basic_machine=mips-compaq
+				basic_os=nonstopux
+				;;
+			os400)
+				basic_machine=powerpc-ibm
+				basic_os=os400
+				;;
+			OSE68000 | ose68000)
+				basic_machine=m68000-ericsson
+				basic_os=ose
+				;;
+			os68k)
+				basic_machine=m68k-none
+				basic_os=os68k
+				;;
+			paragon)
+				basic_machine=i860-intel
+				basic_os=osf
+				;;
+			parisc)
+				basic_machine=hppa-unknown
+				basic_os=linux
+				;;
+			psp)
+				basic_machine=mipsallegrexel-sony
+				basic_os=psp
+				;;
+			pw32)
+				basic_machine=i586-unknown
+				basic_os=pw32
+				;;
+			rdos | rdos64)
+				basic_machine=x86_64-pc
+				basic_os=rdos
+				;;
+			rdos32)
+				basic_machine=i386-pc
+				basic_os=rdos
+				;;
+			rom68k)
+				basic_machine=m68k-rom68k
+				basic_os=coff
+				;;
+			sa29200)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			sei)
+				basic_machine=mips-sei
+				basic_os=seiux
+				;;
+			sequent)
+				basic_machine=i386-sequent
+				basic_os=
+				;;
+			sps7)
+				basic_machine=m68k-bull
+				basic_os=sysv2
+				;;
+			st2000)
+				basic_machine=m68k-tandem
+				basic_os=
+				;;
+			stratus)
+				basic_machine=i860-stratus
+				basic_os=sysv4
+				;;
+			sun2)
+				basic_machine=m68000-sun
+				basic_os=
+				;;
+			sun2os3)
+				basic_machine=m68000-sun
+				basic_os=sunos3
+				;;
+			sun2os4)
+				basic_machine=m68000-sun
+				basic_os=sunos4
+				;;
+			sun3)
+				basic_machine=m68k-sun
+				basic_os=
+				;;
+			sun3os3)
+				basic_machine=m68k-sun
+				basic_os=sunos3
+				;;
+			sun3os4)
+				basic_machine=m68k-sun
+				basic_os=sunos4
+				;;
+			sun4)
+				basic_machine=sparc-sun
+				basic_os=
+				;;
+			sun4os3)
+				basic_machine=sparc-sun
+				basic_os=sunos3
+				;;
+			sun4os4)
+				basic_machine=sparc-sun
+				basic_os=sunos4
+				;;
+			sun4sol2)
+				basic_machine=sparc-sun
+				basic_os=solaris2
+				;;
+			sun386 | sun386i | roadrunner)
+				basic_machine=i386-sun
+				basic_os=
+				;;
+			sv1)
+				basic_machine=sv1-cray
+				basic_os=unicos
+				;;
+			symmetry)
+				basic_machine=i386-sequent
+				basic_os=dynix
+				;;
+			t3e)
+				basic_machine=alphaev5-cray
+				basic_os=unicos
+				;;
+			t90)
+				basic_machine=t90-cray
+				basic_os=unicos
+				;;
+			toad1)
+				basic_machine=pdp10-xkl
+				basic_os=tops20
+				;;
+			tpf)
+				basic_machine=s390x-ibm
+				basic_os=tpf
+				;;
+			udi29k)
+				basic_machine=a29k-amd
+				basic_os=udi
+				;;
+			ultra3)
+				basic_machine=a29k-nyu
+				basic_os=sym1
+				;;
+			v810 | necv810)
+				basic_machine=v810-nec
+				basic_os=none
+				;;
+			vaxv)
+				basic_machine=vax-dec
+				basic_os=sysv
+				;;
+			vms)
+				basic_machine=vax-dec
+				basic_os=vms
+				;;
+			vsta)
+				basic_machine=i386-pc
+				basic_os=vsta
+				;;
+			vxworks960)
+				basic_machine=i960-wrs
+				basic_os=vxworks
+				;;
+			vxworks68)
+				basic_machine=m68k-wrs
+				basic_os=vxworks
+				;;
+			vxworks29k)
+				basic_machine=a29k-wrs
+				basic_os=vxworks
+				;;
+			xbox)
+				basic_machine=i686-pc
+				basic_os=mingw32
+				;;
+			ymp)
+				basic_machine=ymp-cray
+				basic_os=unicos
+				;;
+			*)
+				basic_machine=$1
+				basic_os=
+				;;
+		esac
+		;;
+esac
+
+# Decode 1-component or ad-hoc basic machines
+case $basic_machine in
+	# Here we handle the default manufacturer of certain CPU types.  It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	w89k)
+		cpu=hppa1.1
+		vendor=winbond
+		;;
+	op50n)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	op60c)
+		cpu=hppa1.1
+		vendor=oki
+		;;
+	ibm*)
+		cpu=i370
+		vendor=ibm
+		;;
+	orion105)
+		cpu=clipper
+		vendor=highlevel
+		;;
+	mac | mpw | mac-mpw)
+		cpu=m68k
+		vendor=apple
+		;;
+	pmac | pmac-mpw)
+		cpu=powerpc
+		vendor=apple
+		;;
+
+	# Recognize the various machine names and aliases which stand
+	# for a CPU type and a company and sometimes even an OS.
+	3b1 | 7300 | 7300-att | att-7300 | pc7300 | safari | unixpc)
+		cpu=m68000
+		vendor=att
+		;;
+	3b*)
+		cpu=we32k
+		vendor=att
+		;;
+	bluegene*)
+		cpu=powerpc
+		vendor=ibm
+		basic_os=cnk
+		;;
+	decsystem10* | dec10*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops10
+		;;
+	decsystem20* | dec20*)
+		cpu=pdp10
+		vendor=dec
+		basic_os=tops20
+		;;
+	delta | 3300 | motorola-3300 | motorola-delta \
+	      | 3300-motorola | delta-motorola)
+		cpu=m68k
+		vendor=motorola
+		;;
+	dpx2*)
+		cpu=m68k
+		vendor=bull
+		basic_os=sysv3
+		;;
+	encore | umax | mmax)
+		cpu=ns32k
+		vendor=encore
+		;;
+	elxsi)
+		cpu=elxsi
+		vendor=elxsi
+		basic_os=${basic_os:-bsd}
+		;;
+	fx2800)
+		cpu=i860
+		vendor=alliant
+		;;
+	genix)
+		cpu=ns32k
+		vendor=ns
+		;;
+	h3050r* | hiux*)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	hp3k9[0-9][0-9] | hp9[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k2[0-9][0-9] | hp9k31[0-9])
+		cpu=m68000
+		vendor=hp
+		;;
+	hp9k3[2-9][0-9])
+		cpu=m68k
+		vendor=hp
+		;;
+	hp9k6[0-9][0-9] | hp6[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	hp9k7[0-79][0-9] | hp7[0-79][0-9])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k78[0-9] | hp78[0-9])
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[67]1 | hp8[67]1 | hp9k80[24] | hp80[24] | hp9k8[78]9 | hp8[78]9 | hp9k893 | hp893)
+		# FIXME: really hppa2.0-hp
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][13679] | hp8[0-9][13679])
+		cpu=hppa1.1
+		vendor=hp
+		;;
+	hp9k8[0-9][0-9] | hp8[0-9][0-9])
+		cpu=hppa1.0
+		vendor=hp
+		;;
+	i*86v32)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv32
+		;;
+	i*86v4*)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv4
+		;;
+	i*86v)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=sysv
+		;;
+	i*86sol2)
+		cpu=`echo "$1" | sed -e 's/86.*/86/'`
+		vendor=pc
+		basic_os=solaris2
+		;;
+	j90 | j90-cray)
+		cpu=j90
+		vendor=cray
+		basic_os=${basic_os:-unicos}
+		;;
+	iris | iris4d)
+		cpu=mips
+		vendor=sgi
+		case $basic_os in
+		    irix*)
+			;;
+		    *)
+			basic_os=irix4
+			;;
+		esac
+		;;
+	miniframe)
+		cpu=m68000
+		vendor=convergent
+		;;
+	*mint | mint[0-9]* | *MiNT | *MiNT[0-9]*)
+		cpu=m68k
+		vendor=atari
+		basic_os=mint
+		;;
+	news-3600 | risc-news)
+		cpu=mips
+		vendor=sony
+		basic_os=newsos
+		;;
+	next | m*-next)
+		cpu=m68k
+		vendor=next
+		case $basic_os in
+		    openstep*)
+		        ;;
+		    nextstep*)
+			;;
+		    ns2*)
+		      basic_os=nextstep2
+			;;
+		    *)
+		      basic_os=nextstep3
+			;;
+		esac
+		;;
+	np1)
+		cpu=np1
+		vendor=gould
+		;;
+	op50n-* | op60c-*)
+		cpu=hppa1.1
+		vendor=oki
+		basic_os=proelf
+		;;
+	pa-hitachi)
+		cpu=hppa1.1
+		vendor=hitachi
+		basic_os=hiuxwe2
+		;;
+	pbd)
+		cpu=sparc
+		vendor=tti
+		;;
+	pbb)
+		cpu=m68k
+		vendor=tti
+		;;
+	pc532)
+		cpu=ns32k
+		vendor=pc532
+		;;
+	pn)
+		cpu=pn
+		vendor=gould
+		;;
+	power)
+		cpu=power
+		vendor=ibm
+		;;
+	ps2)
+		cpu=i386
+		vendor=ibm
+		;;
+	rm[46]00)
+		cpu=mips
+		vendor=siemens
+		;;
+	rtpc | rtpc-*)
+		cpu=romp
+		vendor=ibm
+		;;
+	sde)
+		cpu=mipsisa32
+		vendor=sde
+		basic_os=${basic_os:-elf}
+		;;
+	simso-wrs)
+		cpu=sparclite
+		vendor=wrs
+		basic_os=vxworks
+		;;
+	tower | tower-32)
+		cpu=m68k
+		vendor=ncr
+		;;
+	vpp*|vx|vx-*)
+		cpu=f301
+		vendor=fujitsu
+		;;
+	w65)
+		cpu=w65
+		vendor=wdc
+		;;
+	w89k-*)
+		cpu=hppa1.1
+		vendor=winbond
+		basic_os=proelf
+		;;
+	none)
+		cpu=none
+		vendor=none
+		;;
+	leon|leon[3-9])
+		cpu=sparc
+		vendor=$basic_machine
+		;;
+	leon-*|leon[3-9]-*)
+		cpu=sparc
+		vendor=`echo "$basic_machine" | sed 's/-.*//'`
+		;;
+
+	*-*)
+		# shellcheck disable=SC2162
+		IFS="-" read cpu vendor <<EOF
+$basic_machine
+EOF
+		;;
+	# We use `pc' rather than `unknown'
+	# because (1) that's what they normally are, and
+	# (2) the word "unknown" tends to confuse beginning users.
+	i*86 | x86_64)
+		cpu=$basic_machine
+		vendor=pc
+		;;
+	# These rules are duplicated from below for sake of the special case above;
+	# i.e. things that normalized to x86 arches should also default to "pc"
+	pc98)
+		cpu=i386
+		vendor=pc
+		;;
+	x64 | amd64)
+		cpu=x86_64
+		vendor=pc
+		;;
+	# Recognize the basic CPU types without company name.
+	*)
+		cpu=$basic_machine
+		vendor=unknown
+		;;
+esac
+
+unset -v basic_machine
+
+# Decode basic machines in the full and proper CPU-Company form.
+case $cpu-$vendor in
+	# Here we handle the default manufacturer of certain CPU types in canonical form. It is in
+	# some cases the only manufacturer, in others, it is the most popular.
+	craynv-unknown)
+		vendor=cray
+		basic_os=${basic_os:-unicosmp}
+		;;
+	c90-unknown | c90-cray)
+		vendor=cray
+		basic_os=${Basic_os:-unicos}
+		;;
+	fx80-unknown)
+		vendor=alliant
+		;;
+	romp-unknown)
+		vendor=ibm
+		;;
+	mmix-unknown)
+		vendor=knuth
+		;;
+	microblaze-unknown | microblazeel-unknown)
+		vendor=xilinx
+		;;
+	rs6000-unknown)
+		vendor=ibm
+		;;
+	vax-unknown)
+		vendor=dec
+		;;
+	pdp11-unknown)
+		vendor=dec
+		;;
+	we32k-unknown)
+		vendor=att
+		;;
+	cydra-unknown)
+		vendor=cydrome
+		;;
+	i370-ibm*)
+		vendor=ibm
+		;;
+	orion-unknown)
+		vendor=highlevel
+		;;
+	xps-unknown | xps100-unknown)
+		cpu=xps100
+		vendor=honeywell
+		;;
+
+	# Here we normalize CPU types with a missing or matching vendor
+	dpx20-unknown | dpx20-bull)
+		cpu=rs6000
+		vendor=bull
+		basic_os=${basic_os:-bosx}
+		;;
+
+	# Here we normalize CPU types irrespective of the vendor
+	amd64-*)
+		cpu=x86_64
+		;;
+	blackfin-*)
+		cpu=bfin
+		basic_os=linux
+		;;
+	c54x-*)
+		cpu=tic54x
+		;;
+	c55x-*)
+		cpu=tic55x
+		;;
+	c6x-*)
+		cpu=tic6x
+		;;
+	e500v[12]-*)
+		cpu=powerpc
+		basic_os=${basic_os}"spe"
+		;;
+	mips3*-*)
+		cpu=mips64
+		;;
+	ms1-*)
+		cpu=mt
+		;;
+	m68knommu-*)
+		cpu=m68k
+		basic_os=linux
+		;;
+	m9s12z-* | m68hcs12z-* | hcs12z-* | s12z-*)
+		cpu=s12z
+		;;
+	openrisc-*)
+		cpu=or32
+		;;
+	parisc-*)
+		cpu=hppa
+		basic_os=linux
+		;;
+	pentium-* | p5-* | k5-* | k6-* | nexgen-* | viac3-*)
+		cpu=i586
+		;;
+	pentiumpro-* | p6-* | 6x86-* | athlon-* | athalon_*-*)
+		cpu=i686
+		;;
+	pentiumii-* | pentium2-* | pentiumiii-* | pentium3-*)
+		cpu=i686
+		;;
+	pentium4-*)
+		cpu=i786
+		;;
+	pc98-*)
+		cpu=i386
+		;;
+	ppc-* | ppcbe-*)
+		cpu=powerpc
+		;;
+	ppcle-* | powerpclittle-*)
+		cpu=powerpcle
+		;;
+	ppc64-*)
+		cpu=powerpc64
+		;;
+	ppc64le-* | powerpc64little-*)
+		cpu=powerpc64le
+		;;
+	sb1-*)
+		cpu=mipsisa64sb1
+		;;
+	sb1el-*)
+		cpu=mipsisa64sb1el
+		;;
+	sh5e[lb]-*)
+		cpu=`echo "$cpu" | sed 's/^\(sh.\)e\(.\)$/\1\2e/'`
+		;;
+	spur-*)
+		cpu=spur
+		;;
+	strongarm-* | thumb-*)
+		cpu=arm
+		;;
+	tx39-*)
+		cpu=mipstx39
+		;;
+	tx39el-*)
+		cpu=mipstx39el
+		;;
+	x64-*)
+		cpu=x86_64
+		;;
+	xscale-* | xscalee[bl]-*)
+		cpu=`echo "$cpu" | sed 's/^xscale/arm/'`
+		;;
+	arm64-*)
+		cpu=aarch64
+		;;
+
+	# Recognize the canonical CPU Types that limit and/or modify the
+	# company names they are paired with.
+	cr16-*)
+		basic_os=${basic_os:-elf}
+		;;
+	crisv32-* | etraxfs*-*)
+		cpu=crisv32
+		vendor=axis
+		;;
+	cris-* | etrax*-*)
+		cpu=cris
+		vendor=axis
+		;;
+	crx-*)
+		basic_os=${basic_os:-elf}
+		;;
+	neo-tandem)
+		cpu=neo
+		vendor=tandem
+		;;
+	nse-tandem)
+		cpu=nse
+		vendor=tandem
+		;;
+	nsr-tandem)
+		cpu=nsr
+		vendor=tandem
+		;;
+	nsv-tandem)
+		cpu=nsv
+		vendor=tandem
+		;;
+	nsx-tandem)
+		cpu=nsx
+		vendor=tandem
+		;;
+	mipsallegrexel-sony)
+		cpu=mipsallegrexel
+		vendor=sony
+		;;
+	tile*-*)
+		basic_os=${basic_os:-linux-gnu}
+		;;
+
+	*)
+		# Recognize the canonical CPU types that are allowed with any
+		# company name.
+		case $cpu in
+			1750a | 580 \
+			| a29k \
+			| aarch64 | aarch64_be \
+			| abacus \
+			| alpha | alphaev[4-8] | alphaev56 | alphaev6[78] \
+			| alpha64 | alpha64ev[4-8] | alpha64ev56 | alpha64ev6[78] \
+			| alphapca5[67] | alpha64pca5[67] \
+			| am33_2.0 \
+			| amdgcn \
+			| arc | arceb \
+			| arm | arm[lb]e | arme[lb] | armv* \
+			| avr | avr32 \
+			| asmjs \
+			| ba \
+			| be32 | be64 \
+			| bfin | bpf | bs2000 \
+			| c[123]* | c30 | [cjt]90 | c4x \
+			| c8051 | clipper | craynv | csky | cydra \
+			| d10v | d30v | dlx | dsp16xx \
+			| e2k | elxsi | epiphany \
+			| f30[01] | f700 | fido | fr30 | frv | ft32 | fx80 \
+			| h8300 | h8500 \
+			| hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \
+			| hexagon \
+			| i370 | i*86 | i860 | i960 | ia16 | ia64 \
+			| ip2k | iq2000 \
+			| k1om \
+			| le32 | le64 \
+			| lm32 \
+			| m32c | m32r | m32rle \
+			| m5200 | m68000 | m680[012346]0 | m68360 | m683?2 | m68k \
+			| m6811 | m68hc11 | m6812 | m68hc12 | m68hcs12x \
+			| m88110 | m88k | maxq | mb | mcore | mep | metag \
+			| microblaze | microblazeel \
+			| mips | mipsbe | mipseb | mipsel | mipsle \
+			| mips16 \
+			| mips64 | mips64eb | mips64el \
+			| mips64octeon | mips64octeonel \
+			| mips64orion | mips64orionel \
+			| mips64r5900 | mips64r5900el \
+			| mips64vr | mips64vrel \
+			| mips64vr4100 | mips64vr4100el \
+			| mips64vr4300 | mips64vr4300el \
+			| mips64vr5000 | mips64vr5000el \
+			| mips64vr5900 | mips64vr5900el \
+			| mipsisa32 | mipsisa32el \
+			| mipsisa32r2 | mipsisa32r2el \
+			| mipsisa32r6 | mipsisa32r6el \
+			| mipsisa64 | mipsisa64el \
+			| mipsisa64r2 | mipsisa64r2el \
+			| mipsisa64r6 | mipsisa64r6el \
+			| mipsisa64sb1 | mipsisa64sb1el \
+			| mipsisa64sr71k | mipsisa64sr71kel \
+			| mipsr5900 | mipsr5900el \
+			| mipstx39 | mipstx39el \
+			| mmix \
+			| mn10200 | mn10300 \
+			| moxie \
+			| mt \
+			| msp430 \
+			| nds32 | nds32le | nds32be \
+			| nfp \
+			| nios | nios2 | nios2eb | nios2el \
+			| none | np1 | ns16k | ns32k | nvptx \
+			| open8 \
+			| or1k* \
+			| or32 \
+			| orion \
+			| picochip \
+			| pdp10 | pdp11 | pj | pjl | pn | power \
+			| powerpc | powerpc64 | powerpc64le | powerpcle | powerpcspe \
+			| pru \
+			| pyramid \
+			| riscv | riscv32 | riscv64 \
+			| rl78 | romp | rs6000 | rx \
+			| s390 | s390x \
+			| score \
+			| sh | shl \
+			| sh[1234] | sh[24]a | sh[24]ae[lb] | sh[23]e | she[lb] | sh[lb]e \
+			| sh[1234]e[lb] |  sh[12345][lb]e | sh[23]ele | sh64 | sh64le \
+			| sparc | sparc64 | sparc64b | sparc64v | sparc86x | sparclet \
+			| sparclite \
+			| sparcv8 | sparcv9 | sparcv9b | sparcv9v | sv1 | sx* \
+			| spu \
+			| tahoe \
+			| tic30 | tic4x | tic54x | tic55x | tic6x | tic80 \
+			| tron \
+			| ubicom32 \
+			| v70 | v850 | v850e | v850e1 | v850es | v850e2 | v850e2v3 \
+			| vax \
+			| visium \
+			| w65 \
+			| wasm32 | wasm64 \
+			| we32k \
+			| x86 | x86_64 | xc16x | xgate | xps100 \
+			| xstormy16 | xtensa* \
+			| ymp \
+			| z8k | z80)
+				;;
+
+			*)
+				echo Invalid configuration \`"$1"\': machine \`"$cpu-$vendor"\' not recognized 1>&2
+				exit 1
+				;;
+		esac
+		;;
+esac
+
+# Here we canonicalize certain aliases for manufacturers.
+case $vendor in
+	digital*)
+		vendor=dec
+		;;
+	commodore*)
+		vendor=cbm
+		;;
+	*)
+		;;
+esac
+
+# Decode manufacturer-specific aliases for certain operating systems.
+
+if [ x$basic_os != x ]
+then
+
+# First recognize some ad-hoc caes, or perhaps split kernel-os, or else just
+# set os.
+case $basic_os in
+	gnu/linux*)
+		kernel=linux
+		os=`echo $basic_os | sed -e 's|gnu/linux|gnu|'`
+		;;
+	nto-qnx*)
+		kernel=nto
+		os=`echo $basic_os | sed -e 's|nto-qnx|qnx|'`
+		;;
+	*-*)
+		# shellcheck disable=SC2162
+		IFS="-" read kernel os <<EOF
+$basic_os
+EOF
+		;;
+	# Default OS when just kernel was specified
+	nto*)
+		kernel=nto
+		os=`echo $basic_os | sed -e 's|nto|qnx|'`
+		;;
+	linux*)
+		kernel=linux
+		os=`echo $basic_os | sed -e 's|linux|gnu|'`
+		;;
+	*)
+		kernel=
+		os=$basic_os
+		;;
+esac
+
+# Now, normalize the OS (knowing we just have one component, it's not a kernel,
+# etc.)
+case $os in
+	# First match some system type aliases that might get confused
+	# with valid system types.
+	# solaris* is a basic system type, with this one exception.
+	auroraux)
+		os=auroraux
+		;;
+	bluegene*)
+		os=cnk
+		;;
+	solaris1 | solaris1.*)
+		os=`echo $os | sed -e 's|solaris1|sunos4|'`
+		;;
+	solaris)
+		os=solaris2
+		;;
+	unixware*)
+		os=sysv4.2uw
+		;;
+	# es1800 is here to avoid being matched by es* (a different OS)
+	es1800*)
+		os=ose
+		;;
+	# Some version numbers need modification
+	chorusos*)
+		os=chorusos
+		;;
+	isc)
+		os=isc2.2
+		;;
+	sco6)
+		os=sco5v6
+		;;
+	sco5)
+		os=sco3.2v5
+		;;
+	sco4)
+		os=sco3.2v4
+		;;
+	sco3.2.[4-9]*)
+		os=`echo $os | sed -e 's/sco3.2./sco3.2v/'`
+		;;
+	sco*v* | scout)
+		# Don't match below
+		;;
+	sco*)
+		os=sco3.2v2
+		;;
+	psos*)
+		os=psos
+		;;
+	qnx*)
+		case $cpu in
+		    x86 | i*86)
+			;;
+		    *)
+			os=nto-$os
+			;;
+		esac
+		;;
+	hiux*)
+		os=hiuxwe2
+		;;
+	lynx*178)
+		os=lynxos178
+		;;
+	lynx*5)
+		os=lynxos5
+		;;
+	lynxos*)
+		# don't get caught up in next wildcard
+		;;
+	lynx*)
+		os=lynxos
+		;;
+	mac[0-9]*)
+		os=`echo "$os" | sed -e 's|mac|macos|'`
+		;;
+	opened*)
+		os=openedition
+		;;
+	os400*)
+		os=os400
+		;;
+	sunos5*)
+		os=`echo "$os" | sed -e 's|sunos5|solaris2|'`
+		;;
+	sunos6*)
+		os=`echo "$os" | sed -e 's|sunos6|solaris3|'`
+		;;
+	wince*)
+		os=wince
+		;;
+	utek*)
+		os=bsd
+		;;
+	dynix*)
+		os=bsd
+		;;
+	acis*)
+		os=aos
+		;;
+	atheos*)
+		os=atheos
+		;;
+	syllable*)
+		os=syllable
+		;;
+	386bsd)
+		os=bsd
+		;;
+	ctix* | uts*)
+		os=sysv
+		;;
+	nova*)
+		os=rtmk-nova
+		;;
+	ns2)
+		os=nextstep2
+		;;
+	# Preserve the version number of sinix5.
+	sinix5.*)
+		os=`echo $os | sed -e 's|sinix|sysv|'`
+		;;
+	sinix*)
+		os=sysv4
+		;;
+	tpf*)
+		os=tpf
+		;;
+	triton*)
+		os=sysv3
+		;;
+	oss*)
+		os=sysv3
+		;;
+	svr4*)
+		os=sysv4
+		;;
+	svr3)
+		os=sysv3
+		;;
+	sysvr4)
+		os=sysv4
+		;;
+	ose*)
+		os=ose
+		;;
+	*mint | mint[0-9]* | *MiNT | MiNT[0-9]*)
+		os=mint
+		;;
+	dicos*)
+		os=dicos
+		;;
+	pikeos*)
+		# Until real need of OS specific support for
+		# particular features comes up, bare metal
+		# configurations are quite functional.
+		case $cpu in
+		    arm*)
+			os=eabi
+			;;
+		    *)
+			os=elf
+			;;
+		esac
+		;;
+	*)
+		# No normalization, but not necessarily accepted, that comes below.
+		;;
+esac
+
+else
+
+# Here we handle the default operating systems that come with various machines.
+# The value should be what the vendor currently ships out the door with their
+# machine or put another way, the most popular os provided with the machine.
+
+# Note that if you're going to try to match "-MANUFACTURER" here (say,
+# "-sun"), then you have to tell the case statement up towards the top
+# that MANUFACTURER isn't an operating system.  Otherwise, code above
+# will signal an error saying that MANUFACTURER isn't an operating
+# system, and we'll never get to this point.
+
+kernel=
+case $cpu-$vendor in
+	score-*)
+		os=elf
+		;;
+	spu-*)
+		os=elf
+		;;
+	*-acorn)
+		os=riscix1.2
+		;;
+	arm*-rebel)
+		kernel=linux
+		os=gnu
+		;;
+	arm*-semi)
+		os=aout
+		;;
+	c4x-* | tic4x-*)
+		os=coff
+		;;
+	c8051-*)
+		os=elf
+		;;
+	clipper-intergraph)
+		os=clix
+		;;
+	hexagon-*)
+		os=elf
+		;;
+	tic54x-*)
+		os=coff
+		;;
+	tic55x-*)
+		os=coff
+		;;
+	tic6x-*)
+		os=coff
+		;;
+	# This must come before the *-dec entry.
+	pdp10-*)
+		os=tops20
+		;;
+	pdp11-*)
+		os=none
+		;;
+	*-dec | vax-*)
+		os=ultrix4.2
+		;;
+	m68*-apollo)
+		os=domain
+		;;
+	i386-sun)
+		os=sunos4.0.2
+		;;
+	m68000-sun)
+		os=sunos3
+		;;
+	m68*-cisco)
+		os=aout
+		;;
+	mep-*)
+		os=elf
+		;;
+	mips*-cisco)
+		os=elf
+		;;
+	mips*-*)
+		os=elf
+		;;
+	or32-*)
+		os=coff
+		;;
+	*-tti)	# must be before sparc entry or we get the wrong os.
+		os=sysv3
+		;;
+	sparc-* | *-sun)
+		os=sunos4.1.1
+		;;
+	pru-*)
+		os=elf
+		;;
+	*-be)
+		os=beos
+		;;
+	*-ibm)
+		os=aix
+		;;
+	*-knuth)
+		os=mmixware
+		;;
+	*-wec)
+		os=proelf
+		;;
+	*-winbond)
+		os=proelf
+		;;
+	*-oki)
+		os=proelf
+		;;
+	*-hp)
+		os=hpux
+		;;
+	*-hitachi)
+		os=hiux
+		;;
+	i860-* | *-att | *-ncr | *-altos | *-motorola | *-convergent)
+		os=sysv
+		;;
+	*-cbm)
+		os=amigaos
+		;;
+	*-dg)
+		os=dgux
+		;;
+	*-dolphin)
+		os=sysv3
+		;;
+	m68k-ccur)
+		os=rtu
+		;;
+	m88k-omron*)
+		os=luna
+		;;
+	*-next)
+		os=nextstep
+		;;
+	*-sequent)
+		os=ptx
+		;;
+	*-crds)
+		os=unos
+		;;
+	*-ns)
+		os=genix
+		;;
+	i370-*)
+		os=mvs
+		;;
+	*-gould)
+		os=sysv
+		;;
+	*-highlevel)
+		os=bsd
+		;;
+	*-encore)
+		os=bsd
+		;;
+	*-sgi)
+		os=irix
+		;;
+	*-siemens)
+		os=sysv4
+		;;
+	*-masscomp)
+		os=rtu
+		;;
+	f30[01]-fujitsu | f700-fujitsu)
+		os=uxpv
+		;;
+	*-rom68k)
+		os=coff
+		;;
+	*-*bug)
+		os=coff
+		;;
+	*-apple)
+		os=macos
+		;;
+	*-atari*)
+		os=mint
+		;;
+	*-wrs)
+		os=vxworks
+		;;
+	*)
+		os=none
+		;;
+esac
+
+fi
+
+# Now, validate our (potentially fixed-up) OS.
+case $os in
+	# Sometimes we do "kernel-abi", so those need to count as OSes.
+	musl* | newlib* | uclibc*)
+		;;
+	# Likewise for "kernel-libc"
+	eabi | eabisim | eabihf | gnueabi | gnueabihf)
+		;;
+	# Now accept the basic system types.
+	# The portable systems comes first.
+	# Each alternative MUST end in a * to match a version number.
+	gnu* | android* | bsd* | mach* | minix* | genix* | ultrix* | irix* \
+	     | *vms* | esix* | aix* | cnk* | sunos | sunos[34]* \
+	     | hpux* | unos* | osf* | luna* | dgux* | auroraux* | solaris* \
+	     | sym* |  plan9* | psp* | sim* | xray* | os68k* | v88r* \
+	     | hiux* | abug | nacl* | netware* | windows* \
+	     | os9* | macos* | osx* | ios* \
+	     | mpw* | magic* | mmixware* | mon960* | lnews* \
+	     | amigaos* | amigados* | msdos* | newsos* | unicos* | aof* \
+	     | aos* | aros* | cloudabi* | sortix* | twizzler* \
+	     | nindy* | vxsim* | vxworks* | ebmon* | hms* | mvs* \
+	     | clix* | riscos* | uniplus* | iris* | isc* | rtu* | xenix* \
+	     | mirbsd* | netbsd* | dicos* | openedition* | ose* \
+	     | bitrig* | openbsd* | solidbsd* | libertybsd* | os108* \
+	     | ekkobsd* | freebsd* | riscix* | lynxos* | os400* \
+	     | bosx* | nextstep* | cxux* | aout* | elf* | oabi* \
+	     | ptx* | coff* | ecoff* | winnt* | domain* | vsta* \
+	     | udi* | lites* | ieee* | go32* | aux* | hcos* \
+	     | chorusrdb* | cegcc* | glidix* \
+	     | cygwin* | msys* | pe* | moss* | proelf* | rtems* \
+	     | midipix* | mingw32* | mingw64* | mint* \
+	     | uxpv* | beos* | mpeix* | udk* | moxiebox* \
+	     | interix* | uwin* | mks* | rhapsody* | darwin* \
+	     | openstep* | oskit* | conix* | pw32* | nonstopux* \
+	     | storm-chaos* | tops10* | tenex* | tops20* | its* \
+	     | os2* | vos* | palmos* | uclinux* | nucleus* | morphos* \
+	     | scout* | superux* | sysv* | rtmk* | tpf* | windiss* \
+	     | powermax* | dnix* | nx6 | nx7 | sei* | dragonfly* \
+	     | skyos* | haiku* | rdos* | toppers* | drops* | es* \
+	     | onefs* | tirtos* | phoenix* | fuchsia* | redox* | bme* \
+	     | midnightbsd* | amdhsa* | unleashed* | emscripten* | wasi* \
+	     | nsk* | powerunix* | genode* | zvmoe* )
+		;;
+	# This one is extra strict with allowed versions
+	sco3.2v2 | sco3.2v[4-9]* | sco5v6*)
+		# Don't forget version if it is 3.2v4 or newer.
+		;;
+	none)
+		;;
+	*)
+		echo Invalid configuration \`"$1"\': OS \`"$os"\' not recognized 1>&2
+		exit 1
+		;;
+esac
+
+# As a final step for OS-related things, validate the OS-kernel combination
+# (given a valid OS), if there is a kernel.
+case $kernel-$os in
+	linux-gnu* | linux-dietlibc* | linux-android* | linux-newlib* | linux-musl* | linux-uclibc* )
+		;;
+	-dietlibc* | -newlib* | -musl* | -uclibc* )
+		# These are just libc implementations, not actual OSes, and thus
+		# require a kernel.
+		echo "Invalid configuration \`$1': libc \`$os' needs explicit kernel." 1>&2
+		exit 1
+		;;
+	kfreebsd*-gnu* | kopensolaris*-gnu*)
+		;;
+	nto-qnx*)
+		;;
+	*-eabi* | *-gnueabi*)
+		;;
+	-*)
+		# Blank kernel with real OS is always fine.
+		;;
+	*-*)
+		echo "Invalid configuration \`$1': Kernel \`$kernel' not known to work with OS \`$os'." 1>&2
+		exit 1
+		;;
+esac
+
+# Here we handle the case where we know the os, and the CPU type, but not the
+# manufacturer.  We pick the logical manufacturer.
+case $vendor in
+	unknown)
+		case $cpu-$os in
+			*-riscix*)
+				vendor=acorn
+				;;
+			*-sunos*)
+				vendor=sun
+				;;
+			*-cnk* | *-aix*)
+				vendor=ibm
+				;;
+			*-beos*)
+				vendor=be
+				;;
+			*-hpux*)
+				vendor=hp
+				;;
+			*-mpeix*)
+				vendor=hp
+				;;
+			*-hiux*)
+				vendor=hitachi
+				;;
+			*-unos*)
+				vendor=crds
+				;;
+			*-dgux*)
+				vendor=dg
+				;;
+			*-luna*)
+				vendor=omron
+				;;
+			*-genix*)
+				vendor=ns
+				;;
+			*-clix*)
+				vendor=intergraph
+				;;
+			*-mvs* | *-opened*)
+				vendor=ibm
+				;;
+			*-os400*)
+				vendor=ibm
+				;;
+			s390-* | s390x-*)
+				vendor=ibm
+				;;
+			*-ptx*)
+				vendor=sequent
+				;;
+			*-tpf*)
+				vendor=ibm
+				;;
+			*-vxsim* | *-vxworks* | *-windiss*)
+				vendor=wrs
+				;;
+			*-aux*)
+				vendor=apple
+				;;
+			*-hms*)
+				vendor=hitachi
+				;;
+			*-mpw* | *-macos*)
+				vendor=apple
+				;;
+			*-*mint | *-mint[0-9]* | *-*MiNT | *-MiNT[0-9]*)
+				vendor=atari
+				;;
+			*-vos*)
+				vendor=stratus
+				;;
+		esac
+		;;
+esac
+
+echo "$cpu-$vendor-${kernel:+$kernel-}$os"
+exit
+
+# Local variables:
+# eval: (add-hook 'before-save-hook 'time-stamp)
+# time-stamp-start: "timestamp='"
+# time-stamp-format: "%:y-%02m-%02d"
+# time-stamp-end: "'"
+# End:
diff -urN libffi-3.4.2.ori/configure.host libffi-3.4.2/configure.host
--- libffi-3.4.2.ori/configure.host	2021-06-27 23:17:08.000000000 +0800
+++ libffi-3.4.2/configure.host	2022-11-01 23:26:36.286463049 +0800
@@ -140,6 +140,11 @@
 	SOURCES="ffi.c sysv.S"
 	;;
 
+  loongarch64-*-*)
+	TARGET=LOONGARCH; TARGETDIR=loongarch
+	SOURCES="ffi.c sysv.S"
+	;;
+
   m32r*-*-*)
 	TARGET=M32R; TARGETDIR=m32r
 	SOURCES="ffi.c sysv.S"
diff -urN libffi-3.4.2.ori/Makefile.am libffi-3.4.2/Makefile.am
--- libffi-3.4.2.ori/Makefile.am	2021-06-27 23:17:08.000000000 +0800
+++ libffi-3.4.2/Makefile.am	2022-11-01 23:26:36.286463049 +0800
@@ -51,6 +51,7 @@
 	src/avr32/ffitarget.h src/bfin/ffitarget.h			\
 	src/cris/ffitarget.h src/csky/ffitarget.h src/frv/ffitarget.h	\
 	src/ia64/ffitarget.h src/ia64/ia64_flags.h			\
+	src/loongarch/ffitarget.h   \
 	src/m32r/ffitarget.h src/m68k/ffitarget.h			\
 	src/m88k/ffitarget.h src/metag/ffitarget.h			\
 	src/microblaze/ffitarget.h src/mips/ffitarget.h			\
@@ -93,7 +94,7 @@
 	src/x86/ffiw64.c src/x86/win64.S src/x86/ffi64.c		\
 	src/x86/unix64.S src/x86/sysv_intel.S src/x86/win64_intel.S	\
 	src/xtensa/ffi.c src/xtensa/sysv.S src/kvx/ffi.c		\
-	src/kvx/sysv.S
+	src/kvx/sysv.S src/loongarch/ffi.c src/loongarch/sysv.S
 
 TARGET_OBJ = @TARGET_OBJ@
 libffi_la_LIBADD = $(TARGET_OBJ)
diff -urN libffi-3.4.2.ori/Makefile.in libffi-3.4.2/Makefile.in
--- libffi-3.4.2.ori/Makefile.in	2021-06-29 09:09:56.000000000 +0800
+++ libffi-3.4.2/Makefile.in	2022-11-01 23:26:36.286463049 +0800
@@ -833,6 +833,16 @@
 	src/ia64/$(DEPDIR)/$(am__dirstamp)
 src/ia64/unix.lo: src/ia64/$(am__dirstamp) \
 	src/ia64/$(DEPDIR)/$(am__dirstamp)
+src/loongarch/$(am__dirstamp):
+	@$(MKDIR_P) src/loongarch
+	@: > src/loongarch/$(am__dirstamp)
+src/loongarch/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/loongarch/$(DEPDIR)
+	@: > src/loongarch/$(DEPDIR)/$(am__dirstamp)
+src/loongarch/ffi.lo: src/loongarch/$(am__dirstamp) \
+	src/loongarch/$(DEPDIR)/$(am__dirstamp)
+src/loongarch/sysv.lo: src/loongarch/$(am__dirstamp) \
+	src/loongarch/$(DEPDIR)/$(am__dirstamp)
 src/m32r/$(am__dirstamp):
 	@$(MKDIR_P) src/m32r
 	@: > src/m32r/$(am__dirstamp)
@@ -1154,6 +1164,8 @@
 	-rm -f src/x86/*.lo
 	-rm -f src/xtensa/*.$(OBJEXT)
 	-rm -f src/xtensa/*.lo
+	-rm -f src/loongarch/*.$(OBJEXT)
+	-rm -f src/loongarch/*.lo
 
 distclean-compile:
 	-rm -f *.tab.c
@@ -1873,6 +1885,8 @@
 	-rm -f src/x86/$(DEPDIR)/win64_intel.Plo
 	-rm -f src/xtensa/$(DEPDIR)/ffi.Plo
 	-rm -f src/xtensa/$(DEPDIR)/sysv.Plo
+	-rm -f src/loongarch/$(DEPDIR)/ffi.Plo
+	-rm -f src/loongarch/$(DEPDIR)/sysv.Plo
 	-rm -f Makefile
 distclean-am: clean-am distclean-compile distclean-generic \
 	distclean-hdr distclean-libtool distclean-tags
@@ -2011,6 +2025,8 @@
 	-rm -f src/x86/$(DEPDIR)/win64_intel.Plo
 	-rm -f src/xtensa/$(DEPDIR)/ffi.Plo
 	-rm -f src/xtensa/$(DEPDIR)/sysv.Plo
+	-rm -f src/loongarch/$(DEPDIR)/ffi.Plo
+	-rm -f src/loongarch/$(DEPDIR)/sysv.Plo
 	-rm -f Makefile
 maintainer-clean-am: distclean-am maintainer-clean-generic
 
diff -urN libffi-3.4.2.ori/Makefile.in.orig libffi-3.4.2/Makefile.in.orig
--- libffi-3.4.2.ori/Makefile.in.orig	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/Makefile.in.orig	2021-06-29 09:09:56.000000000 +0800
@@ -0,0 +1,2075 @@
+# Makefile.in generated by automake 1.16.2 from Makefile.am.
+# @configure_input@
+
+# Copyright (C) 1994-2020 Free Software Foundation, Inc.
+
+# This Makefile.in is free software; the Free Software Foundation
+# gives unlimited permission to copy and/or distribute it,
+# with or without modifications, as long as this notice is preserved.
+
+# This program is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY, to the extent permitted by law; without
+# even the implied warranty of MERCHANTABILITY or FITNESS FOR A
+# PARTICULAR PURPOSE.
+
+@SET_MAKE@
+
+
+
+VPATH = @srcdir@
+am__is_gnu_make = { \
+  if test -z '$(MAKELEVEL)'; then \
+    false; \
+  elif test -n '$(MAKE_HOST)'; then \
+    true; \
+  elif test -n '$(MAKE_VERSION)' && test -n '$(CURDIR)'; then \
+    true; \
+  else \
+    false; \
+  fi; \
+}
+am__make_running_with_option = \
+  case $${target_option-} in \
+      ?) ;; \
+      *) echo "am__make_running_with_option: internal error: invalid" \
+              "target option '$${target_option-}' specified" >&2; \
+         exit 1;; \
+  esac; \
+  has_opt=no; \
+  sane_makeflags=$$MAKEFLAGS; \
+  if $(am__is_gnu_make); then \
+    sane_makeflags=$$MFLAGS; \
+  else \
+    case $$MAKEFLAGS in \
+      *\\[\ \	]*) \
+        bs=\\; \
+        sane_makeflags=`printf '%s\n' "$$MAKEFLAGS" \
+          | sed "s/$$bs$$bs[$$bs $$bs	]*//g"`;; \
+    esac; \
+  fi; \
+  skip_next=no; \
+  strip_trailopt () \
+  { \
+    flg=`printf '%s\n' "$$flg" | sed "s/$$1.*$$//"`; \
+  }; \
+  for flg in $$sane_makeflags; do \
+    test $$skip_next = yes && { skip_next=no; continue; }; \
+    case $$flg in \
+      *=*|--*) continue;; \
+        -*I) strip_trailopt 'I'; skip_next=yes;; \
+      -*I?*) strip_trailopt 'I';; \
+        -*O) strip_trailopt 'O'; skip_next=yes;; \
+      -*O?*) strip_trailopt 'O';; \
+        -*l) strip_trailopt 'l'; skip_next=yes;; \
+      -*l?*) strip_trailopt 'l';; \
+      -[dEDm]) skip_next=yes;; \
+      -[JT]) skip_next=yes;; \
+    esac; \
+    case $$flg in \
+      *$$target_option*) has_opt=yes; break;; \
+    esac; \
+  done; \
+  test $$has_opt = yes
+am__make_dryrun = (target_option=n; $(am__make_running_with_option))
+am__make_keepgoing = (target_option=k; $(am__make_running_with_option))
+pkgdatadir = $(datadir)/@PACKAGE@
+pkgincludedir = $(includedir)/@PACKAGE@
+pkglibdir = $(libdir)/@PACKAGE@
+pkglibexecdir = $(libexecdir)/@PACKAGE@
+am__cd = CDPATH="$${ZSH_VERSION+.}$(PATH_SEPARATOR)" && cd
+install_sh_DATA = $(install_sh) -c -m 644
+install_sh_PROGRAM = $(install_sh) -c
+install_sh_SCRIPT = $(install_sh) -c
+INSTALL_HEADER = $(INSTALL_DATA)
+transform = $(program_transform_name)
+NORMAL_INSTALL = :
+PRE_INSTALL = :
+POST_INSTALL = :
+NORMAL_UNINSTALL = :
+PRE_UNINSTALL = :
+POST_UNINSTALL = :
+build_triplet = @build@
+host_triplet = @host@
+target_triplet = @target@
+@BUILD_DOCS_TRUE@am__append_1 = doc
+@FFI_DEBUG_TRUE@am__append_2 = src/debug.c
+# Build debug. Define FFI_DEBUG on the commandline so that, when building with
+# MSVC, it can link against the debug CRT.
+@FFI_DEBUG_TRUE@am__append_3 = -DFFI_DEBUG
+subdir = .
+ACLOCAL_M4 = $(top_srcdir)/aclocal.m4
+am__aclocal_m4_deps = $(top_srcdir)/m4/asmcfi.m4 \
+	$(top_srcdir)/m4/ax_append_flag.m4 \
+	$(top_srcdir)/m4/ax_cc_maxopt.m4 \
+	$(top_srcdir)/m4/ax_cflags_warn_all.m4 \
+	$(top_srcdir)/m4/ax_check_compile_flag.m4 \
+	$(top_srcdir)/m4/ax_compiler_vendor.m4 \
+	$(top_srcdir)/m4/ax_configure_args.m4 \
+	$(top_srcdir)/m4/ax_enable_builddir.m4 \
+	$(top_srcdir)/m4/ax_gcc_archflag.m4 \
+	$(top_srcdir)/m4/ax_gcc_x86_cpuid.m4 \
+	$(top_srcdir)/m4/ax_require_defined.m4 \
+	$(top_srcdir)/m4/libtool.m4 $(top_srcdir)/m4/ltoptions.m4 \
+	$(top_srcdir)/m4/ltsugar.m4 $(top_srcdir)/m4/ltversion.m4 \
+	$(top_srcdir)/m4/lt~obsolete.m4 $(top_srcdir)/acinclude.m4 \
+	$(top_srcdir)/configure.ac
+am__configure_deps = $(am__aclocal_m4_deps) $(CONFIGURE_DEPENDENCIES) \
+	$(ACLOCAL_M4)
+DIST_COMMON = $(srcdir)/Makefile.am $(top_srcdir)/configure \
+	$(am__configure_deps) $(noinst_HEADERS) $(am__DIST_COMMON)
+am__CONFIG_DISTCLEAN_FILES = config.status config.cache config.log \
+ configure.lineno config.status.lineno
+mkinstalldirs = $(install_sh) -d
+CONFIG_HEADER = fficonfig.h
+CONFIG_CLEAN_FILES = libffi.pc
+CONFIG_CLEAN_VPATH_FILES =
+am__vpath_adj_setup = srcdirstrip=`echo "$(srcdir)" | sed 's|.|.|g'`;
+am__vpath_adj = case $$p in \
+    $(srcdir)/*) f=`echo "$$p" | sed "s|^$$srcdirstrip/||"`;; \
+    *) f=$$p;; \
+  esac;
+am__strip_dir = f=`echo $$p | sed -e 's|^.*/||'`;
+am__install_max = 40
+am__nobase_strip_setup = \
+  srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*|]/\\\\&/g'`
+am__nobase_strip = \
+  for p in $$list; do echo "$$p"; done | sed -e "s|$$srcdirstrip/||"
+am__nobase_list = $(am__nobase_strip_setup); \
+  for p in $$list; do echo "$$p $$p"; done | \
+  sed "s| $$srcdirstrip/| |;"' / .*\//!s/ .*/ ./; s,\( .*\)/[^/]*$$,\1,' | \
+  $(AWK) 'BEGIN { files["."] = "" } { files[$$2] = files[$$2] " " $$1; \
+    if (++n[$$2] == $(am__install_max)) \
+      { print $$2, files[$$2]; n[$$2] = 0; files[$$2] = "" } } \
+    END { for (dir in files) print dir, files[dir] }'
+am__base_list = \
+  sed '$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;$$!N;s/\n/ /g' | \
+  sed '$$!N;$$!N;$$!N;$$!N;s/\n/ /g'
+am__uninstall_files_from_dir = { \
+  test -z "$$files" \
+    || { test ! -d "$$dir" && test ! -f "$$dir" && test ! -r "$$dir"; } \
+    || { echo " ( cd '$$dir' && rm -f" $$files ")"; \
+         $(am__cd) "$$dir" && rm -f $$files; }; \
+  }
+am__installdirs = "$(DESTDIR)$(toolexeclibdir)" \
+	"$(DESTDIR)$(pkgconfigdir)"
+LTLIBRARIES = $(noinst_LTLIBRARIES) $(toolexeclib_LTLIBRARIES)
+am__DEPENDENCIES_1 =
+am__libffi_la_SOURCES_DIST = src/prep_cif.c src/types.c src/raw_api.c \
+	src/java_raw_api.c src/closures.c src/tramp.c src/debug.c
+am__dirstamp = $(am__leading_dot)dirstamp
+@FFI_DEBUG_TRUE@am__objects_1 = src/debug.lo
+am_libffi_la_OBJECTS = src/prep_cif.lo src/types.lo src/raw_api.lo \
+	src/java_raw_api.lo src/closures.lo src/tramp.lo \
+	$(am__objects_1)
+libffi_la_OBJECTS = $(am_libffi_la_OBJECTS)
+AM_V_lt = $(am__v_lt_@AM_V@)
+am__v_lt_ = $(am__v_lt_@AM_DEFAULT_V@)
+am__v_lt_0 = --silent
+am__v_lt_1 = 
+libffi_la_LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(libffi_la_LDFLAGS) $(LDFLAGS) -o $@
+am__DEPENDENCIES_2 = $(am__DEPENDENCIES_1)
+am__libffi_convenience_la_SOURCES_DIST = src/prep_cif.c src/types.c \
+	src/raw_api.c src/java_raw_api.c src/closures.c src/tramp.c \
+	src/debug.c
+am__objects_2 = src/prep_cif.lo src/types.lo src/raw_api.lo \
+	src/java_raw_api.lo src/closures.lo src/tramp.lo \
+	$(am__objects_1)
+am_libffi_convenience_la_OBJECTS = $(am__objects_2)
+nodist_libffi_convenience_la_OBJECTS =
+libffi_convenience_la_OBJECTS = $(am_libffi_convenience_la_OBJECTS) \
+	$(nodist_libffi_convenience_la_OBJECTS)
+AM_V_P = $(am__v_P_@AM_V@)
+am__v_P_ = $(am__v_P_@AM_DEFAULT_V@)
+am__v_P_0 = false
+am__v_P_1 = :
+AM_V_GEN = $(am__v_GEN_@AM_V@)
+am__v_GEN_ = $(am__v_GEN_@AM_DEFAULT_V@)
+am__v_GEN_0 = @echo "  GEN     " $@;
+am__v_GEN_1 = 
+AM_V_at = $(am__v_at_@AM_V@)
+am__v_at_ = $(am__v_at_@AM_DEFAULT_V@)
+am__v_at_0 = @
+am__v_at_1 = 
+DEFAULT_INCLUDES = -I.@am__isrc@
+depcomp = $(SHELL) $(top_srcdir)/depcomp
+am__maybe_remake_depfiles = depfiles
+am__depfiles_remade = src/$(DEPDIR)/closures.Plo \
+	src/$(DEPDIR)/debug.Plo src/$(DEPDIR)/java_raw_api.Plo \
+	src/$(DEPDIR)/prep_cif.Plo src/$(DEPDIR)/raw_api.Plo \
+	src/$(DEPDIR)/tramp.Plo src/$(DEPDIR)/types.Plo \
+	src/aarch64/$(DEPDIR)/ffi.Plo src/aarch64/$(DEPDIR)/sysv.Plo \
+	src/aarch64/$(DEPDIR)/win64_armasm.Plo \
+	src/alpha/$(DEPDIR)/ffi.Plo src/alpha/$(DEPDIR)/osf.Plo \
+	src/arc/$(DEPDIR)/arcompact.Plo src/arc/$(DEPDIR)/ffi.Plo \
+	src/arm/$(DEPDIR)/ffi.Plo src/arm/$(DEPDIR)/sysv.Plo \
+	src/arm/$(DEPDIR)/sysv_msvc_arm32.Plo \
+	src/avr32/$(DEPDIR)/ffi.Plo src/avr32/$(DEPDIR)/sysv.Plo \
+	src/bfin/$(DEPDIR)/ffi.Plo src/bfin/$(DEPDIR)/sysv.Plo \
+	src/cris/$(DEPDIR)/ffi.Plo src/cris/$(DEPDIR)/sysv.Plo \
+	src/csky/$(DEPDIR)/ffi.Plo src/csky/$(DEPDIR)/sysv.Plo \
+	src/frv/$(DEPDIR)/eabi.Plo src/frv/$(DEPDIR)/ffi.Plo \
+	src/ia64/$(DEPDIR)/ffi.Plo src/ia64/$(DEPDIR)/unix.Plo \
+	src/kvx/$(DEPDIR)/ffi.Plo src/kvx/$(DEPDIR)/sysv.Plo \
+	src/m32r/$(DEPDIR)/ffi.Plo src/m32r/$(DEPDIR)/sysv.Plo \
+	src/m68k/$(DEPDIR)/ffi.Plo src/m68k/$(DEPDIR)/sysv.Plo \
+	src/m88k/$(DEPDIR)/ffi.Plo src/m88k/$(DEPDIR)/obsd.Plo \
+	src/metag/$(DEPDIR)/ffi.Plo src/metag/$(DEPDIR)/sysv.Plo \
+	src/microblaze/$(DEPDIR)/ffi.Plo \
+	src/microblaze/$(DEPDIR)/sysv.Plo src/mips/$(DEPDIR)/ffi.Plo \
+	src/mips/$(DEPDIR)/n32.Plo src/mips/$(DEPDIR)/o32.Plo \
+	src/moxie/$(DEPDIR)/eabi.Plo src/moxie/$(DEPDIR)/ffi.Plo \
+	src/nios2/$(DEPDIR)/ffi.Plo src/nios2/$(DEPDIR)/sysv.Plo \
+	src/or1k/$(DEPDIR)/ffi.Plo src/or1k/$(DEPDIR)/sysv.Plo \
+	src/pa/$(DEPDIR)/ffi.Plo src/pa/$(DEPDIR)/hpux32.Plo \
+	src/pa/$(DEPDIR)/linux.Plo src/powerpc/$(DEPDIR)/aix.Plo \
+	src/powerpc/$(DEPDIR)/aix_closure.Plo \
+	src/powerpc/$(DEPDIR)/darwin.Plo \
+	src/powerpc/$(DEPDIR)/darwin_closure.Plo \
+	src/powerpc/$(DEPDIR)/ffi.Plo \
+	src/powerpc/$(DEPDIR)/ffi_darwin.Plo \
+	src/powerpc/$(DEPDIR)/ffi_linux64.Plo \
+	src/powerpc/$(DEPDIR)/ffi_sysv.Plo \
+	src/powerpc/$(DEPDIR)/linux64.Plo \
+	src/powerpc/$(DEPDIR)/linux64_closure.Plo \
+	src/powerpc/$(DEPDIR)/ppc_closure.Plo \
+	src/powerpc/$(DEPDIR)/sysv.Plo src/riscv/$(DEPDIR)/ffi.Plo \
+	src/riscv/$(DEPDIR)/sysv.Plo src/s390/$(DEPDIR)/ffi.Plo \
+	src/s390/$(DEPDIR)/sysv.Plo src/sh/$(DEPDIR)/ffi.Plo \
+	src/sh/$(DEPDIR)/sysv.Plo src/sh64/$(DEPDIR)/ffi.Plo \
+	src/sh64/$(DEPDIR)/sysv.Plo src/sparc/$(DEPDIR)/ffi.Plo \
+	src/sparc/$(DEPDIR)/ffi64.Plo src/sparc/$(DEPDIR)/v8.Plo \
+	src/sparc/$(DEPDIR)/v9.Plo src/tile/$(DEPDIR)/ffi.Plo \
+	src/tile/$(DEPDIR)/tile.Plo src/vax/$(DEPDIR)/elfbsd.Plo \
+	src/vax/$(DEPDIR)/ffi.Plo src/x86/$(DEPDIR)/ffi.Plo \
+	src/x86/$(DEPDIR)/ffi64.Plo src/x86/$(DEPDIR)/ffiw64.Plo \
+	src/x86/$(DEPDIR)/sysv.Plo src/x86/$(DEPDIR)/sysv_intel.Plo \
+	src/x86/$(DEPDIR)/unix64.Plo src/x86/$(DEPDIR)/win64.Plo \
+	src/x86/$(DEPDIR)/win64_intel.Plo src/xtensa/$(DEPDIR)/ffi.Plo \
+	src/xtensa/$(DEPDIR)/sysv.Plo
+am__mv = mv -f
+CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \
+	$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)
+LTCPPASCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CCAS) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CCASFLAGS) $(CCASFLAGS)
+AM_V_CPPAS = $(am__v_CPPAS_@AM_V@)
+am__v_CPPAS_ = $(am__v_CPPAS_@AM_DEFAULT_V@)
+am__v_CPPAS_0 = @echo "  CPPAS   " $@;
+am__v_CPPAS_1 = 
+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \
+	$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)
+LTCOMPILE = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) \
+	$(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) \
+	$(AM_CFLAGS) $(CFLAGS)
+AM_V_CC = $(am__v_CC_@AM_V@)
+am__v_CC_ = $(am__v_CC_@AM_DEFAULT_V@)
+am__v_CC_0 = @echo "  CC      " $@;
+am__v_CC_1 = 
+CCLD = $(CC)
+LINK = $(LIBTOOL) $(AM_V_lt) --tag=CC $(AM_LIBTOOLFLAGS) \
+	$(LIBTOOLFLAGS) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) \
+	$(AM_LDFLAGS) $(LDFLAGS) -o $@
+AM_V_CCLD = $(am__v_CCLD_@AM_V@)
+am__v_CCLD_ = $(am__v_CCLD_@AM_DEFAULT_V@)
+am__v_CCLD_0 = @echo "  CCLD    " $@;
+am__v_CCLD_1 = 
+SOURCES = $(libffi_la_SOURCES) $(EXTRA_libffi_la_SOURCES) \
+	$(libffi_convenience_la_SOURCES) \
+	$(EXTRA_libffi_convenience_la_SOURCES) \
+	$(nodist_libffi_convenience_la_SOURCES)
+DIST_SOURCES = $(am__libffi_la_SOURCES_DIST) \
+	$(EXTRA_libffi_la_SOURCES) \
+	$(am__libffi_convenience_la_SOURCES_DIST) \
+	$(EXTRA_libffi_convenience_la_SOURCES)
+RECURSIVE_TARGETS = all-recursive check-recursive cscopelist-recursive \
+	ctags-recursive dvi-recursive html-recursive info-recursive \
+	install-data-recursive install-dvi-recursive \
+	install-exec-recursive install-html-recursive \
+	install-info-recursive install-pdf-recursive \
+	install-ps-recursive install-recursive installcheck-recursive \
+	installdirs-recursive pdf-recursive ps-recursive \
+	tags-recursive uninstall-recursive
+am__can_run_installinfo = \
+  case $$AM_UPDATE_INFO_DIR in \
+    n|no|NO) false;; \
+    *) (install-info --version) >/dev/null 2>&1;; \
+  esac
+DATA = $(pkgconfig_DATA)
+HEADERS = $(noinst_HEADERS)
+RECURSIVE_CLEAN_TARGETS = mostlyclean-recursive clean-recursive	\
+  distclean-recursive maintainer-clean-recursive
+am__recursive_targets = \
+  $(RECURSIVE_TARGETS) \
+  $(RECURSIVE_CLEAN_TARGETS) \
+  $(am__extra_recursive_targets)
+AM_RECURSIVE_TARGETS = $(am__recursive_targets:-recursive=) TAGS CTAGS \
+	cscope distdir distdir-am dist dist-all distcheck
+am__tagged_files = $(HEADERS) $(SOURCES) $(TAGS_FILES) $(LISP) \
+	fficonfig.h.in
+# Read a list of newline-separated strings from the standard input,
+# and print each of them once, without duplicates.  Input order is
+# *not* preserved.
+am__uniquify_input = $(AWK) '\
+  BEGIN { nonempty = 0; } \
+  { items[$$0] = 1; nonempty = 1; } \
+  END { if (nonempty) { for (i in items) print i; }; } \
+'
+# Make sure the list of sources is unique.  This is necessary because,
+# e.g., the same source file might be shared among _SOURCES variables
+# for different programs/libraries.
+am__define_uniq_tagged_files = \
+  list='$(am__tagged_files)'; \
+  unique=`for i in $$list; do \
+    if test -f "$$i"; then echo $$i; else echo $(srcdir)/$$i; fi; \
+  done | $(am__uniquify_input)`
+ETAGS = etags
+CTAGS = ctags
+CSCOPE = cscope
+DIST_SUBDIRS = include testsuite man doc
+am__DIST_COMMON = $(srcdir)/Makefile.in $(srcdir)/fficonfig.h.in \
+	$(srcdir)/libffi.pc.in ChangeLog compile config.guess \
+	config.sub depcomp install-sh ltmain.sh missing
+DISTFILES = $(DIST_COMMON) $(DIST_SOURCES) $(TEXINFOS) $(EXTRA_DIST)
+distdir = $(PACKAGE)-$(VERSION)
+top_distdir = $(distdir)
+am__remove_distdir = \
+  if test -d "$(distdir)"; then \
+    find "$(distdir)" -type d ! -perm -200 -exec chmod u+w {} ';' \
+      && rm -rf "$(distdir)" \
+      || { sleep 5 && rm -rf "$(distdir)"; }; \
+  else :; fi
+am__post_remove_distdir = $(am__remove_distdir)
+am__relativize = \
+  dir0=`pwd`; \
+  sed_first='s,^\([^/]*\)/.*$$,\1,'; \
+  sed_rest='s,^[^/]*/*,,'; \
+  sed_last='s,^.*/\([^/]*\)$$,\1,'; \
+  sed_butlast='s,/*[^/]*$$,,'; \
+  while test -n "$$dir1"; do \
+    first=`echo "$$dir1" | sed -e "$$sed_first"`; \
+    if test "$$first" != "."; then \
+      if test "$$first" = ".."; then \
+        dir2=`echo "$$dir0" | sed -e "$$sed_last"`/"$$dir2"; \
+        dir0=`echo "$$dir0" | sed -e "$$sed_butlast"`; \
+      else \
+        first2=`echo "$$dir2" | sed -e "$$sed_first"`; \
+        if test "$$first2" = "$$first"; then \
+          dir2=`echo "$$dir2" | sed -e "$$sed_rest"`; \
+        else \
+          dir2="../$$dir2"; \
+        fi; \
+        dir0="$$dir0"/"$$first"; \
+      fi; \
+    fi; \
+    dir1=`echo "$$dir1" | sed -e "$$sed_rest"`; \
+  done; \
+  reldir="$$dir2"
+DIST_ARCHIVES = $(distdir).tar.gz
+GZIP_ENV = --best
+DIST_TARGETS = dist-gzip
+distuninstallcheck_listfiles = find . -type f -print
+am__distuninstallcheck_listfiles = $(distuninstallcheck_listfiles) \
+  | sed 's|^\./|$(prefix)/|' | grep -v '$(infodir)/dir$$'
+distcleancheck_listfiles = find . -type f -print
+ACLOCAL = @ACLOCAL@
+ALLOCA = @ALLOCA@
+AMTAR = @AMTAR@
+AM_DEFAULT_VERBOSITY = @AM_DEFAULT_VERBOSITY@
+AM_LTLDFLAGS = @AM_LTLDFLAGS@
+AM_RUNTESTFLAGS = @AM_RUNTESTFLAGS@
+AR = @AR@
+AUTOCONF = @AUTOCONF@
+AUTOHEADER = @AUTOHEADER@
+AUTOMAKE = @AUTOMAKE@
+AWK = @AWK@
+CC = @CC@
+CCAS = @CCAS@
+CCASDEPMODE = @CCASDEPMODE@
+CCASFLAGS = @CCASFLAGS@
+CCDEPMODE = @CCDEPMODE@
+CFLAGS = @CFLAGS@
+CPP = @CPP@
+CPPFLAGS = @CPPFLAGS@
+CXX = @CXX@
+CXXCPP = @CXXCPP@
+CXXDEPMODE = @CXXDEPMODE@
+CXXFLAGS = @CXXFLAGS@
+CYGPATH_W = @CYGPATH_W@
+DEFS = @DEFS@
+DEPDIR = @DEPDIR@
+DLLTOOL = @DLLTOOL@
+DSYMUTIL = @DSYMUTIL@
+DUMPBIN = @DUMPBIN@
+ECHO_C = @ECHO_C@
+ECHO_N = @ECHO_N@
+ECHO_T = @ECHO_T@
+EGREP = @EGREP@
+EXEEXT = @EXEEXT@
+FFI_EXEC_TRAMPOLINE_TABLE = @FFI_EXEC_TRAMPOLINE_TABLE@
+FGREP = @FGREP@
+GREP = @GREP@
+HAVE_LONG_DOUBLE = @HAVE_LONG_DOUBLE@
+HAVE_LONG_DOUBLE_VARIANT = @HAVE_LONG_DOUBLE_VARIANT@
+INSTALL = @INSTALL@
+INSTALL_DATA = @INSTALL_DATA@
+INSTALL_PROGRAM = @INSTALL_PROGRAM@
+INSTALL_SCRIPT = @INSTALL_SCRIPT@
+INSTALL_STRIP_PROGRAM = @INSTALL_STRIP_PROGRAM@
+LD = @LD@
+LDFLAGS = @LDFLAGS@
+LIBOBJS = @LIBOBJS@
+LIBS = @LIBS@
+LIBTOOL = @LIBTOOL@
+LIPO = @LIPO@
+LN_S = @LN_S@
+LTLIBOBJS = @LTLIBOBJS@
+LT_SYS_LIBRARY_PATH = @LT_SYS_LIBRARY_PATH@
+MAINT = @MAINT@
+MAKEINFO = @MAKEINFO@
+MANIFEST_TOOL = @MANIFEST_TOOL@
+MKDIR_P = @MKDIR_P@
+NM = @NM@
+NMEDIT = @NMEDIT@
+OBJDUMP = @OBJDUMP@
+OBJEXT = @OBJEXT@
+OPT_LDFLAGS = @OPT_LDFLAGS@
+OTOOL = @OTOOL@
+OTOOL64 = @OTOOL64@
+PACKAGE = @PACKAGE@
+PACKAGE_BUGREPORT = @PACKAGE_BUGREPORT@
+PACKAGE_NAME = @PACKAGE_NAME@
+PACKAGE_STRING = @PACKAGE_STRING@
+PACKAGE_TARNAME = @PACKAGE_TARNAME@
+PACKAGE_URL = @PACKAGE_URL@
+PACKAGE_VERSION = @PACKAGE_VERSION@
+PATH_SEPARATOR = @PATH_SEPARATOR@
+PRTDIAG = @PRTDIAG@
+RANLIB = @RANLIB@
+READELF = @READELF@
+SECTION_LDFLAGS = @SECTION_LDFLAGS@
+SED = @SED@
+SET_MAKE = @SET_MAKE@
+SHELL = @SHELL@
+STRIP = @STRIP@
+TARGET = @TARGET@
+TARGETDIR = @TARGETDIR@
+TARGET_OBJ = @TARGET_OBJ@
+VERSION = @VERSION@
+abs_builddir = @abs_builddir@
+abs_srcdir = @abs_srcdir@
+abs_top_builddir = @abs_top_builddir@
+abs_top_srcdir = @abs_top_srcdir@
+ac_ct_AR = @ac_ct_AR@
+ac_ct_CC = @ac_ct_CC@
+ac_ct_CXX = @ac_ct_CXX@
+ac_ct_DUMPBIN = @ac_ct_DUMPBIN@
+am__include = @am__include@
+am__leading_dot = @am__leading_dot@
+am__quote = @am__quote@
+am__tar = @am__tar@
+am__untar = @am__untar@
+ax_enable_builddir_sed = @ax_enable_builddir_sed@
+bindir = @bindir@
+build = @build@
+build_alias = @build_alias@
+build_cpu = @build_cpu@
+build_os = @build_os@
+build_vendor = @build_vendor@
+builddir = @builddir@
+datadir = @datadir@
+datarootdir = @datarootdir@
+docdir = @docdir@
+dvidir = @dvidir@
+exec_prefix = @exec_prefix@
+host = @host@
+host_alias = @host_alias@
+host_cpu = @host_cpu@
+host_os = @host_os@
+host_vendor = @host_vendor@
+htmldir = @htmldir@
+includedir = @includedir@
+infodir = @infodir@
+install_sh = @install_sh@
+libdir = @libdir@
+libexecdir = @libexecdir@
+localedir = @localedir@
+localstatedir = @localstatedir@
+mandir = @mandir@
+mkdir_p = @mkdir_p@
+oldincludedir = @oldincludedir@
+pdfdir = @pdfdir@
+prefix = @prefix@
+program_transform_name = @program_transform_name@
+psdir = @psdir@
+runstatedir = @runstatedir@
+sbindir = @sbindir@
+sharedstatedir = @sharedstatedir@
+srcdir = @srcdir@
+sys_symbol_underscore = @sys_symbol_underscore@
+sysconfdir = @sysconfdir@
+target = @target@
+target_alias = @target_alias@
+target_cpu = @target_cpu@
+target_os = @target_os@
+target_vendor = @target_vendor@
+toolexecdir = @toolexecdir@
+toolexeclibdir = @toolexeclibdir@
+top_build_prefix = @top_build_prefix@
+top_builddir = @top_builddir@
+top_srcdir = @top_srcdir@
+AUTOMAKE_OPTIONS = foreign subdir-objects
+ACLOCAL_AMFLAGS = -I m4
+SUBDIRS = include testsuite man $(am__append_1)
+EXTRA_DIST = LICENSE ChangeLog.old					\
+	m4/libtool.m4 m4/lt~obsolete.m4					\
+	 m4/ltoptions.m4 m4/ltsugar.m4 m4/ltversion.m4			\
+	 m4/ltversion.m4 src/debug.c msvcc.sh				\
+	generate-darwin-source-and-headers.py				\
+	libffi.xcodeproj/project.pbxproj				\
+	libtool-ldflags libtool-version configure.host README.md        \
+	libffi.map.in LICENSE-BUILDTOOLS msvc_build make_sunver.pl	
+
+
+# local.exp is generated by configure
+DISTCLEANFILES = local.exp
+
+# Subdir rules rely on $(FLAGS_TO_PASS)
+FLAGS_TO_PASS = $(AM_MAKEFLAGS)
+MAKEOVERRIDES = 
+pkgconfigdir = $(libdir)/pkgconfig
+pkgconfig_DATA = libffi.pc
+toolexeclib_LTLIBRARIES = libffi.la
+noinst_LTLIBRARIES = libffi_convenience.la
+libffi_la_SOURCES = src/prep_cif.c src/types.c src/raw_api.c \
+	src/java_raw_api.c src/closures.c src/tramp.c $(am__append_2)
+noinst_HEADERS = src/aarch64/ffitarget.h src/aarch64/internal.h		\
+	src/alpha/ffitarget.h src/alpha/internal.h			\
+	src/arc/ffitarget.h src/arm/ffitarget.h src/arm/internal.h	\
+	src/avr32/ffitarget.h src/bfin/ffitarget.h			\
+	src/cris/ffitarget.h src/csky/ffitarget.h src/frv/ffitarget.h	\
+	src/ia64/ffitarget.h src/ia64/ia64_flags.h			\
+	src/m32r/ffitarget.h src/m68k/ffitarget.h			\
+	src/m88k/ffitarget.h src/metag/ffitarget.h			\
+	src/microblaze/ffitarget.h src/mips/ffitarget.h			\
+	src/moxie/ffitarget.h src/nios2/ffitarget.h			\
+	src/or1k/ffitarget.h src/pa/ffitarget.h				\
+	src/powerpc/ffitarget.h src/powerpc/asm.h			\
+	src/powerpc/ffi_powerpc.h src/riscv/ffitarget.h			\
+	src/s390/ffitarget.h src/s390/internal.h src/sh/ffitarget.h	\
+	src/sh64/ffitarget.h src/sparc/ffitarget.h			\
+	src/sparc/internal.h src/tile/ffitarget.h src/vax/ffitarget.h	\
+	src/x86/ffitarget.h src/x86/internal.h src/x86/internal64.h	\
+	src/x86/asmnames.h src/xtensa/ffitarget.h src/dlmalloc.c	\
+	src/kvx/ffitarget.h
+
+EXTRA_libffi_la_SOURCES = src/aarch64/ffi.c src/aarch64/sysv.S		\
+	src/aarch64/win64_armasm.S src/alpha/ffi.c src/alpha/osf.S	\
+	src/arc/ffi.c src/arc/arcompact.S src/arm/ffi.c			\
+	src/arm/sysv.S src/arm/ffi.c src/arm/sysv_msvc_arm32.S		\
+	src/avr32/ffi.c src/avr32/sysv.S src/bfin/ffi.c			\
+	src/bfin/sysv.S src/cris/ffi.c src/cris/sysv.S src/frv/ffi.c	\
+	src/csky/ffi.c src/csky/sysv.S src/frv/eabi.S src/ia64/ffi.c	\
+	src/ia64/unix.S src/m32r/ffi.c src/m32r/sysv.S src/m68k/ffi.c	\
+	src/m68k/sysv.S src/m88k/ffi.c src/m88k/obsd.S			\
+	src/metag/ffi.c src/metag/sysv.S src/microblaze/ffi.c		\
+	src/microblaze/sysv.S src/mips/ffi.c src/mips/o32.S		\
+	src/mips/n32.S src/moxie/ffi.c src/moxie/eabi.S			\
+	src/nios2/ffi.c src/nios2/sysv.S src/or1k/ffi.c			\
+	src/or1k/sysv.S src/pa/ffi.c src/pa/linux.S src/pa/hpux32.S	\
+	src/powerpc/ffi.c src/powerpc/ffi_sysv.c			\
+	src/powerpc/ffi_linux64.c src/powerpc/sysv.S			\
+	src/powerpc/linux64.S src/powerpc/linux64_closure.S		\
+	src/powerpc/ppc_closure.S src/powerpc/aix.S			\
+	src/powerpc/darwin.S src/powerpc/aix_closure.S			\
+	src/powerpc/darwin_closure.S src/powerpc/ffi_darwin.c		\
+	src/riscv/ffi.c src/riscv/sysv.S src/s390/ffi.c			\
+	src/s390/sysv.S src/sh/ffi.c src/sh/sysv.S src/sh64/ffi.c	\
+	src/sh64/sysv.S src/sparc/ffi.c src/sparc/ffi64.c		\
+	src/sparc/v8.S src/sparc/v9.S src/tile/ffi.c src/tile/tile.S	\
+	src/vax/ffi.c src/vax/elfbsd.S src/x86/ffi.c src/x86/sysv.S	\
+	src/x86/ffiw64.c src/x86/win64.S src/x86/ffi64.c		\
+	src/x86/unix64.S src/x86/sysv_intel.S src/x86/win64_intel.S	\
+	src/xtensa/ffi.c src/xtensa/sysv.S src/kvx/ffi.c		\
+	src/kvx/sysv.S
+
+libffi_la_LIBADD = $(TARGET_OBJ)
+libffi_convenience_la_SOURCES = $(libffi_la_SOURCES)
+EXTRA_libffi_convenience_la_SOURCES = $(EXTRA_libffi_la_SOURCES)
+libffi_convenience_la_LIBADD = $(libffi_la_LIBADD)
+libffi_convenience_la_DEPENDENCIES = $(libffi_la_DEPENDENCIES)
+nodist_libffi_convenience_la_SOURCES = $(nodist_libffi_la_SOURCES)
+LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/libtool-ldflags $(LDFLAGS))
+AM_CFLAGS = $(am__append_3)
+@LIBFFI_BUILD_VERSIONED_SHLIB_FALSE@libffi_version_script = 
+@LIBFFI_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_script = -Wl,--version-script,libffi.map
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_script = -Wl,-M,libffi.map-sun
+@LIBFFI_BUILD_VERSIONED_SHLIB_FALSE@libffi_version_dep = 
+@LIBFFI_BUILD_VERSIONED_SHLIB_GNU_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_dep = libffi.map
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@libffi_version_dep = libffi.map-sun
+libffi_version_info = -version-info `grep -v '^\#' $(srcdir)/libtool-version`
+libffi_la_LDFLAGS = -no-undefined $(libffi_version_info) $(libffi_version_script) $(LTLDFLAGS) $(AM_LTLDFLAGS)
+libffi_la_DEPENDENCIES = $(libffi_la_LIBADD) $(libffi_version_dep)
+AM_CPPFLAGS = -I. -I$(top_srcdir)/include -Iinclude -I$(top_srcdir)/src
+AM_CCASFLAGS = $(AM_CPPFLAGS)
+all: fficonfig.h
+	$(MAKE) $(AM_MAKEFLAGS) all-recursive
+
+.SUFFIXES:
+.SUFFIXES: .S .c .lo .o .obj
+am--refresh: Makefile
+	@:
+$(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)
+	@for dep in $?; do \
+	  case '$(am__configure_deps)' in \
+	    *$$dep*) \
+	      echo ' cd $(srcdir) && $(AUTOMAKE) --foreign'; \
+	      $(am__cd) $(srcdir) && $(AUTOMAKE) --foreign \
+		&& exit 0; \
+	      exit 1;; \
+	  esac; \
+	done; \
+	echo ' cd $(top_srcdir) && $(AUTOMAKE) --foreign Makefile'; \
+	$(am__cd) $(top_srcdir) && \
+	  $(AUTOMAKE) --foreign Makefile
+Makefile: $(srcdir)/Makefile.in $(top_builddir)/config.status
+	@case '$?' in \
+	  *config.status*) \
+	    echo ' $(SHELL) ./config.status'; \
+	    $(SHELL) ./config.status;; \
+	  *) \
+	    echo ' cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles)'; \
+	    cd $(top_builddir) && $(SHELL) ./config.status $@ $(am__maybe_remake_depfiles);; \
+	esac;
+
+$(top_builddir)/config.status: $(top_srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)
+	$(SHELL) ./config.status --recheck
+
+$(top_srcdir)/configure: @MAINTAINER_MODE_TRUE@ $(am__configure_deps)
+	$(am__cd) $(srcdir) && $(AUTOCONF)
+$(ACLOCAL_M4): @MAINTAINER_MODE_TRUE@ $(am__aclocal_m4_deps)
+	$(am__cd) $(srcdir) && $(ACLOCAL) $(ACLOCAL_AMFLAGS)
+$(am__aclocal_m4_deps):
+
+fficonfig.h: stamp-h1
+	@test -f $@ || rm -f stamp-h1
+	@test -f $@ || $(MAKE) $(AM_MAKEFLAGS) stamp-h1
+
+stamp-h1: $(srcdir)/fficonfig.h.in $(top_builddir)/config.status
+	@rm -f stamp-h1
+	cd $(top_builddir) && $(SHELL) ./config.status fficonfig.h
+$(srcdir)/fficonfig.h.in: @MAINTAINER_MODE_TRUE@ $(am__configure_deps) 
+	($(am__cd) $(top_srcdir) && $(AUTOHEADER))
+	rm -f stamp-h1
+	touch $@
+
+distclean-hdr:
+	-rm -f fficonfig.h stamp-h1
+libffi.pc: $(top_builddir)/config.status $(srcdir)/libffi.pc.in
+	cd $(top_builddir) && $(SHELL) ./config.status $@
+
+clean-noinstLTLIBRARIES:
+	-test -z "$(noinst_LTLIBRARIES)" || rm -f $(noinst_LTLIBRARIES)
+	@list='$(noinst_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+
+install-toolexeclibLTLIBRARIES: $(toolexeclib_LTLIBRARIES)
+	@$(NORMAL_INSTALL)
+	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
+	list2=; for p in $$list; do \
+	  if test -f $$p; then \
+	    list2="$$list2 $$p"; \
+	  else :; fi; \
+	done; \
+	test -z "$$list2" || { \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(toolexeclibdir)" || exit 1; \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 '$(DESTDIR)$(toolexeclibdir)'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=install $(INSTALL) $(INSTALL_STRIP_FLAG) $$list2 "$(DESTDIR)$(toolexeclibdir)"; \
+	}
+
+uninstall-toolexeclibLTLIBRARIES:
+	@$(NORMAL_UNINSTALL)
+	@list='$(toolexeclib_LTLIBRARIES)'; test -n "$(toolexeclibdir)" || list=; \
+	for p in $$list; do \
+	  $(am__strip_dir) \
+	  echo " $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f '$(DESTDIR)$(toolexeclibdir)/$$f'"; \
+	  $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=uninstall rm -f "$(DESTDIR)$(toolexeclibdir)/$$f"; \
+	done
+
+clean-toolexeclibLTLIBRARIES:
+	-test -z "$(toolexeclib_LTLIBRARIES)" || rm -f $(toolexeclib_LTLIBRARIES)
+	@list='$(toolexeclib_LTLIBRARIES)'; \
+	locs=`for p in $$list; do echo $$p; done | \
+	      sed 's|^[^/]*$$|.|; s|/[^/]*$$||; s|$$|/so_locations|' | \
+	      sort -u`; \
+	test -z "$$locs" || { \
+	  echo rm -f $${locs}; \
+	  rm -f $${locs}; \
+	}
+src/$(am__dirstamp):
+	@$(MKDIR_P) src
+	@: > src/$(am__dirstamp)
+src/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/$(DEPDIR)
+	@: > src/$(DEPDIR)/$(am__dirstamp)
+src/prep_cif.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/types.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/java_raw_api.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/closures.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/tramp.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/debug.lo: src/$(am__dirstamp) src/$(DEPDIR)/$(am__dirstamp)
+src/aarch64/$(am__dirstamp):
+	@$(MKDIR_P) src/aarch64
+	@: > src/aarch64/$(am__dirstamp)
+src/aarch64/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/aarch64/$(DEPDIR)
+	@: > src/aarch64/$(DEPDIR)/$(am__dirstamp)
+src/aarch64/ffi.lo: src/aarch64/$(am__dirstamp) \
+	src/aarch64/$(DEPDIR)/$(am__dirstamp)
+src/aarch64/sysv.lo: src/aarch64/$(am__dirstamp) \
+	src/aarch64/$(DEPDIR)/$(am__dirstamp)
+src/aarch64/win64_armasm.lo: src/aarch64/$(am__dirstamp) \
+	src/aarch64/$(DEPDIR)/$(am__dirstamp)
+src/alpha/$(am__dirstamp):
+	@$(MKDIR_P) src/alpha
+	@: > src/alpha/$(am__dirstamp)
+src/alpha/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/alpha/$(DEPDIR)
+	@: > src/alpha/$(DEPDIR)/$(am__dirstamp)
+src/alpha/ffi.lo: src/alpha/$(am__dirstamp) \
+	src/alpha/$(DEPDIR)/$(am__dirstamp)
+src/alpha/osf.lo: src/alpha/$(am__dirstamp) \
+	src/alpha/$(DEPDIR)/$(am__dirstamp)
+src/arc/$(am__dirstamp):
+	@$(MKDIR_P) src/arc
+	@: > src/arc/$(am__dirstamp)
+src/arc/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/arc/$(DEPDIR)
+	@: > src/arc/$(DEPDIR)/$(am__dirstamp)
+src/arc/ffi.lo: src/arc/$(am__dirstamp) \
+	src/arc/$(DEPDIR)/$(am__dirstamp)
+src/arc/arcompact.lo: src/arc/$(am__dirstamp) \
+	src/arc/$(DEPDIR)/$(am__dirstamp)
+src/arm/$(am__dirstamp):
+	@$(MKDIR_P) src/arm
+	@: > src/arm/$(am__dirstamp)
+src/arm/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/arm/$(DEPDIR)
+	@: > src/arm/$(DEPDIR)/$(am__dirstamp)
+src/arm/ffi.lo: src/arm/$(am__dirstamp) \
+	src/arm/$(DEPDIR)/$(am__dirstamp)
+src/arm/sysv.lo: src/arm/$(am__dirstamp) \
+	src/arm/$(DEPDIR)/$(am__dirstamp)
+src/arm/sysv_msvc_arm32.lo: src/arm/$(am__dirstamp) \
+	src/arm/$(DEPDIR)/$(am__dirstamp)
+src/avr32/$(am__dirstamp):
+	@$(MKDIR_P) src/avr32
+	@: > src/avr32/$(am__dirstamp)
+src/avr32/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/avr32/$(DEPDIR)
+	@: > src/avr32/$(DEPDIR)/$(am__dirstamp)
+src/avr32/ffi.lo: src/avr32/$(am__dirstamp) \
+	src/avr32/$(DEPDIR)/$(am__dirstamp)
+src/avr32/sysv.lo: src/avr32/$(am__dirstamp) \
+	src/avr32/$(DEPDIR)/$(am__dirstamp)
+src/bfin/$(am__dirstamp):
+	@$(MKDIR_P) src/bfin
+	@: > src/bfin/$(am__dirstamp)
+src/bfin/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/bfin/$(DEPDIR)
+	@: > src/bfin/$(DEPDIR)/$(am__dirstamp)
+src/bfin/ffi.lo: src/bfin/$(am__dirstamp) \
+	src/bfin/$(DEPDIR)/$(am__dirstamp)
+src/bfin/sysv.lo: src/bfin/$(am__dirstamp) \
+	src/bfin/$(DEPDIR)/$(am__dirstamp)
+src/cris/$(am__dirstamp):
+	@$(MKDIR_P) src/cris
+	@: > src/cris/$(am__dirstamp)
+src/cris/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/cris/$(DEPDIR)
+	@: > src/cris/$(DEPDIR)/$(am__dirstamp)
+src/cris/ffi.lo: src/cris/$(am__dirstamp) \
+	src/cris/$(DEPDIR)/$(am__dirstamp)
+src/cris/sysv.lo: src/cris/$(am__dirstamp) \
+	src/cris/$(DEPDIR)/$(am__dirstamp)
+src/frv/$(am__dirstamp):
+	@$(MKDIR_P) src/frv
+	@: > src/frv/$(am__dirstamp)
+src/frv/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/frv/$(DEPDIR)
+	@: > src/frv/$(DEPDIR)/$(am__dirstamp)
+src/frv/ffi.lo: src/frv/$(am__dirstamp) \
+	src/frv/$(DEPDIR)/$(am__dirstamp)
+src/csky/$(am__dirstamp):
+	@$(MKDIR_P) src/csky
+	@: > src/csky/$(am__dirstamp)
+src/csky/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/csky/$(DEPDIR)
+	@: > src/csky/$(DEPDIR)/$(am__dirstamp)
+src/csky/ffi.lo: src/csky/$(am__dirstamp) \
+	src/csky/$(DEPDIR)/$(am__dirstamp)
+src/csky/sysv.lo: src/csky/$(am__dirstamp) \
+	src/csky/$(DEPDIR)/$(am__dirstamp)
+src/frv/eabi.lo: src/frv/$(am__dirstamp) \
+	src/frv/$(DEPDIR)/$(am__dirstamp)
+src/ia64/$(am__dirstamp):
+	@$(MKDIR_P) src/ia64
+	@: > src/ia64/$(am__dirstamp)
+src/ia64/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/ia64/$(DEPDIR)
+	@: > src/ia64/$(DEPDIR)/$(am__dirstamp)
+src/ia64/ffi.lo: src/ia64/$(am__dirstamp) \
+	src/ia64/$(DEPDIR)/$(am__dirstamp)
+src/ia64/unix.lo: src/ia64/$(am__dirstamp) \
+	src/ia64/$(DEPDIR)/$(am__dirstamp)
+src/m32r/$(am__dirstamp):
+	@$(MKDIR_P) src/m32r
+	@: > src/m32r/$(am__dirstamp)
+src/m32r/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/m32r/$(DEPDIR)
+	@: > src/m32r/$(DEPDIR)/$(am__dirstamp)
+src/m32r/ffi.lo: src/m32r/$(am__dirstamp) \
+	src/m32r/$(DEPDIR)/$(am__dirstamp)
+src/m32r/sysv.lo: src/m32r/$(am__dirstamp) \
+	src/m32r/$(DEPDIR)/$(am__dirstamp)
+src/m68k/$(am__dirstamp):
+	@$(MKDIR_P) src/m68k
+	@: > src/m68k/$(am__dirstamp)
+src/m68k/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/m68k/$(DEPDIR)
+	@: > src/m68k/$(DEPDIR)/$(am__dirstamp)
+src/m68k/ffi.lo: src/m68k/$(am__dirstamp) \
+	src/m68k/$(DEPDIR)/$(am__dirstamp)
+src/m68k/sysv.lo: src/m68k/$(am__dirstamp) \
+	src/m68k/$(DEPDIR)/$(am__dirstamp)
+src/m88k/$(am__dirstamp):
+	@$(MKDIR_P) src/m88k
+	@: > src/m88k/$(am__dirstamp)
+src/m88k/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/m88k/$(DEPDIR)
+	@: > src/m88k/$(DEPDIR)/$(am__dirstamp)
+src/m88k/ffi.lo: src/m88k/$(am__dirstamp) \
+	src/m88k/$(DEPDIR)/$(am__dirstamp)
+src/m88k/obsd.lo: src/m88k/$(am__dirstamp) \
+	src/m88k/$(DEPDIR)/$(am__dirstamp)
+src/metag/$(am__dirstamp):
+	@$(MKDIR_P) src/metag
+	@: > src/metag/$(am__dirstamp)
+src/metag/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/metag/$(DEPDIR)
+	@: > src/metag/$(DEPDIR)/$(am__dirstamp)
+src/metag/ffi.lo: src/metag/$(am__dirstamp) \
+	src/metag/$(DEPDIR)/$(am__dirstamp)
+src/metag/sysv.lo: src/metag/$(am__dirstamp) \
+	src/metag/$(DEPDIR)/$(am__dirstamp)
+src/microblaze/$(am__dirstamp):
+	@$(MKDIR_P) src/microblaze
+	@: > src/microblaze/$(am__dirstamp)
+src/microblaze/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/microblaze/$(DEPDIR)
+	@: > src/microblaze/$(DEPDIR)/$(am__dirstamp)
+src/microblaze/ffi.lo: src/microblaze/$(am__dirstamp) \
+	src/microblaze/$(DEPDIR)/$(am__dirstamp)
+src/microblaze/sysv.lo: src/microblaze/$(am__dirstamp) \
+	src/microblaze/$(DEPDIR)/$(am__dirstamp)
+src/mips/$(am__dirstamp):
+	@$(MKDIR_P) src/mips
+	@: > src/mips/$(am__dirstamp)
+src/mips/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/mips/$(DEPDIR)
+	@: > src/mips/$(DEPDIR)/$(am__dirstamp)
+src/mips/ffi.lo: src/mips/$(am__dirstamp) \
+	src/mips/$(DEPDIR)/$(am__dirstamp)
+src/mips/o32.lo: src/mips/$(am__dirstamp) \
+	src/mips/$(DEPDIR)/$(am__dirstamp)
+src/mips/n32.lo: src/mips/$(am__dirstamp) \
+	src/mips/$(DEPDIR)/$(am__dirstamp)
+src/moxie/$(am__dirstamp):
+	@$(MKDIR_P) src/moxie
+	@: > src/moxie/$(am__dirstamp)
+src/moxie/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/moxie/$(DEPDIR)
+	@: > src/moxie/$(DEPDIR)/$(am__dirstamp)
+src/moxie/ffi.lo: src/moxie/$(am__dirstamp) \
+	src/moxie/$(DEPDIR)/$(am__dirstamp)
+src/moxie/eabi.lo: src/moxie/$(am__dirstamp) \
+	src/moxie/$(DEPDIR)/$(am__dirstamp)
+src/nios2/$(am__dirstamp):
+	@$(MKDIR_P) src/nios2
+	@: > src/nios2/$(am__dirstamp)
+src/nios2/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/nios2/$(DEPDIR)
+	@: > src/nios2/$(DEPDIR)/$(am__dirstamp)
+src/nios2/ffi.lo: src/nios2/$(am__dirstamp) \
+	src/nios2/$(DEPDIR)/$(am__dirstamp)
+src/nios2/sysv.lo: src/nios2/$(am__dirstamp) \
+	src/nios2/$(DEPDIR)/$(am__dirstamp)
+src/or1k/$(am__dirstamp):
+	@$(MKDIR_P) src/or1k
+	@: > src/or1k/$(am__dirstamp)
+src/or1k/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/or1k/$(DEPDIR)
+	@: > src/or1k/$(DEPDIR)/$(am__dirstamp)
+src/or1k/ffi.lo: src/or1k/$(am__dirstamp) \
+	src/or1k/$(DEPDIR)/$(am__dirstamp)
+src/or1k/sysv.lo: src/or1k/$(am__dirstamp) \
+	src/or1k/$(DEPDIR)/$(am__dirstamp)
+src/pa/$(am__dirstamp):
+	@$(MKDIR_P) src/pa
+	@: > src/pa/$(am__dirstamp)
+src/pa/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/pa/$(DEPDIR)
+	@: > src/pa/$(DEPDIR)/$(am__dirstamp)
+src/pa/ffi.lo: src/pa/$(am__dirstamp) src/pa/$(DEPDIR)/$(am__dirstamp)
+src/pa/linux.lo: src/pa/$(am__dirstamp) \
+	src/pa/$(DEPDIR)/$(am__dirstamp)
+src/pa/hpux32.lo: src/pa/$(am__dirstamp) \
+	src/pa/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/$(am__dirstamp):
+	@$(MKDIR_P) src/powerpc
+	@: > src/powerpc/$(am__dirstamp)
+src/powerpc/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/powerpc/$(DEPDIR)
+	@: > src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/ffi.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/ffi_sysv.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/ffi_linux64.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/sysv.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/linux64.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/linux64_closure.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/ppc_closure.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/aix.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/darwin.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/aix_closure.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/darwin_closure.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/powerpc/ffi_darwin.lo: src/powerpc/$(am__dirstamp) \
+	src/powerpc/$(DEPDIR)/$(am__dirstamp)
+src/riscv/$(am__dirstamp):
+	@$(MKDIR_P) src/riscv
+	@: > src/riscv/$(am__dirstamp)
+src/riscv/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/riscv/$(DEPDIR)
+	@: > src/riscv/$(DEPDIR)/$(am__dirstamp)
+src/riscv/ffi.lo: src/riscv/$(am__dirstamp) \
+	src/riscv/$(DEPDIR)/$(am__dirstamp)
+src/riscv/sysv.lo: src/riscv/$(am__dirstamp) \
+	src/riscv/$(DEPDIR)/$(am__dirstamp)
+src/s390/$(am__dirstamp):
+	@$(MKDIR_P) src/s390
+	@: > src/s390/$(am__dirstamp)
+src/s390/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/s390/$(DEPDIR)
+	@: > src/s390/$(DEPDIR)/$(am__dirstamp)
+src/s390/ffi.lo: src/s390/$(am__dirstamp) \
+	src/s390/$(DEPDIR)/$(am__dirstamp)
+src/s390/sysv.lo: src/s390/$(am__dirstamp) \
+	src/s390/$(DEPDIR)/$(am__dirstamp)
+src/sh/$(am__dirstamp):
+	@$(MKDIR_P) src/sh
+	@: > src/sh/$(am__dirstamp)
+src/sh/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/sh/$(DEPDIR)
+	@: > src/sh/$(DEPDIR)/$(am__dirstamp)
+src/sh/ffi.lo: src/sh/$(am__dirstamp) src/sh/$(DEPDIR)/$(am__dirstamp)
+src/sh/sysv.lo: src/sh/$(am__dirstamp) \
+	src/sh/$(DEPDIR)/$(am__dirstamp)
+src/sh64/$(am__dirstamp):
+	@$(MKDIR_P) src/sh64
+	@: > src/sh64/$(am__dirstamp)
+src/sh64/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/sh64/$(DEPDIR)
+	@: > src/sh64/$(DEPDIR)/$(am__dirstamp)
+src/sh64/ffi.lo: src/sh64/$(am__dirstamp) \
+	src/sh64/$(DEPDIR)/$(am__dirstamp)
+src/sh64/sysv.lo: src/sh64/$(am__dirstamp) \
+	src/sh64/$(DEPDIR)/$(am__dirstamp)
+src/sparc/$(am__dirstamp):
+	@$(MKDIR_P) src/sparc
+	@: > src/sparc/$(am__dirstamp)
+src/sparc/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/sparc/$(DEPDIR)
+	@: > src/sparc/$(DEPDIR)/$(am__dirstamp)
+src/sparc/ffi.lo: src/sparc/$(am__dirstamp) \
+	src/sparc/$(DEPDIR)/$(am__dirstamp)
+src/sparc/ffi64.lo: src/sparc/$(am__dirstamp) \
+	src/sparc/$(DEPDIR)/$(am__dirstamp)
+src/sparc/v8.lo: src/sparc/$(am__dirstamp) \
+	src/sparc/$(DEPDIR)/$(am__dirstamp)
+src/sparc/v9.lo: src/sparc/$(am__dirstamp) \
+	src/sparc/$(DEPDIR)/$(am__dirstamp)
+src/tile/$(am__dirstamp):
+	@$(MKDIR_P) src/tile
+	@: > src/tile/$(am__dirstamp)
+src/tile/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/tile/$(DEPDIR)
+	@: > src/tile/$(DEPDIR)/$(am__dirstamp)
+src/tile/ffi.lo: src/tile/$(am__dirstamp) \
+	src/tile/$(DEPDIR)/$(am__dirstamp)
+src/tile/tile.lo: src/tile/$(am__dirstamp) \
+	src/tile/$(DEPDIR)/$(am__dirstamp)
+src/vax/$(am__dirstamp):
+	@$(MKDIR_P) src/vax
+	@: > src/vax/$(am__dirstamp)
+src/vax/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/vax/$(DEPDIR)
+	@: > src/vax/$(DEPDIR)/$(am__dirstamp)
+src/vax/ffi.lo: src/vax/$(am__dirstamp) \
+	src/vax/$(DEPDIR)/$(am__dirstamp)
+src/vax/elfbsd.lo: src/vax/$(am__dirstamp) \
+	src/vax/$(DEPDIR)/$(am__dirstamp)
+src/x86/$(am__dirstamp):
+	@$(MKDIR_P) src/x86
+	@: > src/x86/$(am__dirstamp)
+src/x86/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/x86/$(DEPDIR)
+	@: > src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/ffi.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/sysv.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/ffiw64.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/win64.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/ffi64.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/unix64.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/sysv_intel.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/x86/win64_intel.lo: src/x86/$(am__dirstamp) \
+	src/x86/$(DEPDIR)/$(am__dirstamp)
+src/xtensa/$(am__dirstamp):
+	@$(MKDIR_P) src/xtensa
+	@: > src/xtensa/$(am__dirstamp)
+src/xtensa/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/xtensa/$(DEPDIR)
+	@: > src/xtensa/$(DEPDIR)/$(am__dirstamp)
+src/xtensa/ffi.lo: src/xtensa/$(am__dirstamp) \
+	src/xtensa/$(DEPDIR)/$(am__dirstamp)
+src/xtensa/sysv.lo: src/xtensa/$(am__dirstamp) \
+	src/xtensa/$(DEPDIR)/$(am__dirstamp)
+src/kvx/$(am__dirstamp):
+	@$(MKDIR_P) src/kvx
+	@: > src/kvx/$(am__dirstamp)
+src/kvx/$(DEPDIR)/$(am__dirstamp):
+	@$(MKDIR_P) src/kvx/$(DEPDIR)
+	@: > src/kvx/$(DEPDIR)/$(am__dirstamp)
+src/kvx/ffi.lo: src/kvx/$(am__dirstamp) \
+	src/kvx/$(DEPDIR)/$(am__dirstamp)
+src/kvx/sysv.lo: src/kvx/$(am__dirstamp) \
+	src/kvx/$(DEPDIR)/$(am__dirstamp)
+
+libffi.la: $(libffi_la_OBJECTS) $(libffi_la_DEPENDENCIES) $(EXTRA_libffi_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(libffi_la_LINK) -rpath $(toolexeclibdir) $(libffi_la_OBJECTS) $(libffi_la_LIBADD) $(LIBS)
+
+libffi_convenience.la: $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_DEPENDENCIES) $(EXTRA_libffi_convenience_la_DEPENDENCIES) 
+	$(AM_V_CCLD)$(LINK)  $(libffi_convenience_la_OBJECTS) $(libffi_convenience_la_LIBADD) $(LIBS)
+
+mostlyclean-compile:
+	-rm -f *.$(OBJEXT)
+	-rm -f src/*.$(OBJEXT)
+	-rm -f src/*.lo
+	-rm -f src/aarch64/*.$(OBJEXT)
+	-rm -f src/aarch64/*.lo
+	-rm -f src/alpha/*.$(OBJEXT)
+	-rm -f src/alpha/*.lo
+	-rm -f src/arc/*.$(OBJEXT)
+	-rm -f src/arc/*.lo
+	-rm -f src/arm/*.$(OBJEXT)
+	-rm -f src/arm/*.lo
+	-rm -f src/avr32/*.$(OBJEXT)
+	-rm -f src/avr32/*.lo
+	-rm -f src/bfin/*.$(OBJEXT)
+	-rm -f src/bfin/*.lo
+	-rm -f src/cris/*.$(OBJEXT)
+	-rm -f src/cris/*.lo
+	-rm -f src/csky/*.$(OBJEXT)
+	-rm -f src/csky/*.lo
+	-rm -f src/frv/*.$(OBJEXT)
+	-rm -f src/frv/*.lo
+	-rm -f src/ia64/*.$(OBJEXT)
+	-rm -f src/ia64/*.lo
+	-rm -f src/kvx/*.$(OBJEXT)
+	-rm -f src/kvx/*.lo
+	-rm -f src/m32r/*.$(OBJEXT)
+	-rm -f src/m32r/*.lo
+	-rm -f src/m68k/*.$(OBJEXT)
+	-rm -f src/m68k/*.lo
+	-rm -f src/m88k/*.$(OBJEXT)
+	-rm -f src/m88k/*.lo
+	-rm -f src/metag/*.$(OBJEXT)
+	-rm -f src/metag/*.lo
+	-rm -f src/microblaze/*.$(OBJEXT)
+	-rm -f src/microblaze/*.lo
+	-rm -f src/mips/*.$(OBJEXT)
+	-rm -f src/mips/*.lo
+	-rm -f src/moxie/*.$(OBJEXT)
+	-rm -f src/moxie/*.lo
+	-rm -f src/nios2/*.$(OBJEXT)
+	-rm -f src/nios2/*.lo
+	-rm -f src/or1k/*.$(OBJEXT)
+	-rm -f src/or1k/*.lo
+	-rm -f src/pa/*.$(OBJEXT)
+	-rm -f src/pa/*.lo
+	-rm -f src/powerpc/*.$(OBJEXT)
+	-rm -f src/powerpc/*.lo
+	-rm -f src/riscv/*.$(OBJEXT)
+	-rm -f src/riscv/*.lo
+	-rm -f src/s390/*.$(OBJEXT)
+	-rm -f src/s390/*.lo
+	-rm -f src/sh/*.$(OBJEXT)
+	-rm -f src/sh/*.lo
+	-rm -f src/sh64/*.$(OBJEXT)
+	-rm -f src/sh64/*.lo
+	-rm -f src/sparc/*.$(OBJEXT)
+	-rm -f src/sparc/*.lo
+	-rm -f src/tile/*.$(OBJEXT)
+	-rm -f src/tile/*.lo
+	-rm -f src/vax/*.$(OBJEXT)
+	-rm -f src/vax/*.lo
+	-rm -f src/x86/*.$(OBJEXT)
+	-rm -f src/x86/*.lo
+	-rm -f src/xtensa/*.$(OBJEXT)
+	-rm -f src/xtensa/*.lo
+
+distclean-compile:
+	-rm -f *.tab.c
+
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/closures.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/debug.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/java_raw_api.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/prep_cif.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/raw_api.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/tramp.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/$(DEPDIR)/types.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/aarch64/$(DEPDIR)/win64_armasm.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/alpha/$(DEPDIR)/osf.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/arcompact.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/arc/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/arm/$(DEPDIR)/sysv_msvc_arm32.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/avr32/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/bfin/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/bfin/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/cris/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/csky/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/csky/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/frv/$(DEPDIR)/eabi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/frv/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/ia64/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/ia64/$(DEPDIR)/unix.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/kvx/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/kvx/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m32r/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m32r/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m68k/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/m88k/$(DEPDIR)/obsd.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/metag/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/microblaze/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/n32.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/mips/$(DEPDIR)/o32.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/eabi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/moxie/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/nios2/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/or1k/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/hpux32.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/pa/$(DEPDIR)/linux.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/aix.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/aix_closure.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/darwin.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/darwin_closure.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_darwin.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_linux64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ffi_sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/linux64_closure.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/ppc_closure.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/powerpc/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/riscv/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/s390/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sh/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sh/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sh64/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/ffi64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v8.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/sparc/$(DEPDIR)/v9.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/tile/$(DEPDIR)/tile.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/elfbsd.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/vax/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffi64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/ffiw64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/sysv_intel.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/unix64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win64.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/x86/$(DEPDIR)/win64_intel.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/ffi.Plo@am__quote@ # am--include-marker
+@AMDEP_TRUE@@am__include@ @am__quote@src/xtensa/$(DEPDIR)/sysv.Plo@am__quote@ # am--include-marker
+
+$(am__depfiles_remade):
+	@$(MKDIR_P) $(@D)
+	@echo '# dummy' >$@-t && $(am__mv) $@-t $@
+
+am--depfiles: $(am__depfiles_remade)
+
+.S.o:
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ $<
+
+.S.obj:
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCCAS_TRUE@	$(CPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+@am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.S.lo:
+@am__fastdepCCAS_TRUE@	$(AM_V_CPPAS)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCCAS_TRUE@	$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCCAS_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@	DEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCCAS_FALSE@	$(AM_V_CPPAS@am__nodep@)$(LTCPPASCOMPILE) -c -o $@ $<
+
+.c.o:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.o$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ $<
+
+.c.obj:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.obj$$||'`;\
+@am__fastdepCC_TRUE@	$(COMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ `$(CYGPATH_W) '$<'` &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Po
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=no @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(COMPILE) -c -o $@ `$(CYGPATH_W) '$<'`
+
+.c.lo:
+@am__fastdepCC_TRUE@	$(AM_V_CC)depbase=`echo $@ | sed 's|[^/]*$$|$(DEPDIR)/&|;s|\.lo$$||'`;\
+@am__fastdepCC_TRUE@	$(LTCOMPILE) -MT $@ -MD -MP -MF $$depbase.Tpo -c -o $@ $< &&\
+@am__fastdepCC_TRUE@	$(am__mv) $$depbase.Tpo $$depbase.Plo
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	$(AM_V_CC)source='$<' object='$@' libtool=yes @AMDEPBACKSLASH@
+@AMDEP_TRUE@@am__fastdepCC_FALSE@	DEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@
+@am__fastdepCC_FALSE@	$(AM_V_CC@am__nodep@)$(LTCOMPILE) -c -o $@ $<
+
+mostlyclean-libtool:
+	-rm -f *.lo
+
+clean-libtool:
+	-rm -rf .libs _libs
+	-rm -rf src/.libs src/_libs
+	-rm -rf src/aarch64/.libs src/aarch64/_libs
+	-rm -rf src/alpha/.libs src/alpha/_libs
+	-rm -rf src/arc/.libs src/arc/_libs
+	-rm -rf src/arm/.libs src/arm/_libs
+	-rm -rf src/avr32/.libs src/avr32/_libs
+	-rm -rf src/bfin/.libs src/bfin/_libs
+	-rm -rf src/cris/.libs src/cris/_libs
+	-rm -rf src/csky/.libs src/csky/_libs
+	-rm -rf src/frv/.libs src/frv/_libs
+	-rm -rf src/ia64/.libs src/ia64/_libs
+	-rm -rf src/kvx/.libs src/kvx/_libs
+	-rm -rf src/m32r/.libs src/m32r/_libs
+	-rm -rf src/m68k/.libs src/m68k/_libs
+	-rm -rf src/m88k/.libs src/m88k/_libs
+	-rm -rf src/metag/.libs src/metag/_libs
+	-rm -rf src/microblaze/.libs src/microblaze/_libs
+	-rm -rf src/mips/.libs src/mips/_libs
+	-rm -rf src/moxie/.libs src/moxie/_libs
+	-rm -rf src/nios2/.libs src/nios2/_libs
+	-rm -rf src/or1k/.libs src/or1k/_libs
+	-rm -rf src/pa/.libs src/pa/_libs
+	-rm -rf src/powerpc/.libs src/powerpc/_libs
+	-rm -rf src/riscv/.libs src/riscv/_libs
+	-rm -rf src/s390/.libs src/s390/_libs
+	-rm -rf src/sh/.libs src/sh/_libs
+	-rm -rf src/sh64/.libs src/sh64/_libs
+	-rm -rf src/sparc/.libs src/sparc/_libs
+	-rm -rf src/tile/.libs src/tile/_libs
+	-rm -rf src/vax/.libs src/vax/_libs
+	-rm -rf src/x86/.libs src/x86/_libs
+	-rm -rf src/xtensa/.libs src/xtensa/_libs
+
+distclean-libtool:
+	-rm -f libtool config.lt
+install-pkgconfigDATA: $(pkgconfig_DATA)
+	@$(NORMAL_INSTALL)
+	@list='$(pkgconfig_DATA)'; test -n "$(pkgconfigdir)" || list=; \
+	if test -n "$$list"; then \
+	  echo " $(MKDIR_P) '$(DESTDIR)$(pkgconfigdir)'"; \
+	  $(MKDIR_P) "$(DESTDIR)$(pkgconfigdir)" || exit 1; \
+	fi; \
+	for p in $$list; do \
+	  if test -f "$$p"; then d=; else d="$(srcdir)/"; fi; \
+	  echo "$$d$$p"; \
+	done | $(am__base_list) | \
+	while read files; do \
+	  echo " $(INSTALL_DATA) $$files '$(DESTDIR)$(pkgconfigdir)'"; \
+	  $(INSTALL_DATA) $$files "$(DESTDIR)$(pkgconfigdir)" || exit $$?; \
+	done
+
+uninstall-pkgconfigDATA:
+	@$(NORMAL_UNINSTALL)
+	@list='$(pkgconfig_DATA)'; test -n "$(pkgconfigdir)" || list=; \
+	files=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \
+	dir='$(DESTDIR)$(pkgconfigdir)'; $(am__uninstall_files_from_dir)
+
+# This directory's subdirectories are mostly independent; you can cd
+# into them and run 'make' without going through this Makefile.
+# To change the values of 'make' variables: instead of editing Makefiles,
+# (1) if the variable is set in 'config.status', edit 'config.status'
+#     (which will cause the Makefiles to be regenerated when you run 'make');
+# (2) otherwise, pass the desired values on the 'make' command line.
+$(am__recursive_targets):
+	@fail=; \
+	if $(am__make_keepgoing); then \
+	  failcom='fail=yes'; \
+	else \
+	  failcom='exit 1'; \
+	fi; \
+	dot_seen=no; \
+	target=`echo $@ | sed s/-recursive//`; \
+	case "$@" in \
+	  distclean-* | maintainer-clean-*) list='$(DIST_SUBDIRS)' ;; \
+	  *) list='$(SUBDIRS)' ;; \
+	esac; \
+	for subdir in $$list; do \
+	  echo "Making $$target in $$subdir"; \
+	  if test "$$subdir" = "."; then \
+	    dot_seen=yes; \
+	    local_target="$$target-am"; \
+	  else \
+	    local_target="$$target"; \
+	  fi; \
+	  ($(am__cd) $$subdir && $(MAKE) $(AM_MAKEFLAGS) $$local_target) \
+	  || eval $$failcom; \
+	done; \
+	if test "$$dot_seen" = "no"; then \
+	  $(MAKE) $(AM_MAKEFLAGS) "$$target-am" || exit 1; \
+	fi; test -z "$$fail"
+
+ID: $(am__tagged_files)
+	$(am__define_uniq_tagged_files); mkid -fID $$unique
+tags: tags-recursive
+TAGS: tags
+
+tags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	set x; \
+	here=`pwd`; \
+	if ($(ETAGS) --etags-include --version) >/dev/null 2>&1; then \
+	  include_option=--etags-include; \
+	  empty_fix=.; \
+	else \
+	  include_option=--include; \
+	  empty_fix=; \
+	fi; \
+	list='$(SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    test ! -f $$subdir/TAGS || \
+	      set "$$@" "$$include_option=$$here/$$subdir/TAGS"; \
+	  fi; \
+	done; \
+	$(am__define_uniq_tagged_files); \
+	shift; \
+	if test -z "$(ETAGS_ARGS)$$*$$unique"; then :; else \
+	  test -n "$$unique" || unique=$$empty_fix; \
+	  if test $$# -gt 0; then \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      "$$@" $$unique; \
+	  else \
+	    $(ETAGS) $(ETAGSFLAGS) $(AM_ETAGSFLAGS) $(ETAGS_ARGS) \
+	      $$unique; \
+	  fi; \
+	fi
+ctags: ctags-recursive
+
+CTAGS: ctags
+ctags-am: $(TAGS_DEPENDENCIES) $(am__tagged_files)
+	$(am__define_uniq_tagged_files); \
+	test -z "$(CTAGS_ARGS)$$unique" \
+	  || $(CTAGS) $(CTAGSFLAGS) $(AM_CTAGSFLAGS) $(CTAGS_ARGS) \
+	     $$unique
+
+GTAGS:
+	here=`$(am__cd) $(top_builddir) && pwd` \
+	  && $(am__cd) $(top_srcdir) \
+	  && gtags -i $(GTAGS_ARGS) "$$here"
+cscope: cscope.files
+	test ! -s cscope.files \
+	  || $(CSCOPE) -b -q $(AM_CSCOPEFLAGS) $(CSCOPEFLAGS) -i cscope.files $(CSCOPE_ARGS)
+clean-cscope:
+	-rm -f cscope.files
+cscope.files: clean-cscope cscopelist
+cscopelist: cscopelist-recursive
+
+cscopelist-am: $(am__tagged_files)
+	list='$(am__tagged_files)'; \
+	case "$(srcdir)" in \
+	  [\\/]* | ?:[\\/]*) sdir="$(srcdir)" ;; \
+	  *) sdir=$(subdir)/$(srcdir) ;; \
+	esac; \
+	for i in $$list; do \
+	  if test -f "$$i"; then \
+	    echo "$(subdir)/$$i"; \
+	  else \
+	    echo "$$sdir/$$i"; \
+	  fi; \
+	done >> $(top_builddir)/cscope.files
+
+distclean-tags:
+	-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags
+	-rm -f cscope.out cscope.in.out cscope.po.out cscope.files
+
+distdir: $(BUILT_SOURCES)
+	$(MAKE) $(AM_MAKEFLAGS) distdir-am
+
+distdir-am: $(DISTFILES)
+	$(am__remove_distdir)
+	test -d "$(distdir)" || mkdir "$(distdir)"
+	@srcdirstrip=`echo "$(srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	topsrcdirstrip=`echo "$(top_srcdir)" | sed 's/[].[^$$\\*]/\\\\&/g'`; \
+	list='$(DISTFILES)'; \
+	  dist_files=`for file in $$list; do echo $$file; done | \
+	  sed -e "s|^$$srcdirstrip/||;t" \
+	      -e "s|^$$topsrcdirstrip/|$(top_builddir)/|;t"`; \
+	case $$dist_files in \
+	  */*) $(MKDIR_P) `echo "$$dist_files" | \
+			   sed '/\//!d;s|^|$(distdir)/|;s,/[^/]*$$,,' | \
+			   sort -u` ;; \
+	esac; \
+	for file in $$dist_files; do \
+	  if test -f $$file || test -d $$file; then d=.; else d=$(srcdir); fi; \
+	  if test -d $$d/$$file; then \
+	    dir=`echo "/$$file" | sed -e 's,/[^/]*$$,,'`; \
+	    if test -d "$(distdir)/$$file"; then \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    if test -d $(srcdir)/$$file && test $$d != $(srcdir); then \
+	      cp -fpR $(srcdir)/$$file "$(distdir)$$dir" || exit 1; \
+	      find "$(distdir)/$$file" -type d ! -perm -700 -exec chmod u+rwx {} \;; \
+	    fi; \
+	    cp -fpR $$d/$$file "$(distdir)$$dir" || exit 1; \
+	  else \
+	    test -f "$(distdir)/$$file" \
+	    || cp -p $$d/$$file "$(distdir)/$$file" \
+	    || exit 1; \
+	  fi; \
+	done
+	@list='$(DIST_SUBDIRS)'; for subdir in $$list; do \
+	  if test "$$subdir" = .; then :; else \
+	    $(am__make_dryrun) \
+	      || test -d "$(distdir)/$$subdir" \
+	      || $(MKDIR_P) "$(distdir)/$$subdir" \
+	      || exit 1; \
+	    dir1=$$subdir; dir2="$(distdir)/$$subdir"; \
+	    $(am__relativize); \
+	    new_distdir=$$reldir; \
+	    dir1=$$subdir; dir2="$(top_distdir)"; \
+	    $(am__relativize); \
+	    new_top_distdir=$$reldir; \
+	    echo " (cd $$subdir && $(MAKE) $(AM_MAKEFLAGS) top_distdir="$$new_top_distdir" distdir="$$new_distdir" \\"; \
+	    echo "     am__remove_distdir=: am__skip_length_check=: am__skip_mode_fix=: distdir)"; \
+	    ($(am__cd) $$subdir && \
+	      $(MAKE) $(AM_MAKEFLAGS) \
+	        top_distdir="$$new_top_distdir" \
+	        distdir="$$new_distdir" \
+		am__remove_distdir=: \
+		am__skip_length_check=: \
+		am__skip_mode_fix=: \
+	        distdir) \
+	      || exit 1; \
+	  fi; \
+	done
+	$(MAKE) $(AM_MAKEFLAGS) \
+	  top_distdir="$(top_distdir)" distdir="$(distdir)" \
+	  dist-hook
+	-test -n "$(am__skip_mode_fix)" \
+	|| find "$(distdir)" -type d ! -perm -755 \
+		-exec chmod u+rwx,go+rx {} \; -o \
+	  ! -type d ! -perm -444 -links 1 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -400 -exec chmod a+r {} \; -o \
+	  ! -type d ! -perm -444 -exec $(install_sh) -c -m a+r {} {} \; \
+	|| chmod -R a+r "$(distdir)"
+dist-gzip: distdir
+	tardir=$(distdir) && $(am__tar) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).tar.gz
+	$(am__post_remove_distdir)
+
+dist-bzip2: distdir
+	tardir=$(distdir) && $(am__tar) | BZIP2=$${BZIP2--9} bzip2 -c >$(distdir).tar.bz2
+	$(am__post_remove_distdir)
+
+dist-lzip: distdir
+	tardir=$(distdir) && $(am__tar) | lzip -c $${LZIP_OPT--9} >$(distdir).tar.lz
+	$(am__post_remove_distdir)
+
+dist-xz: distdir
+	tardir=$(distdir) && $(am__tar) | XZ_OPT=$${XZ_OPT--e} xz -c >$(distdir).tar.xz
+	$(am__post_remove_distdir)
+
+dist-zstd: distdir
+	tardir=$(distdir) && $(am__tar) | zstd -c $${ZSTD_CLEVEL-$${ZSTD_OPT--19}} >$(distdir).tar.zst
+	$(am__post_remove_distdir)
+
+dist-tarZ: distdir
+	@echo WARNING: "Support for distribution archives compressed with" \
+		       "legacy program 'compress' is deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	tardir=$(distdir) && $(am__tar) | compress -c >$(distdir).tar.Z
+	$(am__post_remove_distdir)
+
+dist-shar: distdir
+	@echo WARNING: "Support for shar distribution archives is" \
+	               "deprecated." >&2
+	@echo WARNING: "It will be removed altogether in Automake 2.0" >&2
+	shar $(distdir) | eval GZIP= gzip $(GZIP_ENV) -c >$(distdir).shar.gz
+	$(am__post_remove_distdir)
+
+dist-zip: distdir
+	-rm -f $(distdir).zip
+	zip -rq $(distdir).zip $(distdir)
+	$(am__post_remove_distdir)
+
+dist dist-all:
+	$(MAKE) $(AM_MAKEFLAGS) $(DIST_TARGETS) am__post_remove_distdir='@:'
+	$(am__post_remove_distdir)
+
+# This target untars the dist file and tries a VPATH configuration.  Then
+# it guarantees that the distribution is self-contained by making another
+# tarfile.
+distcheck: dist
+	case '$(DIST_ARCHIVES)' in \
+	*.tar.gz*) \
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).tar.gz | $(am__untar) ;;\
+	*.tar.bz2*) \
+	  bzip2 -dc $(distdir).tar.bz2 | $(am__untar) ;;\
+	*.tar.lz*) \
+	  lzip -dc $(distdir).tar.lz | $(am__untar) ;;\
+	*.tar.xz*) \
+	  xz -dc $(distdir).tar.xz | $(am__untar) ;;\
+	*.tar.Z*) \
+	  uncompress -c $(distdir).tar.Z | $(am__untar) ;;\
+	*.shar.gz*) \
+	  eval GZIP= gzip $(GZIP_ENV) -dc $(distdir).shar.gz | unshar ;;\
+	*.zip*) \
+	  unzip $(distdir).zip ;;\
+	*.tar.zst*) \
+	  zstd -dc $(distdir).tar.zst | $(am__untar) ;;\
+	esac
+	chmod -R a-w $(distdir)
+	chmod u+w $(distdir)
+	mkdir $(distdir)/_build $(distdir)/_build/sub $(distdir)/_inst
+	chmod a-w $(distdir)
+	test -d $(distdir)/_build || exit 0; \
+	dc_install_base=`$(am__cd) $(distdir)/_inst && pwd | sed -e 's,^[^:\\/]:[\\/],/,'` \
+	  && dc_destdir="$${TMPDIR-/tmp}/am-dc-$$$$/" \
+	  && am__cwd=`pwd` \
+	  && $(am__cd) $(distdir)/_build/sub \
+	  && ../../configure \
+	    $(AM_DISTCHECK_CONFIGURE_FLAGS) \
+	    $(DISTCHECK_CONFIGURE_FLAGS) \
+	    --srcdir=../.. --prefix="$$dc_install_base" \
+	  && $(MAKE) $(AM_MAKEFLAGS) \
+	  && $(MAKE) $(AM_MAKEFLAGS) dvi \
+	  && $(MAKE) $(AM_MAKEFLAGS) check \
+	  && $(MAKE) $(AM_MAKEFLAGS) install \
+	  && $(MAKE) $(AM_MAKEFLAGS) installcheck \
+	  && $(MAKE) $(AM_MAKEFLAGS) uninstall \
+	  && $(MAKE) $(AM_MAKEFLAGS) distuninstallcheck_dir="$$dc_install_base" \
+	        distuninstallcheck \
+	  && chmod -R a-w "$$dc_install_base" \
+	  && ({ \
+	       (cd ../.. && umask 077 && mkdir "$$dc_destdir") \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" install \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" uninstall \
+	       && $(MAKE) $(AM_MAKEFLAGS) DESTDIR="$$dc_destdir" \
+	            distuninstallcheck_dir="$$dc_destdir" distuninstallcheck; \
+	      } || { rm -rf "$$dc_destdir"; exit 1; }) \
+	  && rm -rf "$$dc_destdir" \
+	  && $(MAKE) $(AM_MAKEFLAGS) dist \
+	  && rm -rf $(DIST_ARCHIVES) \
+	  && $(MAKE) $(AM_MAKEFLAGS) distcleancheck \
+	  && cd "$$am__cwd" \
+	  || exit 1
+	$(am__post_remove_distdir)
+	@(echo "$(distdir) archives ready for distribution: "; \
+	  list='$(DIST_ARCHIVES)'; for i in $$list; do echo $$i; done) | \
+	  sed -e 1h -e 1s/./=/g -e 1p -e 1x -e '$$p' -e '$$x'
+distuninstallcheck:
+	@test -n '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: trying to run $@ with an empty' \
+	       '$$(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	$(am__cd) '$(distuninstallcheck_dir)' || { \
+	  echo 'ERROR: cannot chdir into $(distuninstallcheck_dir)' >&2; \
+	  exit 1; \
+	}; \
+	test `$(am__distuninstallcheck_listfiles) | wc -l` -eq 0 \
+	   || { echo "ERROR: files left after uninstall:" ; \
+	        if test -n "$(DESTDIR)"; then \
+	          echo "  (check DESTDIR support)"; \
+	        fi ; \
+	        $(distuninstallcheck_listfiles) ; \
+	        exit 1; } >&2
+distcleancheck: distclean
+	@if test '$(srcdir)' = . ; then \
+	  echo "ERROR: distcleancheck can only run from a VPATH build" ; \
+	  exit 1 ; \
+	fi
+	@test `$(distcleancheck_listfiles) | wc -l` -eq 0 \
+	  || { echo "ERROR: files left in build directory after distclean:" ; \
+	       $(distcleancheck_listfiles) ; \
+	       exit 1; } >&2
+check-am: all-am
+check: check-recursive
+all-am: Makefile $(LTLIBRARIES) $(DATA) $(HEADERS) fficonfig.h
+installdirs: installdirs-recursive
+installdirs-am:
+	for dir in "$(DESTDIR)$(toolexeclibdir)" "$(DESTDIR)$(pkgconfigdir)"; do \
+	  test -z "$$dir" || $(MKDIR_P) "$$dir"; \
+	done
+install: install-recursive
+install-exec: install-exec-recursive
+install-data: install-data-recursive
+uninstall: uninstall-recursive
+
+install-am: all-am
+	@$(MAKE) $(AM_MAKEFLAGS) install-exec-am install-data-am
+
+installcheck: installcheck-recursive
+install-strip:
+	if test -z '$(STRIP)'; then \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	      install; \
+	else \
+	  $(MAKE) $(AM_MAKEFLAGS) INSTALL_PROGRAM="$(INSTALL_STRIP_PROGRAM)" \
+	    install_sh_PROGRAM="$(INSTALL_STRIP_PROGRAM)" INSTALL_STRIP_FLAG=-s \
+	    "INSTALL_PROGRAM_ENV=STRIPPROG='$(STRIP)'" install; \
+	fi
+mostlyclean-generic:
+
+clean-generic:
+
+distclean-generic:
+	-test -z "$(CONFIG_CLEAN_FILES)" || rm -f $(CONFIG_CLEAN_FILES)
+	-test . = "$(srcdir)" || test -z "$(CONFIG_CLEAN_VPATH_FILES)" || rm -f $(CONFIG_CLEAN_VPATH_FILES)
+	-rm -f src/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/$(am__dirstamp)
+	-rm -f src/aarch64/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/aarch64/$(am__dirstamp)
+	-rm -f src/alpha/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/alpha/$(am__dirstamp)
+	-rm -f src/arc/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/arc/$(am__dirstamp)
+	-rm -f src/arm/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/arm/$(am__dirstamp)
+	-rm -f src/avr32/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/avr32/$(am__dirstamp)
+	-rm -f src/bfin/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/bfin/$(am__dirstamp)
+	-rm -f src/cris/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/cris/$(am__dirstamp)
+	-rm -f src/csky/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/csky/$(am__dirstamp)
+	-rm -f src/frv/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/frv/$(am__dirstamp)
+	-rm -f src/ia64/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/ia64/$(am__dirstamp)
+	-rm -f src/kvx/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/kvx/$(am__dirstamp)
+	-rm -f src/m32r/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/m32r/$(am__dirstamp)
+	-rm -f src/m68k/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/m68k/$(am__dirstamp)
+	-rm -f src/m88k/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/m88k/$(am__dirstamp)
+	-rm -f src/metag/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/metag/$(am__dirstamp)
+	-rm -f src/microblaze/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/microblaze/$(am__dirstamp)
+	-rm -f src/mips/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/mips/$(am__dirstamp)
+	-rm -f src/moxie/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/moxie/$(am__dirstamp)
+	-rm -f src/nios2/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/nios2/$(am__dirstamp)
+	-rm -f src/or1k/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/or1k/$(am__dirstamp)
+	-rm -f src/pa/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/pa/$(am__dirstamp)
+	-rm -f src/powerpc/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/powerpc/$(am__dirstamp)
+	-rm -f src/riscv/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/riscv/$(am__dirstamp)
+	-rm -f src/s390/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/s390/$(am__dirstamp)
+	-rm -f src/sh/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/sh/$(am__dirstamp)
+	-rm -f src/sh64/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/sh64/$(am__dirstamp)
+	-rm -f src/sparc/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/sparc/$(am__dirstamp)
+	-rm -f src/tile/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/tile/$(am__dirstamp)
+	-rm -f src/vax/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/vax/$(am__dirstamp)
+	-rm -f src/x86/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/x86/$(am__dirstamp)
+	-rm -f src/xtensa/$(DEPDIR)/$(am__dirstamp)
+	-rm -f src/xtensa/$(am__dirstamp)
+	-test -z "$(DISTCLEANFILES)" || rm -f $(DISTCLEANFILES)
+
+maintainer-clean-generic:
+	@echo "This command is intended for maintainers to use"
+	@echo "it deletes files that may require special tools to rebuild."
+clean: clean-recursive
+
+clean-am: clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	clean-toolexeclibLTLIBRARIES mostlyclean-am
+
+distclean: distclean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+		-rm -f src/$(DEPDIR)/closures.Plo
+	-rm -f src/$(DEPDIR)/debug.Plo
+	-rm -f src/$(DEPDIR)/java_raw_api.Plo
+	-rm -f src/$(DEPDIR)/prep_cif.Plo
+	-rm -f src/$(DEPDIR)/raw_api.Plo
+	-rm -f src/$(DEPDIR)/tramp.Plo
+	-rm -f src/$(DEPDIR)/types.Plo
+	-rm -f src/aarch64/$(DEPDIR)/ffi.Plo
+	-rm -f src/aarch64/$(DEPDIR)/sysv.Plo
+	-rm -f src/aarch64/$(DEPDIR)/win64_armasm.Plo
+	-rm -f src/alpha/$(DEPDIR)/ffi.Plo
+	-rm -f src/alpha/$(DEPDIR)/osf.Plo
+	-rm -f src/arc/$(DEPDIR)/arcompact.Plo
+	-rm -f src/arc/$(DEPDIR)/ffi.Plo
+	-rm -f src/arm/$(DEPDIR)/ffi.Plo
+	-rm -f src/arm/$(DEPDIR)/sysv.Plo
+	-rm -f src/arm/$(DEPDIR)/sysv_msvc_arm32.Plo
+	-rm -f src/avr32/$(DEPDIR)/ffi.Plo
+	-rm -f src/avr32/$(DEPDIR)/sysv.Plo
+	-rm -f src/bfin/$(DEPDIR)/ffi.Plo
+	-rm -f src/bfin/$(DEPDIR)/sysv.Plo
+	-rm -f src/cris/$(DEPDIR)/ffi.Plo
+	-rm -f src/cris/$(DEPDIR)/sysv.Plo
+	-rm -f src/csky/$(DEPDIR)/ffi.Plo
+	-rm -f src/csky/$(DEPDIR)/sysv.Plo
+	-rm -f src/frv/$(DEPDIR)/eabi.Plo
+	-rm -f src/frv/$(DEPDIR)/ffi.Plo
+	-rm -f src/ia64/$(DEPDIR)/ffi.Plo
+	-rm -f src/ia64/$(DEPDIR)/unix.Plo
+	-rm -f src/kvx/$(DEPDIR)/ffi.Plo
+	-rm -f src/kvx/$(DEPDIR)/sysv.Plo
+	-rm -f src/m32r/$(DEPDIR)/ffi.Plo
+	-rm -f src/m32r/$(DEPDIR)/sysv.Plo
+	-rm -f src/m68k/$(DEPDIR)/ffi.Plo
+	-rm -f src/m68k/$(DEPDIR)/sysv.Plo
+	-rm -f src/m88k/$(DEPDIR)/ffi.Plo
+	-rm -f src/m88k/$(DEPDIR)/obsd.Plo
+	-rm -f src/metag/$(DEPDIR)/ffi.Plo
+	-rm -f src/metag/$(DEPDIR)/sysv.Plo
+	-rm -f src/microblaze/$(DEPDIR)/ffi.Plo
+	-rm -f src/microblaze/$(DEPDIR)/sysv.Plo
+	-rm -f src/mips/$(DEPDIR)/ffi.Plo
+	-rm -f src/mips/$(DEPDIR)/n32.Plo
+	-rm -f src/mips/$(DEPDIR)/o32.Plo
+	-rm -f src/moxie/$(DEPDIR)/eabi.Plo
+	-rm -f src/moxie/$(DEPDIR)/ffi.Plo
+	-rm -f src/nios2/$(DEPDIR)/ffi.Plo
+	-rm -f src/nios2/$(DEPDIR)/sysv.Plo
+	-rm -f src/or1k/$(DEPDIR)/ffi.Plo
+	-rm -f src/or1k/$(DEPDIR)/sysv.Plo
+	-rm -f src/pa/$(DEPDIR)/ffi.Plo
+	-rm -f src/pa/$(DEPDIR)/hpux32.Plo
+	-rm -f src/pa/$(DEPDIR)/linux.Plo
+	-rm -f src/powerpc/$(DEPDIR)/aix.Plo
+	-rm -f src/powerpc/$(DEPDIR)/aix_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/darwin.Plo
+	-rm -f src/powerpc/$(DEPDIR)/darwin_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_darwin.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_linux64.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_sysv.Plo
+	-rm -f src/powerpc/$(DEPDIR)/linux64.Plo
+	-rm -f src/powerpc/$(DEPDIR)/linux64_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ppc_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/sysv.Plo
+	-rm -f src/riscv/$(DEPDIR)/ffi.Plo
+	-rm -f src/riscv/$(DEPDIR)/sysv.Plo
+	-rm -f src/s390/$(DEPDIR)/ffi.Plo
+	-rm -f src/s390/$(DEPDIR)/sysv.Plo
+	-rm -f src/sh/$(DEPDIR)/ffi.Plo
+	-rm -f src/sh/$(DEPDIR)/sysv.Plo
+	-rm -f src/sh64/$(DEPDIR)/ffi.Plo
+	-rm -f src/sh64/$(DEPDIR)/sysv.Plo
+	-rm -f src/sparc/$(DEPDIR)/ffi.Plo
+	-rm -f src/sparc/$(DEPDIR)/ffi64.Plo
+	-rm -f src/sparc/$(DEPDIR)/v8.Plo
+	-rm -f src/sparc/$(DEPDIR)/v9.Plo
+	-rm -f src/tile/$(DEPDIR)/ffi.Plo
+	-rm -f src/tile/$(DEPDIR)/tile.Plo
+	-rm -f src/vax/$(DEPDIR)/elfbsd.Plo
+	-rm -f src/vax/$(DEPDIR)/ffi.Plo
+	-rm -f src/x86/$(DEPDIR)/ffi.Plo
+	-rm -f src/x86/$(DEPDIR)/ffi64.Plo
+	-rm -f src/x86/$(DEPDIR)/ffiw64.Plo
+	-rm -f src/x86/$(DEPDIR)/sysv.Plo
+	-rm -f src/x86/$(DEPDIR)/sysv_intel.Plo
+	-rm -f src/x86/$(DEPDIR)/unix64.Plo
+	-rm -f src/x86/$(DEPDIR)/win64.Plo
+	-rm -f src/x86/$(DEPDIR)/win64_intel.Plo
+	-rm -f src/xtensa/$(DEPDIR)/ffi.Plo
+	-rm -f src/xtensa/$(DEPDIR)/sysv.Plo
+	-rm -f Makefile
+distclean-am: clean-am distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags
+
+dvi: dvi-recursive
+
+dvi-am:
+
+html: html-recursive
+
+html-am:
+
+info: info-recursive
+
+info-am:
+
+install-data-am: install-pkgconfigDATA
+
+install-dvi: install-dvi-recursive
+
+install-dvi-am:
+
+install-exec-am: install-toolexeclibLTLIBRARIES
+
+install-html: install-html-recursive
+
+install-html-am:
+
+install-info: install-info-recursive
+
+install-info-am:
+
+install-man:
+
+install-pdf: install-pdf-recursive
+
+install-pdf-am:
+
+install-ps: install-ps-recursive
+
+install-ps-am:
+
+installcheck-am:
+
+maintainer-clean: maintainer-clean-recursive
+	-rm -f $(am__CONFIG_DISTCLEAN_FILES)
+	-rm -rf $(top_srcdir)/autom4te.cache
+		-rm -f src/$(DEPDIR)/closures.Plo
+	-rm -f src/$(DEPDIR)/debug.Plo
+	-rm -f src/$(DEPDIR)/java_raw_api.Plo
+	-rm -f src/$(DEPDIR)/prep_cif.Plo
+	-rm -f src/$(DEPDIR)/raw_api.Plo
+	-rm -f src/$(DEPDIR)/tramp.Plo
+	-rm -f src/$(DEPDIR)/types.Plo
+	-rm -f src/aarch64/$(DEPDIR)/ffi.Plo
+	-rm -f src/aarch64/$(DEPDIR)/sysv.Plo
+	-rm -f src/aarch64/$(DEPDIR)/win64_armasm.Plo
+	-rm -f src/alpha/$(DEPDIR)/ffi.Plo
+	-rm -f src/alpha/$(DEPDIR)/osf.Plo
+	-rm -f src/arc/$(DEPDIR)/arcompact.Plo
+	-rm -f src/arc/$(DEPDIR)/ffi.Plo
+	-rm -f src/arm/$(DEPDIR)/ffi.Plo
+	-rm -f src/arm/$(DEPDIR)/sysv.Plo
+	-rm -f src/arm/$(DEPDIR)/sysv_msvc_arm32.Plo
+	-rm -f src/avr32/$(DEPDIR)/ffi.Plo
+	-rm -f src/avr32/$(DEPDIR)/sysv.Plo
+	-rm -f src/bfin/$(DEPDIR)/ffi.Plo
+	-rm -f src/bfin/$(DEPDIR)/sysv.Plo
+	-rm -f src/cris/$(DEPDIR)/ffi.Plo
+	-rm -f src/cris/$(DEPDIR)/sysv.Plo
+	-rm -f src/csky/$(DEPDIR)/ffi.Plo
+	-rm -f src/csky/$(DEPDIR)/sysv.Plo
+	-rm -f src/frv/$(DEPDIR)/eabi.Plo
+	-rm -f src/frv/$(DEPDIR)/ffi.Plo
+	-rm -f src/ia64/$(DEPDIR)/ffi.Plo
+	-rm -f src/ia64/$(DEPDIR)/unix.Plo
+	-rm -f src/kvx/$(DEPDIR)/ffi.Plo
+	-rm -f src/kvx/$(DEPDIR)/sysv.Plo
+	-rm -f src/m32r/$(DEPDIR)/ffi.Plo
+	-rm -f src/m32r/$(DEPDIR)/sysv.Plo
+	-rm -f src/m68k/$(DEPDIR)/ffi.Plo
+	-rm -f src/m68k/$(DEPDIR)/sysv.Plo
+	-rm -f src/m88k/$(DEPDIR)/ffi.Plo
+	-rm -f src/m88k/$(DEPDIR)/obsd.Plo
+	-rm -f src/metag/$(DEPDIR)/ffi.Plo
+	-rm -f src/metag/$(DEPDIR)/sysv.Plo
+	-rm -f src/microblaze/$(DEPDIR)/ffi.Plo
+	-rm -f src/microblaze/$(DEPDIR)/sysv.Plo
+	-rm -f src/mips/$(DEPDIR)/ffi.Plo
+	-rm -f src/mips/$(DEPDIR)/n32.Plo
+	-rm -f src/mips/$(DEPDIR)/o32.Plo
+	-rm -f src/moxie/$(DEPDIR)/eabi.Plo
+	-rm -f src/moxie/$(DEPDIR)/ffi.Plo
+	-rm -f src/nios2/$(DEPDIR)/ffi.Plo
+	-rm -f src/nios2/$(DEPDIR)/sysv.Plo
+	-rm -f src/or1k/$(DEPDIR)/ffi.Plo
+	-rm -f src/or1k/$(DEPDIR)/sysv.Plo
+	-rm -f src/pa/$(DEPDIR)/ffi.Plo
+	-rm -f src/pa/$(DEPDIR)/hpux32.Plo
+	-rm -f src/pa/$(DEPDIR)/linux.Plo
+	-rm -f src/powerpc/$(DEPDIR)/aix.Plo
+	-rm -f src/powerpc/$(DEPDIR)/aix_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/darwin.Plo
+	-rm -f src/powerpc/$(DEPDIR)/darwin_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_darwin.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_linux64.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ffi_sysv.Plo
+	-rm -f src/powerpc/$(DEPDIR)/linux64.Plo
+	-rm -f src/powerpc/$(DEPDIR)/linux64_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/ppc_closure.Plo
+	-rm -f src/powerpc/$(DEPDIR)/sysv.Plo
+	-rm -f src/riscv/$(DEPDIR)/ffi.Plo
+	-rm -f src/riscv/$(DEPDIR)/sysv.Plo
+	-rm -f src/s390/$(DEPDIR)/ffi.Plo
+	-rm -f src/s390/$(DEPDIR)/sysv.Plo
+	-rm -f src/sh/$(DEPDIR)/ffi.Plo
+	-rm -f src/sh/$(DEPDIR)/sysv.Plo
+	-rm -f src/sh64/$(DEPDIR)/ffi.Plo
+	-rm -f src/sh64/$(DEPDIR)/sysv.Plo
+	-rm -f src/sparc/$(DEPDIR)/ffi.Plo
+	-rm -f src/sparc/$(DEPDIR)/ffi64.Plo
+	-rm -f src/sparc/$(DEPDIR)/v8.Plo
+	-rm -f src/sparc/$(DEPDIR)/v9.Plo
+	-rm -f src/tile/$(DEPDIR)/ffi.Plo
+	-rm -f src/tile/$(DEPDIR)/tile.Plo
+	-rm -f src/vax/$(DEPDIR)/elfbsd.Plo
+	-rm -f src/vax/$(DEPDIR)/ffi.Plo
+	-rm -f src/x86/$(DEPDIR)/ffi.Plo
+	-rm -f src/x86/$(DEPDIR)/ffi64.Plo
+	-rm -f src/x86/$(DEPDIR)/ffiw64.Plo
+	-rm -f src/x86/$(DEPDIR)/sysv.Plo
+	-rm -f src/x86/$(DEPDIR)/sysv_intel.Plo
+	-rm -f src/x86/$(DEPDIR)/unix64.Plo
+	-rm -f src/x86/$(DEPDIR)/win64.Plo
+	-rm -f src/x86/$(DEPDIR)/win64_intel.Plo
+	-rm -f src/xtensa/$(DEPDIR)/ffi.Plo
+	-rm -f src/xtensa/$(DEPDIR)/sysv.Plo
+	-rm -f Makefile
+maintainer-clean-am: distclean-am maintainer-clean-generic
+
+mostlyclean: mostlyclean-recursive
+
+mostlyclean-am: mostlyclean-compile mostlyclean-generic \
+	mostlyclean-libtool
+
+pdf: pdf-recursive
+
+pdf-am:
+
+ps: ps-recursive
+
+ps-am:
+
+uninstall-am: uninstall-pkgconfigDATA uninstall-toolexeclibLTLIBRARIES
+
+.MAKE: $(am__recursive_targets) all install-am install-strip
+
+.PHONY: $(am__recursive_targets) CTAGS GTAGS TAGS all all-am \
+	am--depfiles am--refresh check check-am clean clean-cscope \
+	clean-generic clean-libtool clean-noinstLTLIBRARIES \
+	clean-toolexeclibLTLIBRARIES cscope cscopelist-am ctags \
+	ctags-am dist dist-all dist-bzip2 dist-gzip dist-hook \
+	dist-lzip dist-shar dist-tarZ dist-xz dist-zip dist-zstd \
+	distcheck distclean distclean-compile distclean-generic \
+	distclean-hdr distclean-libtool distclean-tags distcleancheck \
+	distdir distuninstallcheck dvi dvi-am html html-am info \
+	info-am install install-am install-data install-data-am \
+	install-dvi install-dvi-am install-exec install-exec-am \
+	install-html install-html-am install-info install-info-am \
+	install-man install-pdf install-pdf-am install-pkgconfigDATA \
+	install-ps install-ps-am install-strip \
+	install-toolexeclibLTLIBRARIES installcheck installcheck-am \
+	installdirs installdirs-am maintainer-clean \
+	maintainer-clean-generic mostlyclean mostlyclean-compile \
+	mostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \
+	tags tags-am uninstall uninstall-am uninstall-pkgconfigDATA \
+	uninstall-toolexeclibLTLIBRARIES
+
+.PRECIOUS: Makefile
+
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@libffi.map-sun : libffi.map $(top_srcdir)/make_sunver.pl \
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@		 $(libffi_la_OBJECTS) $(libffi_la_LIBADD)
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@	perl $(top_srcdir)/make_sunver.pl libffi.map \
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@	 `echo $(libffi_la_OBJECTS) $(libffi_la_LIBADD) | \
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@	    sed 's,\([^/        ]*\)\.l\([ao]\),.libs/\1.\2,g'` \
+@LIBFFI_BUILD_VERSIONED_SHLIB_SUN_TRUE@@LIBFFI_BUILD_VERSIONED_SHLIB_TRUE@	 > $@ || (rm -f $@ ; exit 1)
+
+libffi.map: $(top_srcdir)/libffi.map.in
+	$(COMPILE) -D$(TARGET) -DGENERATE_LIBFFI_MAP \
+	 -E -x assembler-with-cpp -o $@ $(top_srcdir)/libffi.map.in
+
+dist-hook:
+	d=`(cd $(distdir); pwd)`; (cd doc; make pdf; cp *.pdf $$d/doc)
+	if [ -d $(top_srcdir)/.git ] ; then (cd $(top_srcdir); git log --no-decorate) ; else echo 'See git log for history.' ; fi > $(distdir)/ChangeLog
+	s=`awk '/was released on/{ print NR; exit}' $(top_srcdir)/README.md`; tail -n +$$(($$s-1)) $(top_srcdir)/README.md > $(distdir)/README.md
+
+# Tell versions [3.59,3.63) of GNU make to not export all variables.
+# Otherwise a system limit (for SysV at least) may be exceeded.
+.NOEXPORT:
diff -urN libffi-3.4.2.ori/src/loongarch/ffi.c libffi-3.4.2/src/loongarch/ffi.c
--- libffi-3.4.2.ori/src/loongarch/ffi.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/src/loongarch/ffi.c	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,490 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+                         2018 Stef O'Rear <sorear2@gmail.com>
+   Based on MIPS N32/64 port
+
+   LOONGARCH Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#include <ffi.h>
+#include <ffi_common.h>
+
+#include <stdlib.h>
+#include <stdint.h>
+
+#define ABI_FLEN 64
+#define ABI_FLOAT double
+
+#define NARGREG 8
+#define STKALIGN 16
+#define MAXCOPYARG (2 * sizeof(double))
+
+typedef struct call_context
+{
+    ABI_FLOAT fa[8];
+    size_t a[8];
+    /* used by the assembly code to in-place construct its own stack frame */
+    char frame[16];
+} call_context;
+
+typedef struct call_builder
+{
+    call_context *aregs;
+    int used_integer;
+    int used_float;
+    size_t *used_stack;
+} call_builder;
+
+/* integer (not pointer) less than ABI XLEN */
+/* FFI_TYPE_INT does not appear to be used */
+#if __SIZEOF_POINTER__ == 8
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT64)
+#else
+#define IS_INT(type) ((type) >= FFI_TYPE_UINT8 && (type) <= FFI_TYPE_SINT32)
+#endif
+
+#if ABI_FLEN
+typedef struct {
+    char as_elements, type1, offset2, type2;
+} float_struct_info;
+
+#if ABI_FLEN >= 64
+#define IS_FLOAT(type) ((type) >= FFI_TYPE_FLOAT && (type) <= FFI_TYPE_DOUBLE)
+#else
+#define IS_FLOAT(type) ((type) == FFI_TYPE_FLOAT)
+#endif
+
+static ffi_type **flatten_struct(ffi_type *in, ffi_type **out, ffi_type **out_end) {
+    int i;
+    if (out == out_end) return out;
+    if (in->type != FFI_TYPE_STRUCT) {
+        *(out++) = in;
+    } else {
+        for (i = 0; in->elements[i]; i++)
+            out = flatten_struct(in->elements[i], out, out_end);
+    }
+    return out;
+}
+
+/* Structs with at most two fields after flattening, one of which is of
+   floating point type, are passed in multiple registers if sufficient
+   registers are available. */
+static float_struct_info struct_passed_as_elements(call_builder *cb, ffi_type *top) {
+    float_struct_info ret = {0, 0, 0, 0};
+    ffi_type *fields[3];
+    int num_floats, num_ints;
+    int num_fields = flatten_struct(top, fields, fields + 3) - fields;
+
+    if (num_fields == 1) {
+        if (IS_FLOAT(fields[0]->type)) {
+            ret.as_elements = 1;
+            ret.type1 = fields[0]->type;
+        }
+    } else if (num_fields == 2) {
+        num_floats = IS_FLOAT(fields[0]->type) + IS_FLOAT(fields[1]->type);
+        num_ints = IS_INT(fields[0]->type) + IS_INT(fields[1]->type);
+        if (num_floats == 0 || num_floats + num_ints != 2)
+            return ret;
+        if (cb->used_float + num_floats > NARGREG || cb->used_integer + (2 - num_floats) > NARGREG)
+            return ret;
+        if (!IS_FLOAT(fields[0]->type) && !IS_FLOAT(fields[1]->type))
+            return ret;
+
+        ret.type1 = fields[0]->type;
+        ret.type2 = fields[1]->type;
+        ret.offset2 = FFI_ALIGN(fields[0]->size, fields[1]->alignment);
+        ret.as_elements = 1;
+    }
+
+    return ret;
+}
+#endif
+
+/* allocates a single register, float register, or XLEN-sized stack slot to a datum */
+static void marshal_atom(call_builder *cb, int type, void *data) {
+    size_t value = 0;
+    switch (type) {
+        case FFI_TYPE_UINT8: value = *(uint8_t *)data; break;
+        case FFI_TYPE_SINT8: value = *(int8_t *)data; break;
+        case FFI_TYPE_UINT16: value = *(uint16_t *)data; break;
+        case FFI_TYPE_SINT16: value = *(int16_t *)data; break;
+        /* 32-bit quantities are always sign-extended in the ABI */
+        case FFI_TYPE_UINT32: value = *(int32_t *)data; break;
+        case FFI_TYPE_SINT32: value = *(int32_t *)data; break;
+#if __SIZEOF_POINTER__ == 8
+        case FFI_TYPE_UINT64: value = *(uint64_t *)data; break;
+        case FFI_TYPE_SINT64: value = *(int64_t *)data; break;
+#endif
+        case FFI_TYPE_POINTER: value = *(size_t *)data; break;
+
+        /* float values may be recoded in an implementation-defined way
+           by hardware conforming to 2.1 or earlier, so use asm to
+           reinterpret floats as doubles */
+#if ABI_FLEN >= 32
+        case FFI_TYPE_FLOAT:
+            asm("" : "=f"(cb->aregs->fa[cb->used_float++]) : "0"(*(float *)data));
+            return;
+#endif
+#if ABI_FLEN >= 64
+        case FFI_TYPE_DOUBLE:
+            asm("" : "=f"(cb->aregs->fa[cb->used_float++]) : "0"(*(double *)data));
+            return;
+#endif
+        default: FFI_ASSERT(0); break;
+    }
+
+    if (cb->used_integer == NARGREG) {
+        *cb->used_stack++ = value;
+    } else {
+        cb->aregs->a[cb->used_integer++] = value;
+    }
+}
+
+static void unmarshal_atom(call_builder *cb, int type, void *data) {
+    size_t value;
+    switch (type) {
+#if ABI_FLEN >= 32
+        case FFI_TYPE_FLOAT:
+            asm("" : "=f"(*(float *)data) : "0"(cb->aregs->fa[cb->used_float++]));
+            return;
+#endif
+#if ABI_FLEN >= 64
+        case FFI_TYPE_DOUBLE:
+            asm("" : "=f"(*(double *)data) : "0"(cb->aregs->fa[cb->used_float++]));
+            return;
+#endif
+    }
+
+    if (cb->used_integer == NARGREG) {
+        value = *cb->used_stack++;
+    } else {
+        value = cb->aregs->a[cb->used_integer++];
+    }
+
+    switch (type) {
+        case FFI_TYPE_UINT8: *(uint8_t *)data = value; break;
+        case FFI_TYPE_SINT8: *(uint8_t *)data = value; break;
+        case FFI_TYPE_UINT16: *(uint16_t *)data = value; break;
+        case FFI_TYPE_SINT16: *(uint16_t *)data = value; break;
+        case FFI_TYPE_UINT32: *(uint32_t *)data = value; break;
+        case FFI_TYPE_SINT32: *(uint32_t *)data = value; break;
+#if __SIZEOF_POINTER__ == 8
+        case FFI_TYPE_UINT64: *(uint64_t *)data = value; break;
+        case FFI_TYPE_SINT64: *(uint64_t *)data = value; break;
+#endif
+        case FFI_TYPE_POINTER: *(size_t *)data = value; break;
+        default: FFI_ASSERT(0); break;
+    }
+}
+
+/* adds an argument to a call, or a not by reference return value */
+static void marshal(call_builder *cb, ffi_type *type, int var, void *data) {
+    size_t realign[2];
+
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) {
+            marshal_atom(cb, fsi.type1, data);
+            if (fsi.offset2)
+                marshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);
+            return;
+        }
+    }
+
+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {
+        marshal_atom(cb, type->type, data);
+        return;
+    }
+
+    double promoted;
+    if (var && type->type == FFI_TYPE_FLOAT)
+    {
+        /* C standard requires promoting float -> double for variable arg */
+      promoted = *(float *)data;
+      type = &ffi_type_double;
+      data = &promoted;
+    }
+#endif
+
+    if (type->size > 2 * __SIZEOF_POINTER__) {
+        /* pass by reference */
+        marshal_atom(cb, FFI_TYPE_POINTER, &data);
+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+        marshal_atom(cb, type->type, data);
+    } else {
+        /* overlong integers, soft-float floats, and structs without special
+           float handling are treated identically from this point on */
+
+        /* variadics are aligned even in registers */
+        if (type->alignment > __SIZEOF_POINTER__) {
+            if (var)
+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);
+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);
+        }
+
+        memcpy(realign, data, type->size);
+        if (type->size > 0)
+            marshal_atom(cb, FFI_TYPE_POINTER, realign);
+        if (type->size > __SIZEOF_POINTER__)
+            marshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+    }
+}
+
+/* for arguments passed by reference returns the pointer, otherwise the arg is copied (up to MAXCOPYARG bytes) */
+static void *unmarshal(call_builder *cb, ffi_type *type, int var, void *data) {
+    size_t realign[2];
+    void *pointer;
+
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) {
+            unmarshal_atom(cb, fsi.type1, data);
+            if (fsi.offset2)
+                unmarshal_atom(cb, fsi.type2, ((char*)data) + fsi.offset2);
+            return data;
+        }
+    }
+
+    if (!var && cb->used_float < NARGREG && IS_FLOAT(type->type)) {
+        unmarshal_atom(cb, type->type, data);
+        return data;
+    }
+
+    if (var && type->type == FFI_TYPE_FLOAT)
+    {
+      int m = cb->used_integer;
+      void *promoted = m < NARGREG ? cb->aregs->a + m:cb->used_stack + m - NARGREG + 1;
+      *(float*)promoted = *(double *)promoted;
+    }
+#endif
+
+    if (type->size > 2 * __SIZEOF_POINTER__) {
+        /* pass by reference */
+        unmarshal_atom(cb, FFI_TYPE_POINTER, (char*)&pointer);
+        return pointer;
+    } else if (IS_INT(type->type) || type->type == FFI_TYPE_POINTER) {
+        unmarshal_atom(cb, type->type, data);
+        return data;
+    } else {
+        /* overlong integers, soft-float floats, and structs without special
+           float handling are treated identically from this point on */
+
+        /* variadics are aligned even in registers */
+        if (type->alignment > __SIZEOF_POINTER__) {
+            if (var)
+                cb->used_integer = FFI_ALIGN(cb->used_integer, 2);
+            cb->used_stack = (size_t *)FFI_ALIGN(cb->used_stack, 2*__SIZEOF_POINTER__);
+        }
+
+        if (type->size > 0)
+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign);
+        if (type->size > __SIZEOF_POINTER__)
+            unmarshal_atom(cb, FFI_TYPE_POINTER, realign + 1);
+        memcpy(data, realign, type->size);
+        return data;
+    }
+}
+
+static int passed_by_ref(call_builder *cb, ffi_type *type, int var) {
+#if ABI_FLEN
+    if (!var && type->type == FFI_TYPE_STRUCT) {
+        float_struct_info fsi = struct_passed_as_elements(cb, type);
+        if (fsi.as_elements) return 0;
+    }
+#endif
+
+    return type->size > 2 * __SIZEOF_POINTER__;
+}
+
+/* Perform machine dependent cif processing */
+ffi_status ffi_prep_cif_machdep(ffi_cif *cif) {
+    cif->loongarch_nfixedargs = cif->nargs;
+    return FFI_OK;
+}
+
+/* Perform machine dependent cif processing when we have a variadic function */
+
+ffi_status ffi_prep_cif_machdep_var(ffi_cif *cif, unsigned int nfixedargs, unsigned int ntotalargs) {
+    cif->loongarch_nfixedargs = nfixedargs;
+    return FFI_OK;
+}
+
+/* Low level routine for calling functions */
+extern void ffi_call_asm (void *stack, struct call_context *regs,
+			  void (*fn) (void), void *closure) FFI_HIDDEN;
+
+static void
+ffi_call_int (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue,
+	      void *closure)
+{
+    /* this is a conservative estimate, assuming a complex return value and
+       that all remaining arguments are long long / __int128 */
+    size_t arg_bytes = cif->nargs <= 3 ? 0 :
+        FFI_ALIGN(2 * sizeof(size_t) * (cif->nargs - 3), STKALIGN);
+    size_t rval_bytes = 0;
+    if (rvalue == NULL && cif->rtype->size > 2*__SIZEOF_POINTER__)
+        rval_bytes = FFI_ALIGN(cif->rtype->size, STKALIGN);
+    size_t alloc_size = arg_bytes + rval_bytes + sizeof(call_context);
+
+    /* the assembly code will deallocate all stack data at lower addresses
+       than the argument region, so we need to allocate the frame and the
+       return value after the arguments in a single allocation */
+    size_t alloc_base;
+    /* Argument region must be 16-byte aligned */
+    if (_Alignof(max_align_t) >= STKALIGN) {
+        /* since sizeof long double is normally 16, the compiler will
+           guarantee alloca alignment to at least that much */
+        alloc_base = (size_t)alloca(alloc_size);
+    } else {
+        alloc_base = FFI_ALIGN(alloca(alloc_size + STKALIGN - 1), STKALIGN);
+    }
+
+    if (rval_bytes)
+        rvalue = (void*)(alloc_base + arg_bytes);
+
+    call_builder cb;
+    cb.used_float = cb.used_integer = 0;
+    cb.aregs = (call_context*)(alloc_base + arg_bytes + rval_bytes);
+    cb.used_stack = (void*)alloc_base;
+
+    int return_by_ref = passed_by_ref(&cb, cif->rtype, 0);
+    if (return_by_ref)
+        marshal(&cb, &ffi_type_pointer, 0, &rvalue);
+
+    int i;
+    for (i = 0; i < cif->nargs; i++)
+        marshal(&cb, cif->arg_types[i], i >= cif->loongarch_nfixedargs, avalue[i]);
+
+    ffi_call_asm ((void *) alloc_base, cb.aregs, fn, closure);
+
+    cb.used_float = cb.used_integer = 0;
+    if (!return_by_ref && rvalue)
+        unmarshal(&cb, cif->rtype, 0, rvalue);
+}
+
+void
+ffi_call (ffi_cif *cif, void (*fn) (void), void *rvalue, void **avalue)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, NULL);
+}
+
+void
+ffi_call_go (ffi_cif *cif, void (*fn) (void), void *rvalue,
+	     void **avalue, void *closure)
+{
+  ffi_call_int(cif, fn, rvalue, avalue, closure);
+}
+
+extern void ffi_closure_asm(void) FFI_HIDDEN;
+
+ffi_status ffi_prep_closure_loc(ffi_closure *closure, ffi_cif *cif, void (*fun)(ffi_cif*,void*,void**,void*), void *user_data, void *codeloc)
+{
+    uint32_t *tramp = (uint32_t *) &closure->tramp[0];
+    uint64_t fn = (uint64_t) (uintptr_t) ffi_closure_asm;
+
+    if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+        return FFI_BAD_ABI;
+
+    /* we will call ffi_closure_inner with codeloc, not closure, but as long
+       as the memory is readable it should work */
+
+  tramp[0] = 0x1800000c; /* pcaddi      $t0, 0 (i.e. $t0 <- tramp) */
+#ifdef _ABILP64
+  tramp[1] = 0x28c0418d; /* ld.d        $t1, $t0, 16 */
+#elif defined _ABILPX32
+  tramp[1] = 0x2880418d; /* ld.w        $t1, $t0, 16 */
+#endif
+  tramp[2] = 0x4c0001a0; /* jirl        $zero, $t1, 0 */
+  tramp[3] = 0x03400000; /* nop */
+    tramp[4] = fn;
+    tramp[5] = fn >> 32;
+
+    closure->cif = cif;
+    closure->fun = fun;
+    closure->user_data = user_data;
+
+    __builtin___clear_cache(codeloc, codeloc + FFI_TRAMPOLINE_SIZE);
+
+    return FFI_OK;
+}
+
+extern void ffi_go_closure_asm (void) FFI_HIDDEN;
+
+ffi_status
+ffi_prep_go_closure (ffi_go_closure *closure, ffi_cif *cif,
+		     void (*fun) (ffi_cif *, void *, void **, void *))
+{
+  if (cif->abi <= FFI_FIRST_ABI || cif->abi >= FFI_LAST_ABI)
+    return FFI_BAD_ABI;
+
+  closure->tramp = (void *) ffi_go_closure_asm;
+  closure->cif = cif;
+  closure->fun = fun;
+
+  return FFI_OK;
+}
+
+/* Called by the assembly code with aregs pointing to saved argument registers
+   and stack pointing to the stacked arguments.  Return values passed in
+   registers will be reloaded from aregs. */
+void FFI_HIDDEN
+ffi_closure_inner (ffi_cif *cif,
+		   void (*fun) (ffi_cif *, void *, void **, void *),
+		   void *user_data,
+		   size_t *stack, call_context *aregs)
+{
+    void **avalue = alloca(cif->nargs * sizeof(void*));
+    /* storage for arguments which will be copied by unmarshal().  We could
+       theoretically avoid the copies in many cases and use at most 128 bytes
+       of memory, but allocating disjoint storage for each argument is
+       simpler. */
+    char *astorage = alloca(cif->nargs * MAXCOPYARG);
+    void *rvalue;
+    call_builder cb;
+    int return_by_ref;
+    int i;
+
+    cb.aregs = aregs;
+    cb.used_integer = cb.used_float = 0;
+    cb.used_stack = stack;
+
+    return_by_ref = passed_by_ref(&cb, cif->rtype, 0);
+    if (return_by_ref)
+        unmarshal(&cb, &ffi_type_pointer, 0, &rvalue);
+    else
+        rvalue = alloca(cif->rtype->size);
+
+    for (i = 0; i < cif->nargs; i++)
+        avalue[i] = unmarshal(&cb, cif->arg_types[i],
+            i >= cif->loongarch_nfixedargs, astorage + i*MAXCOPYARG);
+
+    fun (cif, rvalue, avalue, user_data);
+
+    if (!return_by_ref && cif->rtype->type != FFI_TYPE_VOID) {
+        cb.used_integer = cb.used_float = 0;
+        marshal(&cb, cif->rtype, 0, rvalue);
+    }
+}
diff -urN libffi-3.4.2.ori/src/loongarch/ffitarget.h libffi-3.4.2/src/loongarch/ffitarget.h
--- libffi-3.4.2.ori/src/loongarch/ffitarget.h	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/src/loongarch/ffitarget.h	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,69 @@
+/* -----------------------------------------------------------------*-C-*-
+   ffitarget.h - 2014 Michael Knyszek
+
+   Target configuration macros for LOONGARCH.
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+
+   ----------------------------------------------------------------------- */
+
+#ifndef LIBFFI_TARGET_H
+#define LIBFFI_TARGET_H
+
+#ifndef LIBFFI_H
+#error "Please do not include ffitarget.h directly into your source.  Use ffi.h instead."
+#endif
+
+#ifndef __loongarch__
+#error "libffi was configured for a LOONGARCH target but this does not appear to be a LOONGARCH compiler."
+#endif
+
+#ifndef LIBFFI_ASM
+
+typedef unsigned long ffi_arg;
+typedef   signed long ffi_sarg;
+
+/* FFI_UNUSED_NN and loongarch_unused are to maintain ABI compatibility with a
+   distributed Berkeley patch from 2014, and can be removed at SONAME bump */
+typedef enum ffi_abi {
+    FFI_FIRST_ABI = 0,
+    FFI_LP64,
+    FFI_UNUSED_1,
+    FFI_UNUSED_2,
+    FFI_UNUSED_3,
+    FFI_LAST_ABI,
+
+    FFI_DEFAULT_ABI = FFI_LP64
+} ffi_abi;
+
+#endif /* LIBFFI_ASM */
+
+/* ---- Definitions for closures ----------------------------------------- */
+
+#define FFI_CLOSURES 1
+#define FFI_GO_CLOSURES 1
+#define FFI_TRAMPOLINE_SIZE 24
+#define FFI_NATIVE_RAW_API 0
+#define FFI_EXTRA_CIF_FIELDS unsigned loongarch_nfixedargs; unsigned loongarch_unused;
+#define FFI_TARGET_SPECIFIC_VARIADIC
+//#define FFI_TARGET_HAS_COMPLEX_TYPE 1
+#endif
+
diff -urN libffi-3.4.2.ori/src/loongarch/sysv.S libffi-3.4.2/src/loongarch/sysv.S
--- libffi-3.4.2.ori/src/loongarch/sysv.S	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/src/loongarch/sysv.S	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,288 @@
+/* -----------------------------------------------------------------------
+   ffi.c - Copyright (c) 2015 Michael Knyszek <mknyszek@berkeley.edu>
+                         2015 Andrew Waterman <waterman@cs.berkeley.edu>
+                         2018 Stef O'Rear <sorear2@gmail.com>
+
+   LOONGARCH Foreign Function Interface
+
+   Permission is hereby granted, free of charge, to any person obtaining
+   a copy of this software and associated documentation files (the
+   ``Software''), to deal in the Software without restriction, including
+   without limitation the rights to use, copy, modify, merge, publish,
+   distribute, sublicense, and/or sell copies of the Software, and to
+   permit persons to whom the Software is furnished to do so, subject to
+   the following conditions:
+
+   The above copyright notice and this permission notice shall be included
+   in all copies or substantial portions of the Software.
+
+   THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND,
+   EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+   MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
+   NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
+   HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
+   WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
+   OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+   DEALINGS IN THE SOFTWARE.
+   ----------------------------------------------------------------------- */
+
+#define LIBFFI_ASM
+#include <fficonfig.h>
+#include <ffi.h>
+
+/* Define aliases so that we can handle all ABIs uniformly */
+
+#if __SIZEOF_POINTER__ == 8
+#define PTRS 8
+#define LARG ld.d
+#define SARG st.d
+#else
+#define PTRS 4
+#define LARG ld.w
+#define SARG st.w
+#endif
+
+#ifdef __loongarch_hard_float
+# if defined __loongarch_single_float
+#  define FLT	float
+#  define FLEN	4
+#  define FLD	fld.w
+#  define FST	fst.w
+#  error "need check"
+# else
+#  define FLT	double
+#  define FLEN	8
+#  define FLARG	fld.d
+#  define FSARG	fst.d
+# endif
+#else
+# define FLEN	0
+# error "need check"
+#endif
+
+#define FLTS 8
+
+
+    .text
+    .globl  ffi_call_asm
+    .type   ffi_call_asm, @function
+    .hidden ffi_call_asm
+/*
+  struct call_context {
+      floatreg fa[8];
+      intreg a[8];
+      intreg pad[rv32 ? 2 : 0];
+      intreg save_fp, save_ra;
+  }
+  void ffi_call_asm (size_t *stackargs, struct call_context *regargs,
+                     void (*fn) (void), void *closure);
+*/
+
+#define FRAME_LEN (8 * FLTS + 8 * PTRS + 8 * 2)
+
+ffi_call_asm:
+    .cfi_startproc
+
+    /*
+      We are NOT going to set up an ordinary stack frame.  In order to pass
+      the stacked args to the called function, we adjust our stack pointer to
+      a0, which is in the _caller's_ alloca area.  We establish our own stack
+      frame at the end of the call_context.
+
+      Anything below the arguments will be freed at this point, although we
+      preserve the call_context so that it can be read back in the caller.
+    */
+
+    .cfi_def_cfa 5, FRAME_LEN # interim CFA based on a1
+    SARG    $fp, $a1, FRAME_LEN - 2*PTRS
+    .cfi_offset 22, -2*PTRS
+    SARG    $ra, $a1, FRAME_LEN - 1*PTRS
+    .cfi_offset 1, -1*PTRS
+
+    addi.d    $fp, $a1, FRAME_LEN
+    move      $sp, $a0
+    .cfi_def_cfa 22, 0 # our frame is fully set up
+
+    # Load arguments
+    move      $t1, $a2
+    move      $t2, $a3
+
+    FLARG   $fa0, $fp, -FRAME_LEN+0*FLTS
+    FLARG   $fa1, $fp, -FRAME_LEN+1*FLTS
+    FLARG   $fa2, $fp, -FRAME_LEN+2*FLTS
+    FLARG   $fa3, $fp, -FRAME_LEN+3*FLTS
+    FLARG   $fa4, $fp, -FRAME_LEN+4*FLTS
+    FLARG   $fa5, $fp, -FRAME_LEN+5*FLTS
+    FLARG   $fa6, $fp, -FRAME_LEN+6*FLTS
+    FLARG   $fa7, $fp, -FRAME_LEN+7*FLTS
+
+    LARG    $a0, $fp, -FRAME_LEN+8*FLTS+0*PTRS
+    LARG    $a1, $fp, -FRAME_LEN+8*FLTS+1*PTRS
+    LARG    $a2, $fp, -FRAME_LEN+8*FLTS+2*PTRS
+    LARG    $a3, $fp, -FRAME_LEN+8*FLTS+3*PTRS
+    LARG    $a4, $fp, -FRAME_LEN+8*FLTS+4*PTRS
+    LARG    $a5, $fp, -FRAME_LEN+8*FLTS+5*PTRS
+    LARG    $a6, $fp, -FRAME_LEN+8*FLTS+6*PTRS
+    LARG    $a7, $fp, -FRAME_LEN+8*FLTS+7*PTRS
+
+    /* Call */
+    jirl    $ra,$t1,0
+
+    /* Save return values - only a0/a1 (fa0/fa1) are used */
+    FSARG   $fa0, $fp, -FRAME_LEN+0*FLTS
+    FSARG   $fa1, $fp, -FRAME_LEN+1*FLTS
+
+    SARG    $a0, $fp, -FRAME_LEN+8*FLTS+0*PTRS
+    SARG    $a1, $fp, -FRAME_LEN+8*FLTS+1*PTRS
+
+    /* Restore and return */
+    addi.d    $sp, $fp, -FRAME_LEN
+    .cfi_def_cfa 3, FRAME_LEN
+    LARG    $ra, $fp, -1*PTRS
+    .cfi_restore 1
+    LARG    $fp, $fp, -2*PTRS
+    .cfi_restore 22
+    jirl $r0, $ra, 0
+    .cfi_endproc
+    .size   ffi_call_asm, .-ffi_call_asm
+
+
+/*
+  ffi_closure_asm. Expects address of the passed-in ffi_closure in t1.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+    .globl ffi_closure_asm
+    .hidden ffi_closure_asm
+    .type ffi_closure_asm, @function
+ffi_closure_asm:
+    .cfi_startproc
+
+    addi.d    $sp,  $sp, -FRAME_LEN
+    .cfi_def_cfa_offset FRAME_LEN
+
+    /* make a frame */
+    SARG    $fp, $sp, FRAME_LEN - 2*PTRS
+    .cfi_offset 22, -2*PTRS
+    SARG    $ra, $sp, FRAME_LEN - 1*PTRS
+    .cfi_offset 1, -1*PTRS
+    addi.d    $fp, $sp, FRAME_LEN
+
+    /* save arguments */
+    FSARG   $fa0, $sp, 0*FLTS
+    FSARG   $fa1, $sp, 1*FLTS
+    FSARG   $fa2, $sp, 2*FLTS
+    FSARG   $fa3, $sp, 3*FLTS
+    FSARG   $fa4, $sp, 4*FLTS
+    FSARG   $fa5, $sp, 5*FLTS
+    FSARG   $fa6, $sp, 6*FLTS
+    FSARG   $fa7, $sp, 7*FLTS
+
+    SARG    $a0, $sp, 8*FLTS+0*PTRS
+    SARG    $a1, $sp, 8*FLTS+1*PTRS
+    SARG    $a2, $sp, 8*FLTS+2*PTRS
+    SARG    $a3, $sp, 8*FLTS+3*PTRS
+    SARG    $a4, $sp, 8*FLTS+4*PTRS
+    SARG    $a5, $sp, 8*FLTS+5*PTRS
+    SARG    $a6, $sp, 8*FLTS+6*PTRS
+    SARG    $a7, $sp, 8*FLTS+7*PTRS
+
+    /* enter C */
+    LARG    $a0, $t0, FFI_TRAMPOLINE_SIZE+0*PTRS
+    LARG    $a1, $t0, FFI_TRAMPOLINE_SIZE+1*PTRS
+    LARG    $a2, $t0, FFI_TRAMPOLINE_SIZE+2*PTRS
+    addi.d    $a3, $sp, FRAME_LEN
+    move      $a4, $sp
+
+    bl   ffi_closure_inner
+
+    /* return values */
+    FLARG   $fa0, $sp, 0*FLTS
+    FLARG   $fa1, $sp, 1*FLTS
+
+    LARG    $a0, $sp, 8*FLTS+0*PTRS
+    LARG    $a1, $sp, 8*FLTS+1*PTRS
+
+    /* restore and return */
+    LARG    $ra, $sp, FRAME_LEN-1*PTRS
+    .cfi_restore 1
+    LARG    $fp, $sp, FRAME_LEN-2*PTRS
+    .cfi_restore 22
+    addi.d    $sp, $sp, FRAME_LEN
+    .cfi_def_cfa_offset 0
+    jirl $r0, $ra, 0
+    .cfi_endproc
+    .size ffi_closure_asm, .-ffi_closure_asm
+
+/*
+  ffi_go_closure_asm.  Expects address of the passed-in ffi_go_closure in t2.
+  void ffi_closure_inner (ffi_cif *cif,
+		          void (*fun) (ffi_cif *, void *, void **, void *),
+		          void *user_data,
+		          size_t *stackargs, struct call_context *regargs)
+*/
+
+    .globl ffi_go_closure_asm
+    .hidden ffi_go_closure_asm
+    .type ffi_go_closure_asm, @function
+ffi_go_closure_asm:
+    .cfi_startproc
+
+    addi.d    $sp,  $sp, -FRAME_LEN
+    .cfi_def_cfa_offset FRAME_LEN
+
+    /* make a frame */
+    SARG    $fp, $sp, FRAME_LEN - 2*PTRS
+    .cfi_offset 22, -2*PTRS
+    SARG    $ra, $sp, FRAME_LEN - 1*PTRS
+    .cfi_offset 1, -1*PTRS
+    addi.d    $fp, $sp, FRAME_LEN
+
+    /* save arguments */
+    FSARG   $fa0, $sp, 0*FLTS
+    FSARG   $fa1, $sp, 1*FLTS
+    FSARG   $fa2, $sp, 2*FLTS
+    FSARG   $fa3, $sp, 3*FLTS
+    FSARG   $fa4, $sp, 4*FLTS
+    FSARG   $fa5, $sp, 5*FLTS
+    FSARG   $fa6, $sp, 6*FLTS
+    FSARG   $fa7, $sp, 7*FLTS
+
+    SARG    $a0, $sp, 8*FLTS+0*PTRS
+    SARG    $a1, $sp, 8*FLTS+1*PTRS
+    SARG    $a2, $sp, 8*FLTS+2*PTRS
+    SARG    $a3, $sp, 8*FLTS+3*PTRS
+    SARG    $a4, $sp, 8*FLTS+4*PTRS
+    SARG    $a5, $sp, 8*FLTS+5*PTRS
+    SARG    $a6, $sp, 8*FLTS+6*PTRS
+    SARG    $a7, $sp, 8*FLTS+7*PTRS
+
+    /* enter C */
+    LARG    $a0, $t2, 1*PTRS
+    LARG    $a1, $t2, 2*PTRS
+    move      $a2, $t2
+    addi.d    $a3, $sp, FRAME_LEN
+    move      $a4, $sp
+
+    bl    ffi_closure_inner
+
+    /* return values */
+    FLARG   $fa0, $sp, 0*FLTS
+    FLARG   $fa1, $sp, 1*FLTS
+
+    LARG    $a0, $sp, 8*FLTS+0*PTRS
+    LARG    $a1, $sp, 8*FLTS+1*PTRS
+
+    /* restore and return */
+    LARG    $ra, $sp, FRAME_LEN-1*PTRS
+    .cfi_restore 1
+    LARG    $fp, $sp, FRAME_LEN-2*PTRS
+    .cfi_restore 22
+    addi.d    $sp, $sp, FRAME_LEN
+    .cfi_def_cfa_offset 0
+    jirl $r0, $ra, 0
+    .cfi_endproc
+    .size ffi_go_closure_asm, .-ffi_go_closure_asm
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many3.c libffi-3.4.2/testsuite/libffi.call/many3.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many3.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many3.c	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,106 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+	unsigned ret;
+	unsigned one;
+	unsigned two;
+} s3i;
+
+static double many(double f1,
+		  double f2,
+		  s3i arg,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  double f6,
+		  long int i3,
+		  double f7,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (arg.ret + arg.one + arg.two + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  ffi_type s3i_type;
+  ffi_type *s3i_type_elements[4];
+  s3i arg;
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  s3i_type.size = 0;
+  s3i_type.alignment = 0;
+  s3i_type.type = FFI_TYPE_STRUCT;
+  s3i_type.elements = s3i_type_elements;
+  s3i_type_elements[0] = &ffi_type_uint;
+  s3i_type_elements[1] = &ffi_type_uint;
+  s3i_type_elements[2] = &ffi_type_uint;
+  s3i_type_elements[3] = NULL;
+
+  arg.ret = 3;
+  arg.one = 1;
+  arg.two = 2;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if(i == 2) {
+            args[i] = &s3i_type;
+	    values[i] = &arg;
+            continue;
+          }
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], arg,
+               fa[3], fa[4], la[5],
+               fa[6], fa[7], la[8],
+               fa[9], fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many4.c libffi-3.4.2/testsuite/libffi.call/many4.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many4.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many4.c	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,106 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+	unsigned ret;
+	unsigned one;
+	unsigned two;
+} s3i;
+
+static double many(double f1,
+		  double f2,
+		  long int i1,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  double f6,
+		  long int i3,
+		  s3i arg,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (i1 + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/f6+(arg.ret + arg.one + arg.two)/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  ffi_type s3i_type;
+  ffi_type *s3i_type_elements[4];
+  s3i arg;
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  s3i_type.size = 0;
+  s3i_type.alignment = 0;
+  s3i_type.type = FFI_TYPE_STRUCT;
+  s3i_type.elements = s3i_type_elements;
+  s3i_type_elements[0] = &ffi_type_uint;
+  s3i_type_elements[1] = &ffi_type_uint;
+  s3i_type_elements[2] = &ffi_type_uint;
+  s3i_type_elements[3] = NULL;
+
+  arg.ret = 3;
+  arg.one = 1;
+  arg.two = 2;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if(i == 9) {
+            args[i] = &s3i_type;
+	    values[i] = &arg;
+            continue;
+          }
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], la[2],
+               fa[3], fa[4], la[5],
+               fa[6], fa[7], la[8],
+               arg, fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many5.c libffi-3.4.2/testsuite/libffi.call/many5.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many5.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many5.c	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,103 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+	float one;
+	int two;
+} s3i;
+
+static double many(double f1,
+		  double f2,
+		  long int i1,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  double f6,
+		  long int i3,
+		  s3i arg,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (i1 + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/f6+(arg.one + arg.two)/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  ffi_type s3i_type;
+  ffi_type *s3i_type_elements[4];
+  s3i arg;
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  s3i_type.size = 0;
+  s3i_type.alignment = 0;
+  s3i_type.type = FFI_TYPE_STRUCT;
+  s3i_type.elements = s3i_type_elements;
+  s3i_type_elements[0] = &ffi_type_float;
+  s3i_type_elements[1] = &ffi_type_sint;
+  s3i_type_elements[2] = NULL;
+
+  arg.one = 1;
+  arg.two = 2;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if(i == 9) {
+            args[i] = &s3i_type;
+	    values[i] = &arg;
+            continue;
+          }
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], la[2],
+               fa[3], fa[4], la[5],
+               fa[6], fa[7], la[8],
+               arg, fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many6.c libffi-3.4.2/testsuite/libffi.call/many6.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many6.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many6.c	2022-11-01 23:26:36.286463049 +0800
@@ -0,0 +1,103 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+	float one;
+	int two;
+} s3i;
+
+static double many(double f1,
+		  double f2,
+		  s3i arg,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  double f6,
+		  long int i3,
+		  double f7,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (arg.one + arg.two + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/f6+f7/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  ffi_type s3i_type;
+  ffi_type *s3i_type_elements[4];
+  s3i arg;
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  s3i_type.size = 0;
+  s3i_type.alignment = 0;
+  s3i_type.type = FFI_TYPE_STRUCT;
+  s3i_type.elements = s3i_type_elements;
+  s3i_type_elements[0] = &ffi_type_float;
+  s3i_type_elements[1] = &ffi_type_sint;
+  s3i_type_elements[2] = NULL;
+
+  arg.one = 1;
+  arg.two = 2;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if(i == 2) {
+            args[i] = &s3i_type;
+	    values[i] = &arg;
+            continue;
+          }
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], arg,
+               fa[3], fa[4], la[5],
+               fa[6], fa[7], la[8],
+               fa[9], fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many7.c libffi-3.4.2/testsuite/libffi.call/many7.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many7.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many7.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,106 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+	unsigned ret;
+	unsigned one;
+	unsigned two;
+} s3i;
+
+static double many(double f1,
+		  double f2,
+		  long int i1,
+		  double f3,
+		  double f4,
+		  long int i2,
+		  double f5,
+		  s3i arg,
+		  long int i3,
+		  double f7,
+		  double f8,
+		  long int i4,
+		  double f9,
+		  double f10,
+		  long int i5,
+		  double f11,
+		  double f12,
+		  long int i6,
+		  double f13)
+{
+  return ((double) (i1 + i2 + i3 + i4 + i5 + i6) + (f1/f2+f3/f4+f5/(arg.ret + arg.one + arg.two)+f7/f8+f9/f10+f11/f12) * f13);
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[19];
+  ffi_type s3i_type;
+  ffi_type *s3i_type_elements[4];
+  s3i arg;
+  void *values[19];
+  double fa[19];
+  long int la[19];
+  double f, ff;
+  int i;
+
+  s3i_type.size = 0;
+  s3i_type.alignment = 0;
+  s3i_type.type = FFI_TYPE_STRUCT;
+  s3i_type.elements = s3i_type_elements;
+  s3i_type_elements[0] = &ffi_type_uint;
+  s3i_type_elements[1] = &ffi_type_uint;
+  s3i_type_elements[2] = &ffi_type_uint;
+  s3i_type_elements[3] = NULL;
+
+  arg.ret = 3;
+  arg.one = 1;
+  arg.two = 2;
+
+  for (i = 0; i < 19; i++)
+    {
+	  if(i == 7) {
+            args[i] = &s3i_type;
+	    values[i] = &arg;
+            continue;
+          }
+	  if( (i - 2) % 3 == 0) {
+	    args[i] = &ffi_type_slong;
+	    la[i] = (long int) i;
+	    values[i] = &la[i];
+	  }
+	  else {
+	    args[i] = &ffi_type_double;
+	    fa[i] = (double) i;
+	    values[i] = &fa[i];
+	  }
+    }
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 19,
+		       &ffi_type_double, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &f, values);
+
+    ff =  many(fa[0], fa[1], la[2],
+               fa[3], fa[4], la[5],
+               fa[6], arg, la[8],
+               fa[9], fa[10], la[11],
+               fa[12], fa[13], la[14],
+               fa[15], fa[16], la[17],
+               fa[18]);
+    if (fabs(f - ff) < FLT_EPSILON)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/many8.c libffi-3.4.2/testsuite/libffi.call/many8.c
--- libffi-3.4.2.ori/testsuite/libffi.call/many8.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/many8.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,92 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+
+typedef struct
+{
+  char c1, c2;
+} Ss;
+
+static int many(
+double a1,
+float a2, 
+Ss a3,
+long double a4,
+float a5,
+short a6,
+int a7,
+float a8)
+{
+return a1 + a2 + a3.c1 + a3.c2 + a4 + a5 + a6 + a7 + a8;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[9];
+  ffi_type Ss_type;
+  ffi_type *Ss_type_elements[4];
+
+  double a1 = 1;
+  float a2 = 2;
+  Ss a3 = {3, 4};
+  long double a4 = 5;
+  float a5 = 6;
+  short a6 = 7;
+  int a7 = 8;
+  float a8 = 9;
+
+  ffi_arg r1;
+  int r2;
+
+  void *values[9];
+
+  Ss_type.size = 0;
+  Ss_type.alignment = 0;
+  Ss_type.type = FFI_TYPE_STRUCT;
+  Ss_type.elements = Ss_type_elements;
+  Ss_type_elements[0] = &ffi_type_uchar;
+  Ss_type_elements[1] = &ffi_type_uchar;
+  Ss_type_elements[2] = NULL;
+
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_float;
+  args[2] = &Ss_type;
+  args[3] = &ffi_type_longdouble;
+  args[4] = &ffi_type_float;
+  args[5] = &ffi_type_sshort;
+  args[6] = &ffi_type_sint;
+  args[7] = &ffi_type_float;
+  args[8] = NULL;
+
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+  values[6] = &a7;
+  values[7] = &a8;
+  values[8] = NULL;
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 8,
+		       &ffi_type_sint, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &r1, values);
+
+    r2 =  many(a1,a2,a3,a4,a5,a6,a7,a8);
+    if ((int)r1 == r2)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct11.c libffi-3.4.2/testsuite/libffi.call/struct11.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct11.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct11.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,72 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts, int *another_ret)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+  *another_ret = 1;
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+  int i = 0;
+  int *ptr = &i;
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+  
+  args[0] = &ts1_type;
+  args[1] = &ffi_type_pointer; 
+  values[0] = &ts1_arg;
+  values[1] = &ptr;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+  CHECK(i == 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct12.c libffi-3.4.2/testsuite/libffi.call/struct12.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct12.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct12.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,72 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(int *another_ret, test_structure_1 ts)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+  *another_ret = 1;
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+  int i = 0;
+  int *ptr = &i;
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+
+  args[0] = &ffi_type_pointer;
+  args[1] = &ts1_type;
+  values[0] = &ptr;
+  values[1] = &ts1_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+  CHECK(i == 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct13.c libffi-3.4.2/testsuite/libffi.call/struct13.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct13.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct13.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,76 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts, test_structure_1 ts1)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+  CHECK (ts1.uc == 2);
+  CHECK (ts1.d == 4.0);
+  CHECK (ts1.ui == 100);
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  test_structure_1 ts1_arg1, ts1_arg2;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+  
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg1;
+  args[1] = &ts1_type;
+  values[1] = &ts1_arg2;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 2,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg1.uc = '\x01';
+  ts1_arg1.d = 3.14159;
+  ts1_arg1.ui = 555;
+
+  ts1_arg2.uc = 2;
+  ts1_arg2.d = 4.0;
+  ts1_arg2.ui = 100;
+
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct14.c libffi-3.4.2/testsuite/libffi.call/struct14.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct14.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct14.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,84 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts, test_structure_1 arg2, test_structure_1 arg3)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+  CHECK (arg2.uc == 2);
+  CHECK (arg2.d == 4.0);
+  CHECK (arg2.ui == 100);
+  CHECK (arg3.uc == 5);
+  CHECK (arg3.d == 6.0);
+  CHECK (arg3.ui == 7);
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  test_structure_1 ts1_arg1, ts1_arg2, ts1_arg3;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+  
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg1;
+  args[1] = &ts1_type;
+  values[1] = &ts1_arg2;
+  args[2] = &ts1_type;
+  values[2] = &ts1_arg3;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 3,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg1.uc = '\x01';
+  ts1_arg1.d = 3.14159;
+  ts1_arg1.ui = 555;
+
+  ts1_arg2.uc = 2;
+  ts1_arg2.d = 4.0;
+  ts1_arg2.ui = 100;
+
+  ts1_arg3.uc = 5;
+  ts1_arg3.d = 6.0;
+  ts1_arg3.ui = 7;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == 3.14159 - 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct15.c libffi-3.4.2/testsuite/libffi.call/struct15.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct15.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct15.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  double d1;
+} test_structure_2;
+
+static test_structure_2 ABI_ATTR struct2(test_structure_2 ts)
+{
+  ts.d1--;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  test_structure_2 ts2_arg;
+  ffi_type ts2_type;
+  ffi_type *ts2_type_elements[2];
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_2 *ts2_result =
+    (test_structure_2 *) malloc (sizeof(test_structure_2));
+
+  ts2_type.size = 0;
+  ts2_type.alignment = 0;
+  ts2_type.type = FFI_TYPE_STRUCT;
+  ts2_type.elements = ts2_type_elements;
+  ts2_type_elements[0] = &ffi_type_double;
+  ts2_type_elements[1] = NULL;
+
+  args[0] = &ts2_type;
+  values[0] = &ts2_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts2_type, args) == FFI_OK);
+  
+  ts2_arg.d1 = 5.55;
+  
+  printf ("%g\n", ts2_arg.d1);
+  
+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
+  
+  printf ("%g\n", ts2_result->d1);
+  
+  CHECK(ts2_result->d1 == (double) 5.55 - 1);
+  
+  free (ts2_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct16.c libffi-3.4.2/testsuite/libffi.call/struct16.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct16.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct16.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  float d1;
+} test_structure_2;
+
+static test_structure_2 ABI_ATTR struct2(test_structure_2 ts)
+{
+  ts.d1--;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  test_structure_2 ts2_arg;
+  ffi_type ts2_type;
+  ffi_type *ts2_type_elements[2];
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_2 *ts2_result =
+    (test_structure_2 *) malloc (sizeof(test_structure_2));
+
+  ts2_type.size = 0;
+  ts2_type.alignment = 0;
+  ts2_type.type = FFI_TYPE_STRUCT;
+  ts2_type.elements = ts2_type_elements;
+  ts2_type_elements[0] = &ffi_type_float;
+  ts2_type_elements[1] = NULL;
+
+  args[0] = &ts2_type;
+  values[0] = &ts2_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts2_type, args) == FFI_OK);
+  
+  ts2_arg.d1 = 5.55;
+  
+  printf ("%g\n", ts2_arg.d1);
+  
+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
+  
+  printf ("%g\n", ts2_result->d1);
+  
+  CHECK(ts2_result->d1 == (float) 5.55 - 1);
+  
+  free (ts2_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct17.c libffi-3.4.2/testsuite/libffi.call/struct17.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct17.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct17.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,60 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  long double d1;
+} test_structure_2;
+
+static test_structure_2 ABI_ATTR struct2(test_structure_2 ts)
+{
+  ts.d1--;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  test_structure_2 ts2_arg;
+  ffi_type ts2_type;
+  ffi_type *ts2_type_elements[2];
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_2 *ts2_result =
+    (test_structure_2 *) malloc (sizeof(test_structure_2));
+
+  ts2_type.size = 0;
+  ts2_type.alignment = 0;
+  ts2_type.type = FFI_TYPE_STRUCT;
+  ts2_type.elements = ts2_type_elements;
+  ts2_type_elements[0] = &ffi_type_longdouble;
+  ts2_type_elements[1] = NULL;
+
+  args[0] = &ts2_type;
+  values[0] = &ts2_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1, &ts2_type, args) == FFI_OK);
+  
+  ts2_arg.d1 = 5.55;
+  
+  printf ("%Lg\n", ts2_arg.d1);
+  
+  ffi_call(&cif, FFI_FN(struct2), ts2_result, values);
+  
+  printf ("%Lg\n", ts2_result->d1);
+  
+  CHECK(ts2_result->d1 == (long double) 5.55 - 1);
+  
+  free (ts2_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct18.c libffi-3.4.2/testsuite/libffi.call/struct18.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct18.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct18.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,67 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  long double d;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[4];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_longdouble;
+  ts1_type_elements[2] = &ffi_type_uint;
+  ts1_type_elements[3] = NULL;
+  
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == (long double) 3.14159 - 1);
+ 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct19.c libffi-3.4.2/testsuite/libffi.call/struct19.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct19.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct19.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,111 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  long double b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static int
+test_fn (int n, struct small_tag s1, struct large_tag l, struct small_tag s2)
+{
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, (unsigned) s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, (unsigned) s2.b);
+  return n + 1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  ffi_arg res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_longdouble;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &ffi_type_sint, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+
+  return 0;
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct20.c libffi-3.4.2/testsuite/libffi.call/struct20.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct20.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct20.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,113 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  long double b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static struct small_tag
+test_fn (int n, struct small_tag s1, struct large_tag l, struct small_tag s2)
+{
+  printf ("%d %u %u %u %u %u %u %u %u %u\n", n, s1.a, (unsigned) s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, (unsigned) s2.b);
+  s1.a += s2.a;
+  s1.b += s2.b;
+  return s1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  struct small_tag res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_longdouble;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4, &s_type, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d %d\n", res.a, (unsigned) res.b);
+  /* { dg-output "\nres: 12 14" } */
+
+  return 0;
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct21.c libffi-3.4.2/testsuite/libffi.call/struct21.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct21.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct21.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,70 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+typedef struct
+{
+  unsigned char uc;
+  double d;
+  long double ld;
+  unsigned int ui;
+} test_structure_1;
+
+static test_structure_1 ABI_ATTR struct1(test_structure_1 ts)
+{
+  ts.uc++;
+  ts.d--;
+  ts.ui++;
+  ts.ld += ts.uc + ts.d + ts.ui;
+  return ts;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type ts1_type;
+  ffi_type *ts1_type_elements[5];
+
+  test_structure_1 ts1_arg;
+
+  /* This is a hack to get a properly aligned result buffer */
+  test_structure_1 *ts1_result =
+    (test_structure_1 *) malloc (sizeof(test_structure_1));
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+  ts1_type_elements[0] = &ffi_type_uchar;
+  ts1_type_elements[1] = &ffi_type_double;
+  ts1_type_elements[2] = &ffi_type_longdouble;
+  ts1_type_elements[3] = &ffi_type_uint;
+  ts1_type_elements[4] = NULL;
+  
+  args[0] = &ts1_type;
+  values[0] = &ts1_arg;
+  
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 1,
+		     &ts1_type, args) == FFI_OK);
+  
+  ts1_arg.uc = '\x01';
+  ts1_arg.d = 3.14159;
+  ts1_arg.ld = 5.0;
+  ts1_arg.ui = 555;
+
+  ffi_call(&cif, FFI_FN(struct1), ts1_result, values);
+  
+  CHECK(ts1_result->ui == 556);
+  CHECK(ts1_result->d == (double) 3.14159 - 1);
+  CHECK((double)ts1_result->ld == (ts1_arg.uc + 1) + (ts1_arg.d - 1) + (double)ts1_arg.ld + (ts1_arg.ui + 1)); 
+  free (ts1_result);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/struct22.c libffi-3.4.2/testsuite/libffi.call/struct22.c
--- libffi-3.4.2.ori/testsuite/libffi.call/struct22.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/struct22.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,81 @@
+/* Area:	ffi_call
+   Purpose:	Check structures.
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+struct Ls {
+  double d;
+  long double ld;
+  unsigned char c1, c2;
+  int i;
+  unsigned char c3;
+};
+
+static struct Ls ABI_ATTR
+struct1 (double a1, int a2, struct Ls a3, int a4, struct Ls a5)
+{
+  int res = a1 + a2 + a3.d + a3.ld + a3.c1 + a3.c2 + a3.i + a3.c3 + a4 + a5.d + a5.ld + a5.c1 + a5.c2 + a5.i + a5.c3;
+  struct Ls ret = {res, res + 1, res + 2, res + 3, res + 4, res + 5};
+  return ret;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+  ffi_type Ls_type;
+  ffi_type *Ls_type_elements[7];
+
+  double a1 = 1;
+  int a2 = 2;
+  struct Ls a3 = {3, 4, 5, 6, 7, 8};
+  int a4 = 9;
+  struct Ls a5 = {10, 11, 12, 13, 14, 15};
+
+  struct Ls r1, r2;
+
+  Ls_type.size = 0;
+  Ls_type.alignment = 0;
+  Ls_type.type = FFI_TYPE_STRUCT;
+  Ls_type.elements = Ls_type_elements;
+  Ls_type_elements[0] = &ffi_type_double;
+  Ls_type_elements[1] = &ffi_type_longdouble;
+  Ls_type_elements[2] = &ffi_type_uchar;
+  Ls_type_elements[3] = &ffi_type_uchar;
+  Ls_type_elements[4] = &ffi_type_sint;
+  Ls_type_elements[5] = &ffi_type_uchar;
+  Ls_type_elements[6] = NULL;
+  
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_sint;
+  args[2] = &Ls_type;
+  args[3] = &ffi_type_sint;
+  args[4] = &Ls_type;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+
+  r1 = struct1 (a1, a2, a3, a4, a5);
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, ABI_NUM, 5,
+		     &Ls_type, args) == FFI_OK);
+  
+  ffi_call(&cif, FFI_FN(struct1), &r2, values);
+
+  CHECK(r1.d == r2.d);
+  CHECK(r1.ld == r2.ld);
+  CHECK(r1.c1 == r2.c1);
+  CHECK(r1.c2 == r2.c2);
+  CHECK(r1.i == r2.i);
+  CHECK(r1.c3 == r2.c3);
+
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/va_3.c libffi-3.4.2/testsuite/libffi.call/va_3.c
--- libffi-3.4.2.ori/testsuite/libffi.call/va_3.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/va_3.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,106 @@
+/* Area:	ffi_call
+   Purpose:	Check return value double, with many arguments
+   Limitations:	none.
+   PR:		none.
+   Originator:	From the original ffitest.c  */
+
+/* { dg-do run } */
+#include "ffitest.h"
+
+#include <stdlib.h>
+#include <float.h>
+#include <math.h>
+#include <stdarg.h>
+
+typedef struct
+{
+  char c1, c2;
+} Ss;
+
+static int many(double a1, ...)
+{
+  va_list ap;
+  float a2;
+  Ss a3;
+  long double a4;
+  float a5;
+  short a6;
+  int a7;
+  float a8;
+  int r;
+  
+  va_start (ap, a1);
+  a2 = va_arg (ap, double);
+  a3 = va_arg (ap, Ss);
+  a4 = va_arg (ap, long double);
+  a5 = va_arg (ap, double);
+  a6 = va_arg (ap, int);
+  a7 = va_arg (ap, int);
+  a8 = va_arg (ap, double);
+  va_end (ap);
+
+r = a1 + a2 + a3.c1 + a3.c2 + a4 + a5 + a6 + a7 + a8;
+return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[9];
+  ffi_type Ss_type;
+  ffi_type *Ss_type_elements[4];
+
+  double a1 = 1;
+  float a2 = 2;
+  Ss a3 = {3, 4};
+  long double a4 = 5;
+  float a5 = 6;
+  short a6 = 7;
+  int a7 = 8;
+  float a8 = 9;
+
+  ffi_arg r1;
+  int r2;
+
+  void *values[9];
+
+  Ss_type.size = 0;
+  Ss_type.alignment = 0;
+  Ss_type.type = FFI_TYPE_STRUCT;
+  Ss_type.elements = Ss_type_elements;
+  Ss_type_elements[0] = &ffi_type_uchar;
+  Ss_type_elements[1] = &ffi_type_uchar;
+  Ss_type_elements[2] = NULL;
+
+  args[0] = &ffi_type_double;
+  args[1] = &ffi_type_float;
+  args[2] = &Ss_type;
+  args[3] = &ffi_type_longdouble;
+  args[4] = &ffi_type_float;
+  args[5] = &ffi_type_sshort;
+  args[6] = &ffi_type_sint;
+  args[7] = &ffi_type_float;
+  args[8] = NULL;
+
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+  values[6] = &a7;
+  values[7] = &a8;
+  values[8] = NULL;
+
+    /* Initialize the cif */
+    CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 8,
+		       &ffi_type_sint, args) == FFI_OK);
+
+    ffi_call(&cif, FFI_FN(many), &r1, values);
+
+    r2 = many(a1,a2,a3,a4,a5,a6,a7,a8);
+    if ((int)r1 == r2)
+      exit(0);
+    else
+      abort();
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/va_struct4.c libffi-3.4.2/testsuite/libffi.call/va_struct4.c
--- libffi-3.4.2.ori/testsuite/libffi.call/va_struct4.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/va_struct4.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,121 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  long double b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static int
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, (unsigned) s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, (unsigned) s2.b);
+  va_end (ap);
+  return n + 1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  ffi_arg res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_longdouble;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &ffi_type_sint, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d\n", (int) res);
+  /* { dg-output "\nres: 42" } */
+
+  return 0;
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.call/va_struct5.c libffi-3.4.2/testsuite/libffi.call/va_struct5.c
--- libffi-3.4.2.ori/testsuite/libffi.call/va_struct5.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.call/va_struct5.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,123 @@
+/* Area:		ffi_call
+   Purpose:		Test passing struct in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator: ARM Ltd. */
+
+/* { dg-do run } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+
+#include "ffitest.h"
+#include <stdarg.h>
+
+struct small_tag
+{
+  unsigned char a;
+  long double b;
+};
+
+struct large_tag
+{
+  unsigned a;
+  unsigned b;
+  unsigned c;
+  unsigned d;
+  unsigned e;
+};
+
+static struct small_tag
+test_fn (int n, ...)
+{
+  va_list ap;
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l;
+
+  va_start (ap, n);
+  s1 = va_arg (ap, struct small_tag);
+  l = va_arg (ap, struct large_tag);
+  s2 = va_arg (ap, struct small_tag);
+  printf ("%u %u %u %u %u %u %u %u %u\n", s1.a, (unsigned) s1.b, l.a, l.b, l.c, l.d, l.e,
+	  s2.a, (unsigned) s2.b);
+  va_end (ap);
+  s1.a += s2.a;
+  s1.b += s2.b;
+  return s1;
+}
+
+int
+main (void)
+{
+  ffi_cif cif;
+  void* args[5];
+  ffi_type* arg_types[5];
+
+  ffi_type s_type;
+  ffi_type *s_type_elements[3];
+
+  ffi_type l_type;
+  ffi_type *l_type_elements[6];
+
+  struct small_tag s1;
+  struct small_tag s2;
+  struct large_tag l1;
+
+  int n;
+  struct small_tag res;
+
+  s_type.size = 0;
+  s_type.alignment = 0;
+  s_type.type = FFI_TYPE_STRUCT;
+  s_type.elements = s_type_elements;
+
+  s_type_elements[0] = &ffi_type_uchar;
+  s_type_elements[1] = &ffi_type_longdouble;
+  s_type_elements[2] = NULL;
+
+  l_type.size = 0;
+  l_type.alignment = 0;
+  l_type.type = FFI_TYPE_STRUCT;
+  l_type.elements = l_type_elements;
+
+  l_type_elements[0] = &ffi_type_uint;
+  l_type_elements[1] = &ffi_type_uint;
+  l_type_elements[2] = &ffi_type_uint;
+  l_type_elements[3] = &ffi_type_uint;
+  l_type_elements[4] = &ffi_type_uint;
+  l_type_elements[5] = NULL;
+
+  arg_types[0] = &ffi_type_sint;
+  arg_types[1] = &s_type;
+  arg_types[2] = &l_type;
+  arg_types[3] = &s_type;
+  arg_types[4] = NULL;
+
+  CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 4, &s_type, arg_types) == FFI_OK);
+
+  s1.a = 5;
+  s1.b = 6;
+
+  l1.a = 10;
+  l1.b = 11;
+  l1.c = 12;
+  l1.d = 13;
+  l1.e = 14;
+
+  s2.a = 7;
+  s2.b = 8;
+
+  n = 41;
+
+  args[0] = &n;
+  args[1] = &s1;
+  args[2] = &l1;
+  args[3] = &s2;
+  args[4] = NULL;
+
+  ffi_call(&cif, FFI_FN(test_fn), &res, args);
+  /* { dg-output "5 6 10 11 12 13 14 7 8" } */
+  printf("res: %d %d\n", res.a, (unsigned) res.b);
+  /* { dg-output "\nres: 12 14" } */
+
+  return 0;
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.closures/cls_float_va.c libffi-3.4.2/testsuite/libffi.closures/cls_float_va.c
--- libffi-3.4.2.ori/testsuite/libffi.closures/cls_float_va.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.closures/cls_float_va.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,61 @@
+/* Area:		ffi_call, closure_call
+   Purpose:		Test floats passed in variable argument lists.
+   Limitations:	none.
+   PR:			none.
+   Originator:	Blake Chaffin 6/6/2007	 */
+
+/* { dg-do run { xfail strongarm*-*-* xscale*-*-* } } */
+/* { dg-output "" { xfail avr32*-*-* } } */
+/* { dg-output "" { xfail mips-sgi-irix6* } } PR libffi/46660 */
+
+#include "ffitest.h"
+
+static void
+cls_float_va_fn(ffi_cif* cif __UNUSED__, void* resp, 
+		 void** args, void* userdata __UNUSED__)
+{
+	char*	format		= *(char**)args[0];
+	float	floatValue	= *(float*)args[1];
+
+	*(ffi_arg*)resp = printf(format, floatValue);
+}
+
+int main (void)
+{
+	ffi_cif cif;
+        void *code;
+	ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+	void* args[3];
+	ffi_type* arg_types[3];
+
+	char*	format		= "%.1f\n";
+	float	floatArg	= 7;
+	ffi_arg	res			= 0;
+
+	arg_types[0] = &ffi_type_pointer;
+	arg_types[1] = &ffi_type_float;
+	arg_types[2] = NULL;
+
+	/* This printf call is variadic */
+	CHECK(ffi_prep_cif_var(&cif, FFI_DEFAULT_ABI, 1, 2, &ffi_type_sint,
+			       arg_types) == FFI_OK);
+
+	args[0] = &format;
+	args[1] = &floatArg;
+	args[2] = NULL;
+
+	ffi_call(&cif, FFI_FN(printf), &res, args);
+	/* { dg-output "7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+
+	CHECK(ffi_prep_closure_loc(pcl, &cif, cls_float_va_fn, NULL,
+				   code) == FFI_OK);
+
+	res = ((int(*)(char*, ...))(code))(format, floatArg);
+	/* { dg-output "\n7.0" } */
+	printf("res: %d\n", (int) res);
+	/* { dg-output "\nres: 4" } */
+
+	exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_double.c libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "cls_complex_struct1.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_float.c libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "cls_complex_struct1.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1.inc libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,66 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+typedef struct Cs {
+  _Complex T_C_TYPE x;
+} Cs;
+
+Cs gc;
+
+void
+closure_test_fn(Cs p)
+{
+  printf("%.1f,%.1f\n",
+	 T_CONV creal (p.x), T_CONV cimag (p.x));
+  gc = p;
+}
+
+void
+closure_test_gn(ffi_cif* cif __UNUSED__, void* resp __UNUSED__,
+		void** args, void* userdata __UNUSED__)
+{
+  closure_test_fn(*(Cs*)args[0]);
+}
+
+int main(int argc __UNUSED__, char** argv __UNUSED__)
+{
+  ffi_cif cif;
+
+  void *code;
+  ffi_closure *pcl = ffi_closure_alloc(sizeof(ffi_closure), &code);
+  ffi_type *cl_arg_types[1];
+
+  ffi_type ts1_type;
+  ffi_type* ts1_type_elements[4];
+
+  Cs arg = { 1.0 + 11.0 * I};
+
+  ts1_type.size = 0;
+  ts1_type.alignment = 0;
+  ts1_type.type = FFI_TYPE_STRUCT;
+  ts1_type.elements = ts1_type_elements;
+
+  ts1_type_elements[0] = &T_FFI_TYPE;
+  ts1_type_elements[1] = NULL;
+
+  cl_arg_types[0] = &ts1_type;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 1,
+		     &ffi_type_void, cl_arg_types) == FFI_OK);
+
+  CHECK(ffi_prep_closure_loc(pcl, &cif, closure_test_gn, NULL, code) == FFI_OK);
+
+  gc.x = 0.0 + 0.0 * I;
+  ((void*(*)(Cs))(code))(arg);
+  /* { dg-output "1.0,11.0i\n" } */
+  CHECK (gc.x == arg.x);
+
+  gc.x = 0.0 + 0.0 * I;
+  closure_test_fn(arg);
+  /* { dg-output "1.0,11.0i\n" } */
+  CHECK (gc.x == arg.x);
+
+  return 0;
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_longdouble.c libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/cls_complex_struct1_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/cls_complex_struct1_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "cls_complex_struct1.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_double.c libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "return_complex_struct.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_float.c libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "return_complex_struct.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct.inc libffi-3.4.2/testsuite/libffi.complex/return_complex_struct.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/return_complex_struct.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,58 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+
+typedef struct Cs {
+  _Complex T_C_TYPE x;
+} Cs;
+
+static Cs return_c(_Complex T_C_TYPE c1, float fl2, unsigned int in3, _Complex T_C_TYPE c4)
+{
+  Cs r = {c1 + fl2 + in3 + c4};
+  return r;
+}
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  Cs rc, rc2;
+  _Complex T_C_TYPE c1, c4;
+  float fl2;
+  unsigned int in3;
+  args[0] = &T_FFI_TYPE;
+  args[1] = &ffi_type_float;
+  args[2] = &ffi_type_uint;
+  args[3] = &T_FFI_TYPE;
+  values[0] = &c1;
+  values[1] = &fl2;
+  values[2] = &in3;
+  values[3] = &c4;
+
+  ffi_type Cs_type;
+  ffi_type* Cs_type_elements[4];
+  Cs_type.size = 0;
+  Cs_type.alignment = 0;
+  Cs_type.type = FFI_TYPE_STRUCT;
+  Cs_type.elements = Cs_type_elements;
+
+  Cs_type_elements[0] = &T_FFI_TYPE;
+  Cs_type_elements[1] = NULL;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 4,
+		     &Cs_type, args) == FFI_OK);
+  c1 = 127.0 + 255.0 * I;
+  fl2 = 128.0;
+  in3 = 255;
+  c4 = 512.7 + 1024.1 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &rc, values);
+  rc2 = return_c(c1, fl2, in3, c4);
+  printf ("%f,%fi vs %f,%fi\n",
+	  T_CONV creal (rc.x), T_CONV cimag (rc.x),
+	  T_CONV creal (rc2.x), T_CONV cimag (rc2.x));
+  CHECK(rc.x == rc2.x);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_longdouble.c libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/return_complex_struct_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/return_complex_struct_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,4 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "return_complex_struct.inc"
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_non_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_non_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,71 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex long double
+return_c(signed int a1,
+//...
+_Complex long double a2,
+_Complex T_C_TYPE a4,
+signed int a5,
+_Complex long double a6
+)
+{
+//  va_list ap;
+//  _Complex long double a2;
+//  _Complex T_C_TYPE a4;
+//  signed int a5;
+//  _Complex long double a6;
+//  va_start (ap, a1);
+//  a2 = va_arg (ap, _Complex long double);
+//  a4 = va_arg (ap, _Complex T_C_TYPE);
+//  a5 = va_arg (ap, signed int);
+//  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex long double r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &T_FFI_TYPE;
+  args[3] = &ffi_type_sint;
+  args[4] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a4;
+  values[3] = &a5;
+  values[4] = &a6;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
+		     &ffi_type_complex_longdouble, args) == FFI_OK);
+//  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 5,
+//			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va1_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va1_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_non_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_non_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_non_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex float
+return_c(signed int a1,
+//...
+_Complex long double a2,
+signed int a3,
+_Complex T_C_TYPE a4,
+signed int a5,
+_Complex long double a6
+)
+{
+//  va_list ap;
+//  _Complex long double a2;
+//  signed int a3;
+//  _Complex T_C_TYPE a4;
+//  signed int a5;
+//  _Complex long double a6;
+//  va_start (ap, a1);
+//  a2 = va_arg (ap, _Complex long double);
+//  a3 = va_arg (ap, signed int);
+//  a4 = va_arg (ap, _Complex T_C_TYPE);
+//  a5 = va_arg (ap, signed int);
+//  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex float r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+		     &ffi_type_complex_float, args) == FFI_OK);
+//  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+//			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va2_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va2_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_non_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_non_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_non_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex float
+return_c(signed int a1,
+//...
+_Complex float a2,
+signed int a3,
+_Complex T_C_TYPE a4,
+signed int a5,
+_Complex long double a6
+)
+{
+//  va_list ap;
+//  _Complex long double a2;
+//  signed int a3;
+//  _Complex T_C_TYPE a4;
+//  signed int a5;
+//  _Complex long double a6;
+//  va_start (ap, a1);
+//  a2 = va_arg (ap, _Complex long double);
+//  a3 = va_arg (ap, signed int);
+//  a4 = va_arg (ap, _Complex T_C_TYPE);
+//  a5 = va_arg (ap, signed int);
+//  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex float r1, r2;
+
+  signed int a1;
+  _Complex float a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_float;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+		     &ffi_type_complex_float, args) == FFI_OK);
+//  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+//			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va3_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va3_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_non_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_non_va.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_non_va.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex long double
+return_c(signed int a1,
+//...
+_Complex long double a2,
+signed int a3,
+_Complex T_C_TYPE a4,
+signed int a5,
+_Complex long double a6
+)
+{
+//  va_list ap;
+//  _Complex long double a2;
+//  signed int a3;
+//  _Complex T_C_TYPE a4;
+//  signed int a5;
+//  _Complex long double a6;
+//  va_start (ap, a1);
+//  a2 = va_arg (ap, _Complex long double);
+//  a3 = va_arg (ap, signed int);
+//  a4 = va_arg (ap, _Complex T_C_TYPE);
+//  a5 = va_arg (ap, signed int);
+//  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex long double r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+		     &ffi_type_complex_longdouble, args) == FFI_OK);
+//  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+//			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_non_va_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_non_va_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_non_va.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_va1.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va1.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,71 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex long double
+return_c(signed int a1,
+...
+//_Complex long double a2,
+//_Complex T_C_TYPE a4,
+//signed int a5,
+//_Complex long double a6
+)
+{
+  va_list ap;
+  _Complex long double a2;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+  va_start (ap, a1);
+  a2 = va_arg (ap, _Complex long double);
+  a4 = va_arg (ap, _Complex T_C_TYPE);
+  a5 = va_arg (ap, signed int);
+  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex long double r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &T_FFI_TYPE;
+  args[3] = &ffi_type_sint;
+  args[4] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a4;
+  values[3] = &a5;
+  values[4] = &a6;
+
+  /* Initialize the cif */
+//  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 5,
+//		     &ffi_type_complex_longdouble, args) == FFI_OK);
+  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 5,
+			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va1_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va1_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_va1.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_va2.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va2.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex float
+return_c(signed int a1,
+...
+//_Complex long double a2,
+//signed int a3,
+//_Complex T_C_TYPE a4,
+//signed int a5,
+//_Complex long double a6
+)
+{
+  va_list ap;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+  va_start (ap, a1);
+  a2 = va_arg (ap, _Complex long double);
+  a3 = va_arg (ap, signed int);
+  a4 = va_arg (ap, _Complex T_C_TYPE);
+  a5 = va_arg (ap, signed int);
+  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex float r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+//  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+//		     &ffi_type_complex_longdouble, args) == FFI_OK);
+  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+			  &ffi_type_complex_float, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va2_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va2_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_va2.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_va3.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va3.inc	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex float
+return_c(signed int a1,
+...
+//_Complex long double a2,
+//signed int a3,
+//_Complex T_C_TYPE a4,
+//signed int a5,
+//_Complex long double a6
+)
+{
+  va_list ap;
+  _Complex float a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+  va_start (ap, a1);
+  a2 = va_arg (ap, _Complex float);
+  a3 = va_arg (ap, signed int);
+  a4 = va_arg (ap, _Complex T_C_TYPE);
+  a5 = va_arg (ap, signed int);
+  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex float r1, r2;
+
+  signed int a1;
+  _Complex float a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_float;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+//  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+//		     &ffi_type_complex_longdouble, args) == FFI_OK);
+  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+			  &ffi_type_complex_float, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va3_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va3_longdouble.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_va3.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_double.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va_double.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_double.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va_double.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_double.inc"
+#include "test_complex_va.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_float.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va_float.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_float.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va_float.c	2022-11-01 23:26:36.290463089 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_float.inc"
+#include "test_complex_va.inc"
+
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va.inc libffi-3.4.2/testsuite/libffi.complex/test_complex_va.inc
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va.inc	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va.inc	2022-11-01 23:26:36.294463129 +0800
@@ -0,0 +1,78 @@
+/* -*-c-*- */
+#include "ffitest.h"
+#include <complex.h>
+#include <stdarg.h>
+
+_Complex long double
+return_c(signed int a1,
+...
+//_Complex long double a2,
+//signed int a3,
+//_Complex T_C_TYPE a4,
+//signed int a5,
+//_Complex long double a6
+)
+{
+  va_list ap;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+  va_start (ap, a1);
+  a2 = va_arg (ap, _Complex long double);
+  a3 = va_arg (ap, signed int);
+  a4 = va_arg (ap, _Complex T_C_TYPE);
+  a5 = va_arg (ap, signed int);
+  a6 = va_arg (ap, _Complex long double);
+
+  volatile _Complex long double r = a1 + a2 + a3 + a4 + a5 + a6;
+  return r;
+}
+
+int main (void)
+{
+  ffi_cif cif;
+  ffi_type *args[MAX_ARGS];
+  void *values[MAX_ARGS];
+
+  _Complex long double r1, r2;
+
+  signed int a1;
+  _Complex long double a2;
+  signed int a3;
+  _Complex T_C_TYPE a4;
+  signed int a5;
+  _Complex long double a6;
+
+  args[0] = &ffi_type_sint;
+  args[1] = &ffi_type_complex_longdouble;
+  args[2] = &ffi_type_sint;
+  args[3] = &T_FFI_TYPE;
+  args[4] = &ffi_type_sint;
+  args[5] = &ffi_type_complex_longdouble;
+  values[0] = &a1;
+  values[1] = &a2;
+  values[2] = &a3;
+  values[3] = &a4;
+  values[4] = &a5;
+  values[5] = &a6;
+
+  /* Initialize the cif */
+//  CHECK(ffi_prep_cif(&cif, FFI_DEFAULT_ABI, 6,
+//		     &ffi_type_complex_longdouble, args) == FFI_OK);
+  CHECK(ffi_prep_cif_var (&cif, FFI_DEFAULT_ABI, 1, 6,
+			  &ffi_type_complex_longdouble, args) == FFI_OK);
+
+  a1 = 5;
+  a2 = 127.0 + 255.0 * I;
+  a3 = 6;
+  a4 = 512.7 + 1024.1 * I;
+  a5 = 7;
+  a6 = 89 + 12 * I;
+
+  ffi_call(&cif, FFI_FN(return_c), &r1, values);
+  r2 = return_c(a1, a2, a3, a4, a5, a6);
+  CHECK(r1 == r2);
+  exit(0);
+}
diff -urN libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_longdouble.c libffi-3.4.2/testsuite/libffi.complex/test_complex_va_longdouble.c
--- libffi-3.4.2.ori/testsuite/libffi.complex/test_complex_va_longdouble.c	1970-01-01 08:00:00.000000000 +0800
+++ libffi-3.4.2/testsuite/libffi.complex/test_complex_va_longdouble.c	2022-11-01 23:26:36.294463129 +0800
@@ -0,0 +1,5 @@
+/* { dg-do run } */
+
+#include "complex_defs_longdouble.inc"
+#include "test_complex_va.inc"
+
