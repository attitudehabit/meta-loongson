diff -urN rustc-1.65.0-src.ori/compiler/rustc_codegen_gcc/example/alloc_system.rs rustc-1.65.0-src/compiler/rustc_codegen_gcc/example/alloc_system.rs
--- rustc-1.65.0-src.ori/compiler/rustc_codegen_gcc/example/alloc_system.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_codegen_gcc/example/alloc_system.rs	2022-12-03 17:24:35.058805290 +0800
@@ -21,6 +21,7 @@
 const MIN_ALIGN: usize = 8;
 #[cfg(all(any(target_arch = "x86_64",
               target_arch = "aarch64",
+              target_arch = "loongarch64",
               target_arch = "mips64",
               target_arch = "s390x",
               target_arch = "sparc64")))]
diff -urN rustc-1.65.0-src.ori/compiler/rustc_codegen_ssa/src/back/metadata.rs rustc-1.65.0-src/compiler/rustc_codegen_ssa/src/back/metadata.rs
--- rustc-1.65.0-src.ori/compiler/rustc_codegen_ssa/src/back/metadata.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_codegen_ssa/src/back/metadata.rs	2022-12-03 17:25:23.928008162 +0800
@@ -116,6 +116,7 @@
         "powerpc64" => Architecture::PowerPc64,
         "riscv32" => Architecture::Riscv32,
         "riscv64" => Architecture::Riscv64,
+        "loongarch64" => Architecture::LoongArch64,
         "sparc64" => Architecture::Sparc64,
         "avr" => Architecture::Avr,
         "msp430" => Architecture::Msp430,
diff -urN rustc-1.65.0-src.ori/compiler/rustc_lint/src/builtin.rs rustc-1.65.0-src/compiler/rustc_lint/src/builtin.rs
--- rustc-1.65.0-src.ori/compiler/rustc_lint/src/builtin.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_lint/src/builtin.rs	2022-12-03 17:24:35.058805290 +0800
@@ -3055,11 +3055,6 @@
     /// ```rust,compile_fail
     /// use std::arch::asm;
     ///
-    /// fn main() {
-    ///     unsafe {
-    ///         asm!("foo: bar");
-    ///     }
-    /// }
     /// ```
     ///
     /// {{produces}}
diff -urN rustc-1.65.0-src.ori/compiler/rustc_llvm/build.rs rustc-1.65.0-src/compiler/rustc_llvm/build.rs
--- rustc-1.65.0-src.ori/compiler/rustc_llvm/build.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_llvm/build.rs	2022-12-03 17:24:35.058805290 +0800
@@ -10,6 +10,7 @@
     "aarch64",
     "amdgpu",
     "avr",
+    "loongarch",
     "m68k",
     "mips",
     "powerpc",
diff -urN rustc-1.65.0-src.ori/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp rustc-1.65.0-src/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp
--- rustc-1.65.0-src.ori/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp	2022-12-03 17:24:35.058805290 +0800
@@ -319,6 +319,12 @@
 #define SUBTARGET_RISCV
 #endif
 
+#ifdef LLVM_COMPONENT_LOONGARCH
+#define SUBTARGET_LOONGARCH SUBTARGET(LoongArch)
+#else
+#define SUBTARGET_LOONGARCH
+#endif
+
 #ifdef LLVM_COMPONENT_SPARC
 #define SUBTARGET_SPARC SUBTARGET(Sparc)
 #else
@@ -344,6 +350,7 @@
   SUBTARGET_SPARC                                                              \
   SUBTARGET_HEXAGON                                                            \
   SUBTARGET_RISCV                                                              \
+  SUBTARGET_LOONGARCH                                                          \
 
 #define SUBTARGET(x)                                                           \
   namespace llvm {                                                             \
@@ -485,18 +492,18 @@
   const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();
   const Triple::ArchType HostArch = Triple(sys::getProcessTriple()).getArch();
   const Triple::ArchType TargetArch = Target->getTargetTriple().getArch();
-  const ArrayRef<SubtargetSubTypeKV> CPUTable = MCInfo->getCPUTable();
-  unsigned MaxCPULen = getLongestEntryLength(CPUTable);
+//  const ArrayRef<SubtargetSubTypeKV> CPUTable = MCInfo->getCPUTable();
+//  unsigned MaxCPULen = getLongestEntryLength(CPUTable);
 
   printf("Available CPUs for this target:\n");
-  if (HostArch == TargetArch) {
+  /*if (HostArch == TargetArch) {
     const StringRef HostCPU = sys::getHostCPUName();
     printf("    %-*s - Select the CPU of the current host (currently %.*s).\n",
       MaxCPULen, "native", (int)HostCPU.size(), HostCPU.data());
   }
   for (auto &CPU : CPUTable)
     printf("    %-*s\n", MaxCPULen, CPU.Key);
-  printf("\n");
+  printf("\n");*/
 }
 
 extern "C" size_t LLVMRustGetTargetFeaturesCount(LLVMTargetMachineRef TM) {
diff -urN rustc-1.65.0-src.ori/compiler/rustc_llvm/src/lib.rs rustc-1.65.0-src/compiler/rustc_llvm/src/lib.rs
--- rustc-1.65.0-src.ori/compiler/rustc_llvm/src/lib.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_llvm/src/lib.rs	2022-12-03 17:24:35.058805290 +0800
@@ -103,6 +103,14 @@
         LLVMInitializeM68kAsmParser
     );
     init_target!(
+        llvm_component = "loongarch",
+        LLVMInitializeLoongArchTargetInfo,
+        LLVMInitializeLoongArchTarget,
+        LLVMInitializeLoongArchTargetMC,
+        LLVMInitializeLoongArchAsmPrinter,
+        LLVMInitializeLoongArchAsmParser
+    );
+    init_target!(
         llvm_component = "mips",
         LLVMInitializeMipsTargetInfo,
         LLVMInitializeMipsTarget,
diff -urN rustc-1.65.0-src.ori/compiler/rustc_target/src/abi/call/loongarch64.rs rustc-1.65.0-src/compiler/rustc_target/src/abi/call/loongarch64.rs
--- rustc-1.65.0-src.ori/compiler/rustc_target/src/abi/call/loongarch64.rs	1970-01-01 08:00:00.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_target/src/abi/call/loongarch64.rs	2022-12-03 17:24:35.058805290 +0800
@@ -0,0 +1,347 @@
+use crate::abi::call::{ArgAbi, ArgExtension, CastTarget, FnAbi, PassMode, Reg, RegKind, Uniform};
+use crate::abi::{
+    self, Abi, FieldsShape, HasDataLayout, Size, TyAndLayout, TyAbiInterface,
+};
+//use crate::spec::HasTargetSpec;
+
+#[derive(Copy, Clone)]
+enum RegPassKind {
+    Float(Reg),
+    Integer(Reg),
+    Unknown,
+}
+
+#[derive(Copy, Clone)]
+enum FloatConv {
+    FloatPair(Reg, Reg),
+    Float(Reg),
+    MixedPair(Reg, Reg),
+}
+
+#[derive(Copy, Clone)]
+struct CannotUseFpConv;
+
+fn is_loongarch_aggregate<'a, Ty>(arg: &ArgAbi<'a, Ty>) -> bool {
+    match arg.layout.abi {
+        Abi::Vector { .. } => true,
+        _ => arg.layout.is_aggregate(),
+    }
+}
+
+fn should_use_fp_conv_helper<'a, Ty, C>(
+    cx: &C,
+    arg_layout: &TyAndLayout<'a, Ty>,
+    xlen: u64,
+    flen: u64,
+    field1_kind: &mut RegPassKind,
+    field2_kind: &mut RegPassKind,
+) -> Result<(), CannotUseFpConv>
+where
+    Ty: TyAbiInterface<'a, C> + Copy,
+    C: HasDataLayout,
+{
+    match arg_layout.abi {
+        Abi::Scalar(scalar) => match scalar.primitive() {
+            abi::Int(..) | abi::Pointer => {
+                if arg_layout.size.bits() > xlen {
+                    return Err(CannotUseFpConv);
+                }
+                match (*field1_kind, *field2_kind) {
+                    (RegPassKind::Unknown, _) => {
+                        *field1_kind = RegPassKind::Integer(Reg {
+                            kind: RegKind::Integer,
+                            size: arg_layout.size,
+                        });
+                    }
+                    (RegPassKind::Float(_), RegPassKind::Unknown) => {
+                        *field2_kind = RegPassKind::Integer(Reg {
+                            kind: RegKind::Integer,
+                            size: arg_layout.size,
+                        });
+                    }
+                    _ => return Err(CannotUseFpConv),
+                }
+            }
+            abi::F32 | abi::F64 => {
+                if arg_layout.size.bits() > flen {
+                    return Err(CannotUseFpConv);
+                }
+                match (*field1_kind, *field2_kind) {
+                    (RegPassKind::Unknown, _) => {
+                        *field1_kind =
+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });
+                    }
+                    (_, RegPassKind::Unknown) => {
+                        *field2_kind =
+                            RegPassKind::Float(Reg { kind: RegKind::Float, size: arg_layout.size });
+                    }
+                    _ => return Err(CannotUseFpConv),
+                }
+            }
+        },
+        Abi::Vector { .. } | Abi::Uninhabited => return Err(CannotUseFpConv),
+        Abi::ScalarPair(..) | Abi::Aggregate { .. } => match arg_layout.fields {
+            FieldsShape::Primitive => {
+                unreachable!("aggregates can't have `FieldsShape::Primitive`")
+            }
+            FieldsShape::Union(_) => {
+                if !arg_layout.is_zst() {
+                    return Err(CannotUseFpConv);
+                }
+            }
+            FieldsShape::Array { count, .. } => {
+                for _ in 0..count {
+                    let elem_layout = arg_layout.field(cx, 0);
+                    should_use_fp_conv_helper(
+                        cx,
+                        &elem_layout,
+                        xlen,
+                        flen,
+                        field1_kind,
+                        field2_kind,
+                    )?;
+                }
+            }
+            FieldsShape::Arbitrary { .. } => {
+                match arg_layout.variants {
+                    abi::Variants::Multiple { .. } => return Err(CannotUseFpConv),
+                    abi::Variants::Single { .. } => (),
+                }
+                for i in arg_layout.fields.index_by_increasing_offset() {
+                    let field = arg_layout.field(cx, i);
+                    should_use_fp_conv_helper(cx, &field, xlen, flen, field1_kind, field2_kind)?;
+                }
+            }
+        },
+    }
+    Ok(())
+}
+
+fn should_use_fp_conv<'a, Ty, C>(
+    cx: &C,
+    arg: &TyAndLayout<'a, Ty>,
+    xlen: u64,
+    flen: u64,
+) -> Option<FloatConv>
+where
+    Ty: TyAbiInterface<'a, C> + Copy,
+    C: HasDataLayout,
+{
+    let mut field1_kind = RegPassKind::Unknown;
+    let mut field2_kind = RegPassKind::Unknown;
+    if should_use_fp_conv_helper(cx, arg, xlen, flen, &mut field1_kind, &mut field2_kind).is_err() {
+        return None;
+    }
+    match (field1_kind, field2_kind) {
+        (RegPassKind::Integer(l), RegPassKind::Float(r)) => Some(FloatConv::MixedPair(l, r)),
+        (RegPassKind::Float(l), RegPassKind::Integer(r)) => Some(FloatConv::MixedPair(l, r)),
+        (RegPassKind::Float(l), RegPassKind::Float(r)) => Some(FloatConv::FloatPair(l, r)),
+        (RegPassKind::Float(f), RegPassKind::Unknown) => Some(FloatConv::Float(f)),
+        _ => None,
+    }
+}
+
+fn classify_ret<'a, Ty, C>(cx: &C, arg: &mut ArgAbi<'a, Ty>, xlen: u64, flen: u64) -> bool
+where
+    Ty: TyAbiInterface<'a, C> + Copy,
+    C: HasDataLayout,
+{
+    if let Some(conv) = should_use_fp_conv(cx, &arg.layout, xlen, flen) {
+        match conv {
+            FloatConv::Float(f) => {
+                arg.cast_to(f);
+            }
+            FloatConv::FloatPair(l, r) => {
+                arg.cast_to(CastTarget::pair(l, r));
+            }
+            FloatConv::MixedPair(l, r) => {
+                arg.cast_to(CastTarget::pair(l, r));
+            }
+        }
+        return false;
+    }
+
+    let total = arg.layout.size;
+
+    // "Scalars wider than 2✕XLEN are passed by reference and are replaced in
+    // the argument list with the address."
+    // "Aggregates larger than 2✕XLEN bits are passed by reference and are
+    // replaced in the argument list with the address, as are C++ aggregates
+    // with nontrivial copy constructors, destructors, or vtables."
+    if total.bits() > 2 * xlen {
+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.
+        if is_loongarch_aggregate(arg) {
+            arg.make_indirect();
+        }
+        return true;
+    }
+
+    let xlen_reg = match xlen {
+        32 => Reg::i32(),
+        64 => Reg::i64(),
+        _ => unreachable!("Unsupported XLEN: {}", xlen),
+    };
+    if is_loongarch_aggregate(arg) {
+        if total.bits() <= xlen {
+            arg.cast_to(xlen_reg);
+        } else {
+            arg.cast_to(Uniform { unit: xlen_reg, total: Size::from_bits(xlen * 2) });
+        }
+        return false;
+    }
+
+    // "When passed in registers, scalars narrower than XLEN bits are widened
+    // according to the sign of their type up to 32 bits, then sign-extended to
+    // XLEN bits."
+    extend_integer_width(arg, xlen);
+    false
+}
+
+fn classify_arg<'a, Ty, C>(
+    cx: &C,
+    arg: &mut ArgAbi<'a, Ty>,
+    xlen: u64,
+    flen: u64,
+    is_vararg: bool,
+    avail_gprs: &mut u64,
+    avail_fprs: &mut u64,
+) where
+    Ty: TyAbiInterface<'a, C> + Copy,
+    C: HasDataLayout,
+{
+    if !is_vararg {
+        match should_use_fp_conv(cx, &arg.layout, xlen, flen) {
+            Some(FloatConv::Float(f)) if *avail_fprs >= 1 => {
+                *avail_fprs -= 1;
+                arg.cast_to(f);
+                return;
+            }
+            Some(FloatConv::FloatPair(l, r)) if *avail_fprs >= 2 => {
+                *avail_fprs -= 2;
+                arg.cast_to(CastTarget::pair(l, r));
+                return;
+            }
+            Some(FloatConv::MixedPair(l, r)) if *avail_fprs >= 1 && *avail_gprs >= 1 => {
+                *avail_gprs -= 1;
+                *avail_fprs -= 1;
+                arg.cast_to(CastTarget::pair(l, r));
+                return;
+            }
+            _ => (),
+        }
+    }
+
+    let total = arg.layout.size;
+    let align = arg.layout.align.abi.bits();
+
+    // "Scalars wider than 2✕XLEN are passed by reference and are replaced in
+    // the argument list with the address."
+    // "Aggregates larger than 2✕XLEN bits are passed by reference and are
+    // replaced in the argument list with the address, as are C++ aggregates
+    // with nontrivial copy constructors, destructors, or vtables."
+    if total.bits() > 2 * xlen {
+        // We rely on the LLVM backend lowering code to lower passing a scalar larger than 2*XLEN.
+        if is_loongarch_aggregate(arg) {
+            arg.make_indirect();
+        }
+        if *avail_gprs >= 1 {
+            *avail_gprs -= 1;
+        }
+        return;
+    }
+
+    let double_xlen_reg = match xlen {
+        32 => Reg::i64(),
+        64 => Reg::i128(),
+        _ => unreachable!("Unsupported XLEN: {}", xlen),
+    };
+
+    let xlen_reg = match xlen {
+        32 => Reg::i32(),
+        64 => Reg::i64(),
+        _ => unreachable!("Unsupported XLEN: {}", xlen),
+    };
+
+    if total.bits() > xlen {
+        let align_regs = align > xlen;
+        if is_loongarch_aggregate(arg) {
+            arg.cast_to(Uniform {
+                unit: if align_regs { double_xlen_reg } else { xlen_reg },
+                total: Size::from_bits(xlen * 2),
+            });
+        }
+        if align_regs && is_vararg {
+            *avail_gprs -= *avail_gprs % 2;
+        }
+        if *avail_gprs >= 2 {
+            *avail_gprs -= 2;
+        } else {
+            *avail_gprs = 0;
+        }
+        return;
+    } else if is_loongarch_aggregate(arg) {
+        arg.cast_to(xlen_reg);
+        if *avail_gprs >= 1 {
+            *avail_gprs -= 1;
+        }
+        return;
+    }
+
+    // "When passed in registers, scalars narrower than XLEN bits are widened
+    // according to the sign of their type up to 32 bits, then sign-extended to
+    // XLEN bits."
+    if *avail_gprs >= 1 {
+        extend_integer_width(arg, xlen);
+        *avail_gprs -= 1;
+    }
+}
+
+fn extend_integer_width<'a, Ty>(arg: &mut ArgAbi<'a, Ty>, xlen: u64) {
+    if let Abi::Scalar(scalar) = arg.layout.abi {
+        if let abi::Int(i, _) = scalar.primitive() {
+            // 32-bit integers are always sign-extended
+            if i.size().bits() == 32 && xlen > 32 {
+                if let PassMode::Direct(ref mut attrs) = arg.mode {
+                    attrs.ext(ArgExtension::Sext);
+                    return;
+                }
+            }
+        }
+    }
+
+    arg.extend_integer_width_to(xlen);
+}
+
+pub fn compute_abi_info<'a, Ty, C>(cx: &C, fn_abi: &mut FnAbi<'a, Ty>)
+where
+    Ty: TyAbiInterface<'a, C> + Copy,
+    C: HasDataLayout,
+{
+    let flen = 64;
+    let xlen = cx.data_layout().pointer_size.bits();
+
+    let mut avail_gprs = 8;
+    let mut avail_fprs = 8;
+
+    if !fn_abi.ret.is_ignore() {
+        if classify_ret(cx, &mut fn_abi.ret, xlen, flen) {
+            avail_gprs -= 1;
+        }
+    }
+
+    for (i, arg) in fn_abi.args.iter_mut().enumerate() {
+        if arg.is_ignore() {
+            continue;
+        }
+        classify_arg(
+            cx,
+            arg,
+            xlen,
+            flen,
+            i >= fn_abi.fixed_count as usize,
+            &mut avail_gprs,
+            &mut avail_fprs,
+        );
+    }
+}
+
diff -urN rustc-1.65.0-src.ori/compiler/rustc_target/src/abi/call/mod.rs rustc-1.65.0-src/compiler/rustc_target/src/abi/call/mod.rs
--- rustc-1.65.0-src.ori/compiler/rustc_target/src/abi/call/mod.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_target/src/abi/call/mod.rs	2022-12-03 17:24:35.058805290 +0800
@@ -10,6 +10,7 @@
 mod avr;
 mod bpf;
 mod hexagon;
+mod loongarch64;
 mod m68k;
 mod mips;
 mod mips64;
@@ -696,6 +697,7 @@
             "amdgpu" => amdgpu::compute_abi_info(cx, self),
             "arm" => arm::compute_abi_info(cx, self),
             "avr" => avr::compute_abi_info(self),
+            "loongarch64" => loongarch64::compute_abi_info(cx, self),
             "m68k" => m68k::compute_abi_info(self),
             "mips" => mips::compute_abi_info(cx, self),
             "mips64" => mips64::compute_abi_info(cx, self),
diff -urN rustc-1.65.0-src.ori/compiler/rustc_target/src/spec/loongarch64_unknown_linux_gnu.rs rustc-1.65.0-src/compiler/rustc_target/src/spec/loongarch64_unknown_linux_gnu.rs
--- rustc-1.65.0-src.ori/compiler/rustc_target/src/spec/loongarch64_unknown_linux_gnu.rs	1970-01-01 08:00:00.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_target/src/spec/loongarch64_unknown_linux_gnu.rs	2022-12-03 17:24:35.062805391 +0800
@@ -0,0 +1,18 @@
+use crate::spec::{CodeModel, Target, TargetOptions};
+
+pub fn target() -> Target {
+    Target {
+        llvm_target: "loongarch64-unknown-linux-gnu".into(),
+        pointer_width: 64,
+        data_layout: "e-m:e-i8:8:32-i16:16:32-i64:64-n32:64-S128".into(),
+        arch: "loongarch64".into(),
+        options: TargetOptions {
+            code_model: Some(CodeModel::Medium),
+            cpu: "generic-la64".into(),
+            features: "+d".into(),
+            llvm_abiname: "lp64d".into(),
+            max_atomic_width: Some(64),
+           ..super::linux_gnu_base::opts()
+        },
+    }
+}
diff -urN rustc-1.65.0-src.ori/compiler/rustc_target/src/spec/mod.rs rustc-1.65.0-src/compiler/rustc_target/src/spec/mod.rs
--- rustc-1.65.0-src.ori/compiler/rustc_target/src/spec/mod.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/compiler/rustc_target/src/spec/mod.rs	2022-12-03 17:24:35.062805391 +0800
@@ -919,6 +919,7 @@
     ("mipsisa64r6-unknown-linux-gnuabi64", mipsisa64r6_unknown_linux_gnuabi64),
     ("mipsisa64r6el-unknown-linux-gnuabi64", mipsisa64r6el_unknown_linux_gnuabi64),
     ("mipsel-unknown-linux-gnu", mipsel_unknown_linux_gnu),
+    ("loongarch64-unknown-linux-gnu", loongarch64_unknown_linux_gnu),
     ("powerpc-unknown-linux-gnu", powerpc_unknown_linux_gnu),
     ("powerpc-unknown-linux-gnuspe", powerpc_unknown_linux_gnuspe),
     ("powerpc-unknown-linux-musl", powerpc_unknown_linux_musl),
diff -urN rustc-1.65.0-src.ori/library/std/src/env.rs rustc-1.65.0-src/library/std/src/env.rs
--- rustc-1.65.0-src.ori/library/std/src/env.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/library/std/src/env.rs	2022-12-03 17:24:35.062805391 +0800
@@ -888,6 +888,7 @@
     /// - x86_64
     /// - arm
     /// - aarch64
+    /// - loongarch64 
     /// - m68k
     /// - mips
     /// - mips64
diff -urN rustc-1.65.0-src.ori/library/std/src/os/linux/raw.rs rustc-1.65.0-src/library/std/src/os/linux/raw.rs
--- rustc-1.65.0-src.ori/library/std/src/os/linux/raw.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/library/std/src/os/linux/raw.rs	2022-12-03 17:24:35.062805391 +0800
@@ -236,7 +236,8 @@
     target_arch = "s390x",
     target_arch = "sparc64",
     target_arch = "riscv64",
-    target_arch = "riscv32"
+    target_arch = "riscv32",
+    target_arch = "loongarch64"
 ))]
 mod arch {
     #[stable(feature = "raw_ext", since = "1.1.0")]
diff -urN rustc-1.65.0-src.ori/library/std/src/sys/common/alloc.rs rustc-1.65.0-src/library/std/src/sys/common/alloc.rs
--- rustc-1.65.0-src.ori/library/std/src/sys/common/alloc.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/library/std/src/sys/common/alloc.rs	2022-12-03 17:24:35.062805391 +0800
@@ -21,6 +21,7 @@
 #[cfg(all(any(
     target_arch = "x86_64",
     target_arch = "aarch64",
+    target_arch = "loongarch64",
     target_arch = "mips64",
     target_arch = "s390x",
     target_arch = "sparc64",
diff -urN rustc-1.65.0-src.ori/library/unwind/src/libunwind.rs rustc-1.65.0-src/library/unwind/src/libunwind.rs
--- rustc-1.65.0-src.ori/library/unwind/src/libunwind.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/library/unwind/src/libunwind.rs	2022-12-03 17:24:35.062805391 +0800
@@ -45,6 +45,9 @@
 #[cfg(target_arch = "m68k")]
 pub const unwinder_private_data_size: usize = 2;
 
+#[cfg(target_arch = "loongarch64")]
+pub const unwinder_private_data_size: usize = 2;
+
 #[cfg(target_arch = "mips")]
 pub const unwinder_private_data_size: usize = 2;
 
diff -urN rustc-1.65.0-src.ori/src/bootstrap/bootstrap.py rustc-1.65.0-src/src/bootstrap/bootstrap.py
--- rustc-1.65.0-src.ori/src/bootstrap/bootstrap.py	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/src/bootstrap/bootstrap.py	2022-12-03 17:24:35.062805391 +0800
@@ -303,6 +303,7 @@
         'i486': 'i686',
         'i686': 'i686',
         'i786': 'i686',
+        'loongarch64': 'loongarch64',        
         'm68k': 'm68k',
         'powerpc': 'powerpc',
         'powerpc64': 'powerpc64',
diff -urN rustc-1.65.0-src.ori/src/bootstrap/builder.rs rustc-1.65.0-src/src/bootstrap/builder.rs
--- rustc-1.65.0-src.ori/src/bootstrap/builder.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/src/bootstrap/builder.rs	2022-12-03 17:24:35.062805391 +0800
@@ -2056,9 +2056,9 @@
             }
         }
 
-        if self.config.locked_deps {
-            cargo.arg("--locked");
-        }
+        //if self.config.locked_deps {
+        //    cargo.arg("--locked");
+        //}
         if self.config.vendor || self.is_sudo {
             cargo.arg("--frozen");
         }
diff -urN rustc-1.65.0-src.ori/src/bootstrap/native.rs rustc-1.65.0-src/src/bootstrap/native.rs
--- rustc-1.65.0-src.ori/src/bootstrap/native.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/src/bootstrap/native.rs	2022-12-03 17:24:35.062805391 +0800
@@ -348,7 +348,7 @@
         let llvm_targets = match &builder.config.llvm_targets {
             Some(s) => s,
             None => {
-                "AArch64;ARM;BPF;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\
+                "AArch64;ARM;BPF;Hexagon;LoongArch;MSP430;Mips;NVPTX;PowerPC;RISCV;\
                      Sparc;SystemZ;WebAssembly;X86"
             }
         };
diff -urN rustc-1.65.0-src.ori/src/bootstrap/tool.rs rustc-1.65.0-src/src/bootstrap/tool.rs
--- rustc-1.65.0-src.ori/src/bootstrap/tool.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/src/bootstrap/tool.rs	2022-12-03 17:24:35.062805391 +0800
@@ -198,7 +198,7 @@
                       that will update the dependency graph to ensure that \
                       these crates all share the same feature set"
             );
-            panic!("tools should not compile multiple copies of the same crate");
+            //panic!("tools should not compile multiple copies of the same crate");
         }
 
         builder.save_toolstate(
diff -urN rustc-1.65.0-src.ori/src/librustdoc/clean/cfg.rs rustc-1.65.0-src/src/librustdoc/clean/cfg.rs
--- rustc-1.65.0-src.ori/src/librustdoc/clean/cfg.rs	2022-11-02 22:36:24.000000000 +0800
+++ rustc-1.65.0-src/src/librustdoc/clean/cfg.rs	2022-12-03 17:24:35.062805391 +0800
@@ -515,6 +515,8 @@
                         "aarch64" => "AArch64",
                         "arm" => "ARM",
                         "asmjs" => "JavaScript",
+                        "loongarch" => "LoongArch",
+                        "loongarch64" => "LoongArch64",
                         "m68k" => "M68k",
                         "mips" => "MIPS",
                         "mips64" => "MIPS-64",
diff -urN rustc-1.65.0-src.ori/src/tools/build-manifest/src/main.rs rustc-1.65.0-src/src/tools/build-manifest/src/main.rs
--- rustc-1.65.0-src.ori/src/tools/build-manifest/src/main.rs	2022-11-02 22:36:25.000000000 +0800
+++ rustc-1.65.0-src/src/tools/build-manifest/src/main.rs	2022-12-03 17:24:35.062805391 +0800
@@ -28,6 +28,8 @@
     "i686-pc-windows-gnu",
     "i686-pc-windows-msvc",
     "i686-unknown-linux-gnu",
+    "loongarch-unknown-linux-gnu",
+    "loongarch64-unknown-linux-gnu",
     "mips-unknown-linux-gnu",
     "mips64-unknown-linux-gnuabi64",
     "mips64el-unknown-linux-gnuabi64",
@@ -99,6 +101,8 @@
     "i686-unknown-freebsd",
     "i686-unknown-linux-gnu",
     "i686-unknown-linux-musl",
+    "loongarch-unknown-linux-gnu",
+    "loongarch64-unknown-linux-gnu",
     "m68k-unknown-linux-gnu",
     "mips-unknown-linux-gnu",
     "mips-unknown-linux-musl",
